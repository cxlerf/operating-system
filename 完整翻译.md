However, the comparison in Figure 38.8 does capture the essential differences, and is useful for understanding tradeoffs across RAID levels.
==然而，图 38.8 中的比较确实捕捉到了本质区别，并且对于理解不同 RAID 级别之间的权衡非常有用。==

For the latency analysis, we simply use $T$ to represent the time that a request to a single disk would take.
==对于延迟分析，我们简单地使用 $T$ 来表示对单个磁盘的请求所需的时间。==

To conclude, if you strictly want performance and do not care about reliability, striping is obviously best.
==总而言之，如果你只追求性能而不关心可靠性，条带化（striping）显然是最好的。==

If, however, you want random I/O performance and reliability, mirroring is the best; the cost you pay is in lost capacity.
==然而，如果你想要随机 I/O 性能和可靠性，镜像（mirroring）是最好的；你付出的代价是容量的损失。==

If capacity and reliability are your main goals, then RAID-5 is the winner; the cost you pay is in small-write performance.
==如果容量和可靠性是你的主要目标，那么 RAID-5 就是赢家；你付出的代价是小写（small-write）性能。==

Finally, if you are always doing sequential I/O and want to maximize capacity, RAID-5 also makes the most sense.
==最后，如果你总是进行顺序 I/O 并希望最大化容量，RAID-5 也是最合理的选择。==

**38.9 Other Interesting RAID Issues**
==**38.9 其他有趣的 RAID 问题**==

There are a number of other interesting ideas that one could (and perhaps should) discuss when thinking about RAID.
==在思考 RAID 时，还有许多其他有趣的想法可以（也或许应该）讨论。==

Here are some things we might eventually write about.
==以下是我们最终可能会写到的一些内容。==

For example, there are many other RAID designs, including Levels 2 and 3 from the original taxonomy, and Level 6 to tolerate multiple disk faults [C+04].
==例如，还有许多其他的 RAID 设计，包括原始分类中的级别 2 和 3，以及可以容忍多个磁盘故障的级别 6 [C+04]。==

There is also what the RAID does when a disk fails; sometimes it has a **hot spare** sitting around to fill in for the failed disk.
==还有 RAID 在磁盘故障时的表现；有时它会有一个**热备盘**（hot spare）在旁边随时待命，以填补故障磁盘的空缺。==

What happens to performance under failure, and performance during reconstruction of the failed disk?
==故障下的性能表现如何，以及故障磁盘重建期间的性能表现又如何？==

There are also more realistic fault models, to take into account **latent sector errors** or **block corruption** [B+08], and lots of techniques to handle such faults (see the data integrity chapter for details).
==还有更现实的故障模型，需要考虑**潜伏扇区错误**或**数据块损坏** [B+08]，以及许多处理此类故障的技术（详见数据完整性章节）。==

Finally, you can even build RAID as a software layer: such **software RAID** systems are cheaper but have other problems, including the **consistent-update problem** [DAA05].
==最后，你甚至可以将 RAID 构建为软件层：这种**软件 RAID** 系统更便宜，但也有其他问题，包括**一致性更新问题** [DAA05]。==

**38.10 Summary**
==**38.10 总结**==

We have discussed RAID.
==我们已经讨论了 RAID。==

RAID transforms a number of independent disks into a large, more capacious, and more reliable single entity; importantly, it does so transparently, and thus hardware and software above is relatively oblivious to the change.
==RAID 将多个独立的磁盘转化为一个巨大、容量更大且更可靠的单一实体；重要的是，它是透明地完成这一过程的，因此上层的硬件和软件对这种变化相对无感。==

There are many possible RAID levels to choose from, and the exact RAID level to use depends heavily on what is important to the end-user.
==有许多可能的 RAID 级别可供选择，具体使用哪种 RAID 级别很大程度上取决于对终端用户而言什么才是重要的。==

For example, mirrored RAID is simple, reliable, and generally provides good performance but at a high capacity cost.
==例如，镜像 RAID 简单、可靠，通常提供良好的性能，但容量成本很高。==

RAID-5, in contrast, is reliable and better from a capacity standpoint, but performs quite poorly when there are small writes in the workload.
==相比之下，RAID-5 是可靠的，从容量角度看更好，但当工作负载中存在小额写入时，性能表现相当糟糕。==

Picking a RAID and setting its parameters (chunk size, number of disks, etc.) properly for a particular workload is challenging, and remains more of an art than a science.
==为特定工作负载选择合适的 RAID 并正确设置其参数（块大小、磁盘数量等）是具有挑战性的，这在很大程度上仍然是一门艺术而非科学。==

**39 Interlude: Files and Directories**
==**39 插曲：文件和目录**==

Thus far we have seen the development of two key operating system abstractions: the **process**, which is a virtualization of the CPU, and the **address space**, which is a virtualization of memory.
==到目前为止，我们已经看到了两个关键操作系统抽象的发展：**进程**（CPU 的虚拟化）和**地址空间**（内存的虚拟化）。==

In tandem, these two abstractions allow a program to run as if it is in its own private, isolated world; as if it has its own processor (or processors); as if it has its own memory.
==这两个抽象协同工作，使程序运行起来就好像处于自己私有的、隔离的世界中；就好像它拥有自己的处理器（或多个处理器）；就好像它拥有自己的内存。==

This illusion makes programming the system much easier and thus is prevalent today not only on desktops and servers but increasingly on all programmable platforms including mobile phones and the like.
==这种错觉使系统编程变得更加容易，因此在当今不仅在台式机和服务器上流行，而且越来越多地出现在包括移动电话在内的所有可编程平台上。==

In this section, we add one more critical piece to the virtualization puzzle: **persistent storage**.
==在本节中，我们为虚拟化拼图增加了一个关键部分：**持久性存储**。==

A persistent-storage device, such as a classic **hard disk drive** or a more modern **solid-state storage device**, stores information permanently (or at least, for a long time).
==持久性存储设备，如经典的**硬盘驱动器**或更现代的**固态存储设备**，可以永久（或者至少是长时间地）存储信息。==

Unlike memory, whose contents are lost when there is a power loss, a persistent-storage device keeps such data intact.
==与内存不同（内存的内容在断电时会丢失），持久性存储设备可以保持此类数据的完整。==

Thus, the OS must take extra care with such a device: this is where users keep data that they really care about.
==因此，操作系统必须对这种设备格外小心：这是用户存放他们真正关心的数据的地方。==

**CRUX: HOW TO MANAGE A PERSISTENT DEVICE**
==**核心问题：如何管理持久性设备**==

How should the OS manage a persistent device?
==操作系统应该如何管理持久性设备？==

What are the APIs?
==有哪些 API？==

What are the important aspects of the implementation?
==实现中的重要方面有哪些？==

Thus, in the next few chapters, we will explore critical techniques for managing persistent data, focusing on methods to improve performance and reliability.
==因此，在接下来的几章中，我们将探索管理持久性数据的关键技术，重点关注提高性能和可靠性的方法。==

We begin, however, with an overview of the API: the interfaces you’ll expect to see when interacting with a UNIX file system.
==然而，我们首先概述 API：即在与 UNIX 文件系统交互时你期望看到的接口。==

**39.1 Files And Directories**
==**39.1 文件和目录**==

Two key abstractions have developed over time in the virtualization of storage.
==在存储虚拟化的过程中，随着时间的推移发展出了两个关键抽象。==

The first is the **file**.
==第一个是**文件**。==

A file is simply a linear array of bytes, each of which you can read or write.
==文件只是一个简单的字节线性数组，你可以读取或写入其中的每一个字节。==

Each file has some kind of **low-level name**, usually a number of some kind; often, the user is not aware of this name (as we will see).
==每个文件都有某种**低级名称**，通常是某种数字；通常情况下，用户并不知道这个名称（我们稍后会看到）。==

For historical reasons, the low-level name of a file is often referred to as its **inode number** (**i-number**).
==由于历史原因，文件的低级名称通常被称为其 **inode 编号**（**i-number**）。==

We’ll be learning a lot more about inodes in future chapters; for now, just assume that each file has an inode number associated with it.
==在未来的章节中，我们将学习更多关于 inode 的知识；目前，只需假设每个文件都关联一个 inode 编号。==

In most systems, the OS does not know much about the structure of the file (e.g., whether it is a picture, or a text file, or C code); rather, the responsibility of the file system is simply to store such data persistently on disk and make sure that when you request the data again, you get what you put there in the first place.
==在大多数系统中，操作系统对文件的结构了解不多（例如，它是图片、文本文件还是 C 代码）；相反，文件系统的责任只是将此类数据持久地存储在磁盘上，并确保当你再次请求数据时，你能得到最初存放的内容。==

Doing so is not as simple as it seems!
==这样做并不像看起来那么简单！==

The second abstraction is that of a **directory**.
==第二个抽象是**目录**。==

A directory, like a file, also has a low-level name (i.e., an inode number), but its contents are quite specific: it contains a list of (user-readable name, low-level name) pairs.
==目录和文件一样，也有一个低级名称（即 inode 编号），但它的内容非常特殊：它包含一个（用户可读名称，低级名称）对的列表。==

For example, let’s say there is a file with the low-level name “10”, and it is referred to by the user-readable name of “foo”.
==例如，假设有一个低级名称为“10”的文件，用户可读的名称为“foo”。==

The directory that “foo” resides in thus would have an entry (“foo”, “10”) that maps the user-readable name to the low-level name.
==因此，“foo”所在的目录将包含一个条目（“foo”，“10”），该条目将用户可读名称映射到低级名称。==

Each entry in a directory refers to either files or other directories.
==目录中的每个条目要么指向文件，要么指向其他目录。==

By placing directories within other directories, users are able to build an arbitrary **directory tree** (or **directory hierarchy**), under which all files and directories are stored.
==通过将目录放置在其他目录中，用户能够构建一个任意的**目录树**（或**目录层级**），所有的文件和目录都存储在其中。==

The directory hierarchy starts at a **root directory** (in UNIX-based systems, the root directory is simply referred to as /) and uses some kind of separator to name subsequent sub-directories until the desired file or directory is named.
==目录层级始于**根目录**（在基于 UNIX 的系统中，根目录简称为 /），并使用某种分隔符来命名后续的子目录，直到命名所需的文件夹或文件。==

For example, if a user created a directory `foo` in the root directory `/`, and then created a file `bar.txt` in the directory `foo`, we could refer to the file by its **absolute pathname**, which in this case would be `/foo/bar.txt`.
==例如，如果用户在根目录 `/` 中创建了一个目录 `foo`，然后在目录 `foo` 中创建了一个文件 `bar.txt`，我们可以通过其**绝对路径名**来引用该文件，在这种情况下就是 `/foo/bar.txt`。==

See Figure 39.1 for a more complex directory tree; valid directories in the example are `/`, `/foo`, `/bar`, `/bar/bar`, `/bar/foo` and valid files are `/foo/bar.txt` and `/bar/foo/bar.txt`.
==请参见图 39.1 了解更复杂的目录树；示例中的有效目录是 `/`, `/foo`, `/bar`, `/bar/bar`, `/bar/foo`，有效文件是 `/foo/bar.txt` 和 `/bar/foo/bar.txt`。==

**TIP: THINK CAREFULLY ABOUT NAMING**
==**提示：仔细思考命名问题**==

Naming is an important aspect of computer systems [SK09].
==命名是计算机系统的一个重要方面 [SK09]。==

In UNIX systems, virtually everything that you can think of is named through the file system.
==在 UNIX 系统中，几乎所有你能想到的东西都是通过文件系统命名的。==

Beyond just files, devices, pipes, and even processes [K84] can be found in what looks like a plain old file system.
==除了文件之外，设备、管道甚至进程 [K84] 都可以出现在看起来像普通文件系统的结构中。==

This uniformity of naming eases your conceptual model of the system, and makes the system simpler and more modular.
==这种命名的统一性简化了你对系统的概念模型，使系统更简单、更模块化。==

Thus, whenever creating a system or interface, think carefully about what names you are using.
==因此，每当创建系统或接口时，请仔细思考你正在使用的名称。==

Directories and files can have the same name as long as they are in different locations in the file-system tree (e.g., there are two files named `bar.txt` in the figure, `/foo/bar.txt` and `/bar/foo/bar.txt`).
==只要目录和文件位于文件系统树的不同位置，它们就可以拥有相同的名称（例如，图中两个名为 `bar.txt` 的文件，分别是 `/foo/bar.txt` 和 `/bar/foo/bar.txt`）。==

You may also notice that the file name in this example often has two parts: `bar` and `txt`, separated by a period.
==你可能还会注意到，本例中的文件名通常由两部分组成：`bar` 和 `txt`，由句点分隔。==

The first part is an arbitrary name, whereas the second part of the file name is usually used to indicate the **type** of the file, e.g., whether it is C code (e.g., `.c`), or an image (e.g., `.jpg`), or a music file (e.g., `.mp3`).
==第一部分是任意名称，而文件名的第二部分通常用于指示文件的**类型**，例如，它是 C 代码（如 `.c`）、图像（如 `.jpg`）还是音乐文件（如 `.mp3`）。==

However, this is usually just a **convention**: there is usually no enforcement that the data contained in a file named `main.c` is indeed C source code.
==然而，这通常只是一个**惯例**：通常并不强制要求名为 `main.c` 的文件中包含的数据确实是 C 源代码。==

Thus, we can see one great thing provided by the file system: a convenient way to **name** all the files we are interested in.
==因此，我们可以看到文件系统提供的一件伟大的事情：一种方便的方式来**命名**我们感兴趣的所有文件。==

Names are important in systems as the first step to accessing any resource is being able to name it.
==名称在系统中非常重要，因为访问任何资源的第一步就是能够对其命名。==

In UNIX systems, the file system thus provides a unified way to access files on disk, USB stick, CD-ROM, many other devices, and in fact many other things, all located under the single directory tree.
==因此，在 UNIX 系统中，文件系统提供了一种统一的方式来访问磁盘、USB 闪存盘、CD-ROM、许多其他设备以及实际上许多其他东西，所有这些都位于单一的目录树下。==

**39.2 The File System Interface**
==**39.2 文件系统接口**==

Let’s now discuss the file system interface in more detail.
==现在让我们更详细地讨论文件系统接口。==

We’ll start with the basics of creating, accessing, and deleting files.
==我们将从创建、访问和删除文件的基础知识开始。==

You may think this is straightforward, but along the way we’ll discover the mysterious call that is used to remove files, known as `unlink()`.
==你可能认为这很简单，但在此过程中我们将发现用于删除文件的神秘调用，称为 `unlink()`。==

Hopefully, by the end of this chapter, this mystery won’t be so mysterious to you!
==希望到本章结束时，这个秘密对你来说不再那么神秘！==

**39.3 Creating Files**
==**39.3 创建文件**==

We’ll start with the most basic of operations: creating a file.
==我们将从最基本的操作开始：创建一个文件。==

This can be accomplished with the `open` system call; by calling `open()` and passing it the `O_CREAT` flag, a program can create a new file.
==这可以通过 `open` 系统调用来完成；通过调用 `open()` 并传递 `O_CREAT` 标志，程序可以创建一个新文件。==

Here is some example code to create a file called “foo” in the current working directory:
==下面是在当前工作目录中创建名为“foo”的文件的示例代码：==

```c
int fd = open("foo", O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR);
```

**ASIDE: THE CREAT() SYSTEM CALL**
==**补充：CREAT() 系统调用**==

The older way of creating a file is to call `creat()`, as follows:
==创建文件的旧方法是调用 `creat()`，如下所示：==

```c
==// 选项：添加第二个标志以设置权限==
int fd = creat("foo");
```

You can think of `creat()` as `open()` with the following flags: `O_CREAT | O_WRONLY | O_TRUNC`.
==你可以将 `creat()` 视为带有以下标志的 `open()`：`O_CREAT | O_WRONLY | O_TRUNC`。==

Because `open()` can create a file, the usage of `creat()` has somewhat fallen out of favor (indeed, it could just be implemented as a library call to `open()`); however, it does hold a special place in UNIX lore.
==因为 `open()` 也可以创建文件，所以 `creat()` 的使用在某种程度上已经不再受青睐（实际上，它可以简单地实现为对 `open()` 的库调用）；然而，它在 UNIX 传说中确实占有特殊地位。==

Specifically, when Ken Thompson was asked what he would do differently if he were redesigning UNIX, he replied: “I’d spell creat with an e.”
==具体来说，当 Ken Thompson 被问到如果重新设计 UNIX 他会做哪些不同的改进时，他回答道：“我会给 creat 加个 e。”==

The routine `open()` takes a number of different flags.
==`open()` 例程接受许多不同的标志。==

In this example, the second parameter creates the file (`O_CREAT`) if it does not exist, ensures that the file can only be written to (`O_WRONLY`), and, if the file already exists, truncates it to a size of zero bytes thus removing any existing content (`O_TRUNC`).
==在本例中，第二个参数在文件不存在时创建文件（`O_CREAT`），确保文件只能被写入（`O_WRONLY`），并且如果文件已经存在，则将其截断为零字节，从而删除任何现有内容（`O_TRUNC`）。==

The third parameter specifies permissions, in this case making the file readable and writable by the owner.
==第三个参数指定权限，在本例中使文件对所有者可读写。==

One important aspect of `open()` is what it returns: a **file descriptor**.
==`open()` 的一个重要方面是它的返回值：一个**文件描述符**。==

A file descriptor is just an integer, private per process, and is used in UNIX systems to access files; thus, once a file is opened, you use the file descriptor to read or write the file, assuming you have permission to do so.
==文件描述符只是一个整数，对每个进程而言是私有的，在 UNIX 系统中用于访问文件；因此，一旦文件被打开，你就可以使用文件描述符来读取或写入文件，前提是你拥有相应的权限。==

In this way, a file descriptor is a **capability** [L84], i.e., an opaque handle that gives you the power to perform certain operations.
==通过这种方式，文件描述符是一种**能力**（capability）[L84]，即一个赋予你执行某些操作权限的不透明句柄。==

Another way to think of a file descriptor is as a pointer to an object of type file; once you have such an object, you can call other “methods” to access the file, like `read()` and `write()` (we’ll see how to do so below).
==另一种理解文件描述符的方式是将其视为指向文件类型对象的指针；一旦拥有了这样一个对象，你就可以调用其他“方法”来访问文件，例如 `read()` 和 `write()`（我们将在下面看到如何操作）。==

As stated above, file descriptors are managed by the operating system on a per-process basis.
==如上所述，文件描述符由操作系统在每个进程的基础上进行管理。==

This means some kind of simple structure (e.g., an array) is kept in the `proc` structure on UNIX systems.
==这意味着在 UNIX 系统的 `proc` 结构中保留了某种简单的结构（例如数组）。==

Here is the relevant piece from the xv6 kernel [CK+08]:
==以下是 xv6 内核中相关的部分 [CK+08]：==

```c
struct proc {
  ...
==  struct file *ofile[NOFILE]; // 已打开的文件==
  ...
};
```

A simple array (with a maximum of `NOFILE` open files), indexed by the file descriptor, tracks which files are opened on a per-process basis.
==一个简单的数组（最多可容纳 `NOFILE` 个打开文件），由文件描述符索引，在每个进程的基础上跟踪哪些文件已打开。==

Each entry of the array is actually just a pointer to a `struct file`, which will be used to track information about the file being read or written; we’ll discuss this further below.
==数组的每个条目实际上只是一个指向 `struct file` 的指针，它将用于跟踪正在读取或写入的文件信息；我们将在下文中进一步讨论。==




The declaration below shows the information available within each directory entry in the **struct dirent** data structure:
==下面的声明显示了 **struct dirent** 数据结构中每个目录项（directory entry）中可用的信息：==

```c
struct dirent {
    char           d_name[256]; // filename
    ino_t          d_ino;       // inode number
    off_t          d_off;       // offset to the next dirent
    unsigned short d_reclen;    // length of this record
    unsigned char  d_type;      // type of file
};
```
```c
struct dirent {
==    char           d_name[256]; // 文件名==
==    ino_t          d_ino;       // i 节点号==
==    off_t          d_off;       // 到下一个目录项的偏移量==
==    unsigned short d_reclen;    // 本条记录的长度==
==    unsigned char  d_type;      // 文件类型==
};
```

Because directories are light on information (basically, just mapping the name to the inode number, along with a few other details), a program may want to call **stat()** on each file to get more information on each, such as its length or other detailed information.
==由于目录包含的信息很少（基本上只是将名称映射到 i 节点号，以及其他一些细节），程序可能希望对每个文件调用 **stat()** 以获取有关每个文件的更多信息，例如其长度或其他详细信息。==

Indeed, this is exactly what **ls** does when you pass it the **-l** flag; try **strace** on **ls** with and without that flag to see for yourself.
==事实上，当你给 **ls** 传递 **-l** 标志时，它正是这么做的；你可以尝试对带和不带该标志的 **ls** 使用 **strace**，亲自查看效果。==

39.13 Deleting Directories
==39.13 删除目录==

Finally, you can delete a directory with a call to **rmdir()** (which is used by the program of the same name, **rmdir**).
==最后，你可以通过调用 **rmdir()** 来删除目录（同名程序 **rmdir** 使用的就是该调用）。==

Unlike file deletion, however, removing directories is more dangerous, as you could potentially delete a large amount of data with a single command.
==然而，与删除文件不同，删除目录更加危险，因为你可能会通过单个命令删除大量数据。==

Thus, **rmdir()** has the requirement that the directory be empty (i.e., only has "." and ".." entries) before it is deleted.
==因此，**rmdir()** 要求目录在被删除之前必须为空（即，仅包含“.”和“..”条目）。==

If you try to delete a non-empty directory, the call to **rmdir()** simply will fail.
==如果你尝试删除一个非空目录，对 **rmdir()** 的调用将直接失败。==

39.14 Hard Links
==39.14 硬链接==

We now come back to the mystery of why removing a file is performed via **unlink()**, by understanding a new way to make an entry in the file system tree, through a system call known as **link()**.
==通过理解一种在文件系统树中创建条目的新方法——即通过名为 **link()** 的系统调用，我们现在回到“为什么删除文件是通过 **unlink()** 执行”的谜题。==

The **link()** system call takes two arguments, an old pathname and a new one; when you "link" a new file name to an old one, you essentially create another way to refer to the same file.
==**link()** 系统调用接受两个参数：一个旧路径名和一个新路径名；当你将一个新文件名“链接”到一个旧文件名时，你实际上创建了引用同一个文件的另一种方式。==

The command-line program **ln** is used to do this, as we see in this example:
==命令行程序 **ln** 用于执行此操作，如我们在本例中所见：==

```
prompt> echo hello > file
prompt> cat file
hello
prompt> ln file file2
prompt> cat file2
hello
```
```
prompt> echo hello > file
prompt> cat file
hello
prompt> ln file file2
prompt> cat file2
hello
```

The way **link()** works is that it simply creates another name in the directory you are creating the link to, and refers it to the same inode number (i.e., low-level name) of the original file.
==**link()** 的工作原理是，它只是在你创建链接的目录中创建另一个名称，并将其指向原始文件的同一个 i 节点号（即低级名称）。==

The file is not copied in any way; rather, you now just have two human-readable names (**file** and **file2**) that both refer to the same file.
==文件本身并没有被以任何方式复制；相反，你现在只是有了两个人类可读的名称（**file** 和 **file2**），它们都指向同一个文件。==

We can even see this in the directory itself, by printing out the inode number of each file:
==我们甚至可以在目录本身中看到这一点，通过打印出每个文件的 i 节点号：==

```
prompt> ls -i file file2
67158084 file
67158084 file2
```
```
prompt> ls -i file file2
67158084 file
67158084 file2
```

By passing the **-i** flag to **ls**, it prints out the inode number of each file (as well as the file name).
==通过给 **ls** 传递 **-i** 标志，它会打印出每个文件的 i 节点号（以及文件名）。==

And thus you can see what link really has done: just make a new reference to the same exact inode number (67158084 in this example).
==因此，你可以看到链接真正做了什么：只是为完全相同的 i 节点号（本例中为 67158084）创建了一个新的引用。==

By now you might be starting to see why **unlink()** is called **unlink()**.
==到目前为止，你可能已经开始理解为什么 **unlink()** 被称为 **unlink()** 了。==

When you create a file, you are really doing two things.
==当你创建一个文件时，你实际上在做两件事。==

First, you are making a structure (the inode) that will track virtually all relevant information about the file, including its size, where its blocks are on disk, and so forth.
==首先，你正在创建一个结构（i 节点），它将跟踪几乎所有与文件相关的信息，包括其大小、其数据块在磁盘上的位置等等。==

Second, you are linking a human-readable name to that file, and putting that link into a directory.
==其次，你正在将一个人类可读的名称链接到该文件，并将该链接放入一个目录中。==

After creating a hard link to a file, the file system perceives no difference between the original file name (**file**) and the newly created file name (**file2**); indeed, they are both just links to the underlying metadata about the file, which is found in inode number 67158084.
==在为文件创建硬链接后，文件系统感知不到原始文件名（**file**）和新创建文件名（**file2**）之间有任何区别；事实上，它们都只是指向该文件底层元数据的链接，这些元数据位于 67158084 号 i 节点中。==

Thus, to remove a file from the file system, we call **unlink()**.
==因此，为了从文件系统中移除一个文件，我们调用 **unlink()**。==

In the example above, we could for example remove the file named **file**, and still access the file without difficulty:
==在上面的例子中，例如我们可以删除名为 **file** 的文件，但仍然可以毫无困难地访问该文件：==

```
prompt> rm file
removed 'file'
prompt> cat file2
hello
```
```
prompt> rm file
removed 'file'
prompt> cat file2
hello
```

The reason this works is because when the file system unlinks file, it checks a **reference count** within the inode number.
==这种方法之所以有效，是因为当文件系统取消对文件的链接时，它会检查 i 节点号中的**引用计数**（reference count）。==

This reference count (sometimes called the **link count**) allows the file system to track how many different file names have been linked to this particular inode.
==这个引用计数（有时称为**链接计数**）允许文件系统跟踪有多少个不同的文件名已链接到这个特定的 i 节点。==

When **unlink()** is called, it removes the "link" between the human-readable name (the file that is being deleted) to the given inode number, and decrements the reference count; only when the reference count reaches zero does the file system also free the inode and related data blocks, and thus truly "delete" the file.
==当 **unlink()** 被调用时，它会移除人类可读名称（正在被删除的文件）与给定 i 节点号之间的“链接”，并递减引用计数；只有当引用计数达到零时，文件系统才会释放 i 节点和相关的数据块，从而真正“删除”文件。==

You can see the reference count of a file using **stat()** of course.
==当然，你可以使用 **stat()** 查看文件的引用计数。==

39.15 Symbolic Links
==39.15 符号链接==

There is one other type of link that is really useful, and it is called a **symbolic link** or sometimes a **soft link**.
==还有另一种非常有用的链接类型，它被称为**符号链接**（symbolic link），有时也称为**软链接**（soft link）。==

Hard links are somewhat limited: you can't create one to a directory (for fear that you will create a cycle in the directory tree); you can't hard link to files in other disk partitions (because inode numbers are only unique within a particular file system, not across file systems); etc.
==硬链接有一定的局限性：你不能创建一个指向目录的硬链接（因为担心会在目录树中创建环路）；你不能硬链接到其他磁盘分区中的文件（因为 i 节点号仅在特定的文件系统内唯一，而不能跨文件系统唯一）；等等。==

Thus, a new type of link called the symbolic link was created.
==因此，一种称为符号链接的新型链接被创造了出来。==

To create such a link, you can use the same program **ln**, but with the **-s** flag.
==要创建这样的链接，你可以使用同一个程序 **ln**，但要加上 **-s** 标志。==

```
prompt> echo hello > file
prompt> ln -s file file2
prompt> cat file2
hello
```
```
prompt> echo hello > file
prompt> ln -s file file2
prompt> cat file2
hello
```

However, beyond this surface similarity, symbolic links are actually quite different from hard links.
==然而，除了这种表面上的相似性之外，符号链接实际上与硬链接大不相同。==

The first difference is that a symbolic link is actually a file itself, of a different type.
==第一个区别是，符号链接本身实际上是一个文件，属于不同的类型。==

The reason that **file2** is 4 bytes is because the way a symbolic link is formed is by holding the pathname of the linked-to file as the data of the link file.
==**file2** 为 4 字节的原因是，符号链接的形成方式是将链接目标的路径名作为链接文件的数据。==

Finally, because of the way symbolic links are created, they leave the possibility for what is known as a **dangling reference**:
==最后，由于符号链接的创建方式，它们留下了所谓**悬空引用**（dangling reference）的可能性：==

```
prompt> echo hello > file
prompt> ln -s file file2
prompt> cat file2
hello
prompt> rm file
prompt> cat file2
cat: file2: No such file or directory
```
```
prompt> echo hello > file
prompt> ln -s file file2
prompt> cat file2
hello
prompt> rm file
prompt> cat file2
cat: file2: No such file or directory
```

39.16 Permission Bits And Access Control Lists
==39.16 权限位与访问控制列表==

The file system also presents a virtual view of a disk, transforming it from a bunch of raw blocks into much more user-friendly files and directories.
==文件系统还呈现了磁盘的虚拟视图，将其从一堆原始块转换为更加用户友好的文件和目录。==

The first form of such mechanisms is the classic UNIX **permission bits**.
==这类机制的第一种形式是经典的 UNIX **权限位**。==

```
prompt> ls -l foo.txt
-rw-r--r-- 1 remzi wheel 0 Aug 24 16:29 foo.txt
```
```
prompt> ls -l foo.txt
-rw-r--r-- 1 remzi wheel 0 Aug 24 16:29 foo.txt
```

We are interested in the permission bits, which are represented by the next nine characters (**rw-r--r--**).
==我们感兴趣的是权限位，由接下来的九个字符（**rw-r--r--**）表示。==

These bits determine, for each regular file, directory, and other entities, exactly who can access it and how.
==这些位决定了对于每个常规文件、目录和其他实体，究竟谁可以访问它以及如何访问。==

The permissions consist of three groupings: what the **owner** of the file can do to it, what someone in a **group** can do to the file, and finally, what anyone (sometimes referred to as **other**) can do.
==权限由三组组成：文件的**所有者**（owner）可以对它做什么，**用户组**（group）中的成员可以对该文件做什么，以及最后，任何人（有时称为**其他人**，other）可以做什么。==

The abilities the owner, group member, or others can have include the ability to **read** the file, **write** it, or **execute** it.
==所有者、组成员或其他人可以拥有的能力包括**读取**（read）文件、**写入**（write）文件或**执行**（execute）文件的能力。==

The owner of the file can readily change these permissions, for example by using the **chmod** command.
==文件的所有者可以随时更改这些权限，例如通过使用 **chmod** 命令。==

For directories, the execute bit behaves a bit differently.
==对于目录，执行位的行为略有不同。==

Specifically, it enables a user (or group, or everyone) to do things like change directories (i.e., **cd**) into the given directory, and, in combination with the writable bit, create files therein.
==具体来说，它使授权用户（或组，或所有人）能够执行诸如进入（即 **cd**）给定目录之类的操作，并且结合写入位，可以在其中创建文件。==

Beyond permissions bits, some file systems include more sophisticated controls in the form of an **access control list (ACL)** per directory.
==除了权限位之外，一些文件系统还以每个目录的**访问控制列表（ACL）**的形式包含更复杂的控制。==

39.17 Making And Mounting A File System
==39.17 创建与挂载文件系统==

This task is accomplished via first **making** file systems, and then **mounting** them to make their contents accessible.
==这项任务通过首先**创建**文件系统，然后**挂载**它们以使其内容可访问来完成。==

To make a file system, most file systems provide a tool, usually referred to as **mkfs**.
==为了创建文件系统，大多数文件系统提供了一个工具，通常被称为 **mkfs**。==

However, once such a file system is created, it needs to be made accessible within the uniform file-system tree via the **mount** program.
==然而，一旦创建了这样的文件系统，就需要通过 **mount** 程序使其在统一的文件系统树中可被访问。==

What **mount** does, quite simply is take an existing directory as a target **mount point** and essentially paste a new file system onto the directory tree at that point.
==**mount** 的作用非常简单，就是将一个现有目录作为目标**挂载点**（mount point），并实质上在该点将一个新的文件系统“粘贴”到目录树上。==

```
prompt> mount -t ext3 /dev/sda1 /home/users
```
```
prompt> mount -t ext3 /dev/sda1 /home/users
```

TIP: BE WARY OF TOCTTOU
==提示：警惕 TOCTTOU==

We today call this the **Time Of Check To Time Of Use (TOCTTOU)** problem.
==我们今天称之为**检查时间与使用时间（TOCTTOU）**问题。==

The **O_NOFOLLOW** flag makes it so that **open()** will fail if the target is a symbolic link, thus avoiding attacks that require said links.
==**O_NOFOLLOW** 标志使得如果目标是符号链接，**open()** 将失败，从而避免了需要利用此类链接的攻击。==

40.2 Overall Organization
==40.2 整体组织==

The first thing we'll need to do is divide the disk into **blocks**; simple file systems use just one block size, and that’s exactly what we’ll do here.
==我们首先需要做的是将磁盘划分为**块**（blocks）；简单文件系统只使用一种块大小，这正是我们在这里要做的。==

Let’s choose a commonly-used size of 4 KB.
==让我们选择一个常用的 4 KB 大小。==

Assume we have a really small disk, with just 64 blocks.
==假设我们有一个非常小的磁盘，只有 64 个块。==

Let’s now think about what we need to store in these blocks to build a file system.
==现在让我们思考一下，为了构建一个文件系统，我们需要在这些块中存储什么。==

Of course, the first thing that comes to mind is user data.
==当然，首先想到的是用户数据。==

Let’s call the region of the disk we use for user data the **data region**.
==我们将磁盘上用于用户数据的区域称为**数据区域**（data region）。==

To store metadata, file systems usually have a structure called an **inode**.
==为了存储元数据，文件系统通常有一个称为 **inode**（i 节点）的结构。==

To accommodate inodes, we’ll need to reserve some space on the disk for them as well.
==为了容纳 i 节点，我们还需要在磁盘上为它们预留一些空间。==

Let’s call this portion of the disk the **inode table**, which simply holds an array of on-disk inodes.
==我们将磁盘的这部分称为 **inode 表**，它只是保存了一个磁盘上 i 节点的数组。==

One primary component that is still needed is some way to track whether inodes or data blocks are free or allocated.
==仍然需要的一个主要组件是某种跟踪 i 节点或数据块是空闲还是已分配的方法。==

We instead choose a simple and popular structure known as a **bitmap**, one for the data region (the **data bitmap**), and one for the inode table (the **inode bitmap**).
==相反，我们选择了一种简单且流行的结构，称为**位图**（bitmap），一个用于数据区域（**数据位图**），一个用于 i 节点表（**i 节点位图**）。==

A bitmap is a simple structure: each bit is used to indicate whether the corresponding object/block is free (0) or in-use (1).
==位图是一个简单的结构：每个位用于指示相应的对象/块是空闲（0）还是在使用中（1）。==

The **superblock** contains information about this particular file system, including, for example, how many inodes and data blocks are in the file system.
==**超级块**（superblock）包含有关此特定文件系统的信息，例如文件系统中有多少个 i 节点和数据块。==

40.3 File Organization: The Inode
==40.3 文件组织：i 节点==

One of the most important on-disk structures of a file system is the **inode**; virtually all file systems have a structure similar to this.
==文件系统最重要的磁盘结构之一是 **inode**；几乎所有的文件系统都有类似的结构。==

The name inode is short for **index node**.
==inode 这个名字是**索引节点**（index node）的缩写。==

Each inode is implicitly referred to by a number (called the **i-number**), which we’ve earlier called the **low-level name** of the file.
==每个 i 节点都通过一个数字（称为 **i 节点号**）隐式引用，我们之前称之为文件的**低级名称**。==

The sector address $sector$ of the inode block can be calculated as follows:
==i 节点块的扇区地址 $sector$ 可以如下计算：==

$blk = (inumber \times sizeof(inode\_t)) / blockSize$
$blk = (inumber \times sizeof(inode\_t)) / blockSize$

$sector = ((blk \times blockSize) + inodeStartAddr) / sectorSize$
$sector = ((blk \times blockSize) + inodeStartAddr) / sectorSize$

One simple approach would be to have one or more **direct pointers** (disk addresses) inside the inode; each pointer refers to one disk block that belongs to the file.
==一种简单的方法是在 i 节点内部设有一个或多个**直接指针**（direct pointers，磁盘地址）；每个指针指向属于该文件的一个磁盘块。==

To support bigger files, file system designers have had to introduce different structures within inodes.
==为了支持更大的文件，文件系统设计者不得不在 i 节点内引入不同的结构。==

One common idea is to have a special pointer known as an **indirect pointer**.
==一个常见的想法是使用一种特殊的指针，称为**间接指针**（indirect pointer）。==

Assuming 4-KB blocks and 4-byte disk addresses, the file can grow to be $(12 + 1024) \times 4\text{KB}$ or $4144\text{KB}$.
==假设块大小为 4 KB，磁盘地址为 4 字节，文件大小可以增长到 $(12 + 1024) \times 4\text{KB}$，即 $4144\text{KB}$。==

A different approach is to use **extents** instead of pointers.
==另一种方法是使用**范围**（extents）而不是指针。==

An extent is simply a disk pointer plus a length (in blocks).
==一个范围（extent）仅仅是一个磁盘指针加上一个长度（以块为单位）。==

Overall, this imbalanced tree is referred to as the **multi-level index** approach to pointing to file blocks.
==总的来说，这种不平衡树被称为指向文件块的**多级索引**（multi-level index）方法。==

40.4 Directory Organization
==40.4 目录组织==

In **vsfs** (as in many file systems), directories have a simple organization; a directory basically just contains a list of (entry name, inode number) pairs.
==在 **vsfs** 中（如在许多文件系统中），目录具有简单的组织方式；目录基本上只包含一组（条目名称，i 节点号）对。==




ASIDE: LINKED-BASED APPROACHES
==旁注：基于链接的方法==

Another simpler approach in designing inodes is to use a **linked list**.
==设计 inode 的另一种更简单的方法是使用**链表**。==

Thus, inside an inode, instead of having multiple pointers, you just need one, to point to the first block of the file.
==因此，在 inode 内部，你不需要多个指针，只需要一个指针指向文件的第一个块。==

To handle larger files, add another pointer at the end of that data block, and so on, and thus you can support large files.
==为了处理更大的文件，在那个数据块的末尾添加另一个指针，依此类推，从而支持大文件。==

As you might have guessed, linked file allocation performs poorly for some workloads; think about reading the last block of a file, for example, or just doing random access.
==正如你可能猜到的，链接文件分配在某些工作负载下表现不佳；例如，考虑读取文件的最后一个块，或者仅仅是进行随机访问。==

Thus, to make linked allocation work better, some systems will keep an in-memory table of link information, instead of storing the next pointers with the data blocks themselves.
==因此，为了使链接分配更好地工作，一些系统会在内存中保留一张链接信息表，而不是将下一个指针与数据块本身存储在一起。==

The table is indexed by the address of a data block $D$; the content of an entry is simply $D$’s next pointer, i.e., the address of the next block in a file which follows $D$.
==该表以数据块 $D$ 的地址为索引；条目的内容仅仅是 $D$ 的下一个指针，即紧随 $D$ 之后的文件中下一个块的地址。==

A null-value could be there too (indicating an end-of-file), or some other marker to indicate that a particular block is free.
==那里也可以有一个空值（表示文件结束），或者其他一些标记来表示某个特定块是空闲的。==

Having such a table of next pointers makes it so that a linked allocation scheme can effectively do random file accesses, simply by first scanning through the (in memory) table to find the desired block, and then accessing (on disk) it directly.
==拥有这样一张“下一指针表”，使得链接分配方案能够有效地进行随机文件访问，只需首先扫描（内存中的）表以找到所需的块，然后直接访问（磁盘上的）该块。==

Does such a table sound familiar?
==这样的表听起来熟悉吗？==

What we have described is the basic structure of what is known as the **file allocation table**, or **FAT** file system.
==我们所描述的是所谓的**文件分配表**（**FAT**）文件系统的基本结构。==

Yes, this classic old Windows file system, before NTFS [C94], is based on a simple linked-based allocation scheme.
==是的，这个在 NTFS [C94] 之前的经典老式 Windows 文件系统，就是基于一种简单的链接分配方案。==

There are other differences from a standard UNIX file system too; for example, there are no inodes per se, but rather directory entries which store metadata about a file and refer directly to the first block of said file, which makes creating hard links impossible.
==与标准 UNIX 文件系统还有其他不同之处；例如，它本身没有 inode，而是通过目录项存储文件的元数据并直接引用该文件的第一个块，这使得创建硬链接变得不可能。==

See Brouwer [B02] for more of the inelegant details.
==有关更多不雅的细节，请参阅 Brouwer [B02]。==

You might be wondering where exactly directories are stored.
==你可能想知道目录到底存储在哪里。==

Often, file systems treat directories as a special type of file.
==通常，文件系统将目录视为一种特殊类型的文件。==

Thus, a directory has an inode, somewhere in the inode table (with the type field of the inode marked as “directory” instead of “regular file”).
==因此，目录有一个 inode，位于 inode 表中的某个位置（其 inode 的类型字段被标记为“目录”而不是“普通文件”）。==

The directory has data blocks pointed to by the inode (and perhaps, indirect blocks); these data blocks live in the data block region of our simple file system.
==该目录具有由 inode 指向的数据块（可能还有间接块）；这些数据块位于我们简单文件系统的数据块区域中。==

Our on-disk structure thus remains unchanged.
==因此，我们的磁盘结构保持不变。==

We should also note again that this simple linear list of directory entries is not the only way to store such information.
==我们还应该再次注意，这种简单的目录项线性列表并不是存储此类信息的唯一方法。==

As before, any data structure is possible.
==和以前一样，任何数据结构都是可能的。==

For example, XFS [S+96] stores directories in **B-tree** form, making file create operations (which have to ensure that a file name has not been used before creating it) faster than systems with simple lists that must be scanned in their entirety.
==例如，XFS [S+96] 以 **B 树**形式存储目录，这使得文件创建操作（必须在创建之前确保文件名未被使用）比必须完整扫描的简单列表系统更快。==

ASIDE: FREE SPACE MANAGEMENT
==旁注：空闲空间管理==

There are many ways to manage free space; **bitmaps** are just one way.
==管理空闲空间有很多方法；**位图**只是其中一种。==

Some early file systems used **free lists**, where a single pointer in the super block was kept to point to the first free block; inside that block the next free pointer was kept, thus forming a list through the free blocks of the system.
==一些早期的文件系统使用**空闲列表**，在超级块中保留一个指针指向第一个空闲块；在该块内部保留下一个空闲指针，从而形成贯穿系统空闲块的列表。==

When a block was needed, the head block was used and the list updated accordingly.
==当需要一个块时，使用头块并相应地更新列表。==

Modern file systems use more sophisticated data structures.
==现代文件系统使用更复杂的数据结构。==

For example, SGI’s XFS [S+96] uses some form of a **B-tree** to compactly represent which chunks of the disk are free.
==例如，SGI 的 XFS [S+96] 使用某种形式的 **B 树**来紧凑地表示磁盘的哪些部分是空闲的。==

As with any data structure, different time-space trade-offs are possible.
==与任何数据结构一样，不同的时空折衷是可能的。==

40.5 Free Space Management
==40.5 空闲空间管理==

A file system must track which inodes and data blocks are free, and which are not, so that when a new file or directory is allocated, it can find space for it.
==文件系统必须追踪哪些 inode 和数据块是空闲的，哪些不是，以便在分配新文件或目录时，它能为其找到空间。==

Thus **free space management** is important for all file systems.
==因此，**空闲空间管理**对所有文件系统都很重要。==

In vsfs, we have two simple **bitmaps** for this task.
==在 vsfs 中，我们有两个简单的**位图**来完成这项任务。==

For example, when we create a file, we will have to allocate an inode for that file.
==例如，当我们创建一个文件时，我们必须为该文件分配一个 inode。==

The file system will thus search through the bitmap for an inode that is free, and allocate it to the file; the file system will have to mark the inode as used (with a 1) and eventually update the on-disk bitmap with the correct information.
==因此，文件系统将在位图中搜索空闲的 inode，并将其分配给文件；文件系统必须将该 inode 标记为已使用（用 1 表示），并最终用正确的信息更新磁盘上的位图。==

A similar set of activities take place when a data block is allocated.
==当分配数据块时，会发生一系列类似的活动。==

Some other considerations might also come into play when allocating data blocks for a new file.
==在为新文件分配数据块时，还可能涉及其他一些考虑因素。==

For example, some Linux file systems, such as ext2 and ext3, will look for a sequence of blocks (say 8) that are free when a new file is created and needs data blocks; by finding such a sequence of free blocks, and then allocating them to the newly-created file, the file system guarantees that a portion of the file will be contiguous on the disk, thus improving performance.
==例如，一些 Linux 文件系统（如 ext2 和 ext3）在创建新文件并需要数据块时，会寻找一系列空闲块（例如 8 个）；通过寻找这样一系列空闲块并将其分配给新创建的文件，文件系统保证了文件的一部分在磁盘上是连续的，从而提高了性能。==

Such a **pre-allocation** policy is thus a commonly-used heuristic when allocating space for data blocks.
==因此，这种**预分配**策略是分配数据块空间时常用的一种启发式方法。==

40.6 Access Paths: Reading and Writing
==40.6 访问路径：读取和写入==

Now that we have some idea of how files and directories are stored on disk, we should be able to follow the flow of operation during the activity of reading or writing a file.
==既然我们已经了解了文件和目录在磁盘上的存储方式，我们应该能够跟踪读取或写入文件活动期间的操作流程。==

Understanding what happens on this **access path** is thus the second key in developing an understanding of how a file system works; pay attention!
==因此，了解这条**访问路径**上发生的事情，是深入理解文件系统如何工作的第二个关键；请注意！==

For the following examples, let us assume that the file system has been mounted and thus that the superblock is already in memory.
==对于以下示例，让我们假设文件系统已经挂载，因此超级块已经在内存中。==

Everything else (i.e., inodes, directories) is still on the disk.
==其他所有内容（即 inode、目录）仍位于磁盘上。==

Reading A File From Disk
==从磁盘读取文件==

In this simple example, let us first assume that you want to simply open a file (e.g., `/foo/bar`), read it, and then close it.
==在这个简单的示例中，让我们首先假设你只想打开一个文件（例如 `/foo/bar`），读取它，然后关闭它。==

For this simple example, let’s assume the file is just 12KB in size (i.e., 3 blocks).
==对于这个简单的例子，假设文件的大小只有 12KB（即 3 个块）。==

When you issue an `open("/foo/bar", O_RDONLY)` call, the file system first needs to find the inode for the file `bar`, to obtain some basic information about the file (permissions information, file size, etc.).
==当你发出 `open("/foo/bar", O_RDONLY)` 调用时，文件系统首先需要找到文件 `bar` 的 inode，以获取有关该文件的一些基本信息（权限信息、文件大小等）。==

To do so, the file system must be able to find the inode, but all it has right now is the full pathname.
==为此，文件系统必须能够找到 inode，但它现在只有完整的路径名。==

The file system must **traverse** the pathname and thus locate the desired inode.
==文件系统必须**遍历**路径名，从而定位所需的 inode。==

All traversals begin at the root of the file system, in the **root directory** which is simply called `/`.
==所有遍历都从文件系统的根目录开始，即**根目录**，简称为 `/`。==

Thus, the first thing the FS will read from disk is the inode of the root directory.
==因此，文件系统（FS）从磁盘读取的第一件事就是根目录的 inode。==

But where is this inode?
==但是这个 inode 在哪里呢？==

To find an inode, we must know its i-number.
==要找到一个 inode，我们必须知道它的 i-number（索引节点号）。==

Usually, we find the i-number of a file or directory in its parent directory; the root has no parent (by definition).
==通常，我们在文件或目录的父目录中找到其 i-number；而根目录没有父目录（根据定义）。==

Thus, the root inode number must be “well known”; the FS must know what it is when the file system is mounted.
==因此，根 inode 编号必须是“众所周知”的；文件系统必须在挂载时知道它是什么。==

In most UNIX file systems, the root inode number is 2.
==在大多数 UNIX 文件系统中，根 inode 编号是 2。==

Thus, to begin the process, the FS reads in the block that contains inode number 2 (the first inode block).
==因此，为了开始这个过程，文件系统读入包含 inode 编号 2 的块（第一个 inode 块）。==

Once the inode is read in, the FS can look inside of it to find pointers to data blocks, which contain the contents of the root directory.
==一旦读入 inode，文件系统就可以查看其内部以找到指向数据块的指针，这些数据块包含根目录的内容。==

The FS will thus use these on-disk pointers to read through the directory, in this case looking for an entry for `foo`.
==因此，文件系统将使用这些磁盘上的指针来读取目录，在本例中是寻找 `foo` 的条目。==

By reading in one or more directory data blocks, it will find the entry for `foo`; once found, the FS will also have found the inode number of `foo` (say it is 44) which it will need next.
==通过读入一个或多个目录数据块，它将找到 `foo` 的条目；一旦找到，文件系统也将找到 `foo` 的 inode 编号（假设为 44），这是它下一步需要的。==

The next step is to recursively traverse the pathname until the desired inode is found.
==下一步是递归遍历路径名，直到找到所需的 inode。==

In this example, the FS reads the block containing the inode of `foo` and then its directory data, finally finding the inode number of `bar`.
==在此示例中，文件系统读取包含 `foo` 的 inode 的块，然后读取其目录数据，最终找到 `bar` 的 inode 编号。==

The final step of `open()` is to read `bar`’s inode into memory; the FS then does a final permissions check, allocates a file descriptor for this process in the per-process open-file table, and returns it to the user.
==`open()` 的最后一步是将 `bar` 的 inode 读入内存；然后，文件系统进行最终的权限检查，在每个进程的打开文件表中为此进程分配一个文件描述符，并将其返回给用户。==

Once open, the program can then issue a `read()` system call to read from the file.
==一旦打开，程序就可以发出 `read()` 系统调用来从文件中读取。==

The first read (at offset 0 unless `lseek()` has been called) will thus read in the first block of the file, consulting the inode to find the location of such a block; it may also update the inode with a new last-accessed time.
==因此，第一次读取（偏移量为 0，除非调用了 `lseek()`）将读入文件的第一个块，并咨询 inode 以查找该块的位置；它还可能用新的最后访问时间更新 inode。==

The read will further update the in-memory open file table for this file descriptor, updating the file offset such that the next read will read the second file block, etc.
==读取操作将进一步更新此文件描述符的内存中打开文件表，更新文件偏移量，以便下一次读取将读取第二个文件块，依此类推。==

At some point, the file will be closed.
==在某个时刻，文件将被关闭。==

There is much less work to be done here; clearly, the file descriptor should be deallocated, but for now, that is all the FS really needs to do.
==这里要做的工作少得多；显然，文件描述符应该被释放，但目前，这就是文件系统真正需要做的全部工作。==

No disk I/Os take place.
==不发生磁盘 I/O。==

A depiction of this entire process is found in Figure 40.3 (page 11); time increases downward in the figure.
==图 40.3（第 11 页）描绘了整个过程；图中时间向下递增。==

In the figure, the open causes numerous reads to take place in order to finally locate the inode of the file.
==在图中，open 导致发生了多次读取，以便最终定位文件的 inode。==

Afterwards, reading each block requires the file system to first consult the inode, then read the block, and then update the inode’s last-accessed-time field with a write.
==随后，读取每个块都需要文件系统首先咨询 inode，然后读取该块，最后通过写入更新 inode 的最后访问时间字段。==

Spend some time and understand what is going on.
==花点时间理解发生了什么。==

Also note that the amount of I/O generated by the open is proportional to the length of the pathname.
==还请注意，open 生成的 I/O 量与路径名的长度成正比。==

For each additional directory in the path, we have to read its inode as well as its data.
==路径中每增加一个目录，我们都必须读取其 inode 及其数据。==

Making this worse would be the presence of large directories; here, we only have to read one block to get the contents of a directory, whereas with a large directory, we might have to read many data blocks to find the desired entry.
==大目录的存在会使情况变得更糟；在这里，我们只需要读取一个块就能获得一个目录的内容，而对于大目录，我们可能需要读取许多数据块才能找到所需的条目。==

Yes, life can get pretty bad when reading a file; as you’re about to find out, writing out a file (and especially, creating a new one) is even worse.
==是的，读取文件时情况可能会变得非常糟糕；正如你即将发现的那样，写出文件（尤其是创建一个新文件）的情况甚至更糟。==

Writing A File To Disk
==将文件写入磁盘==

Writing to a file is a similar process.
==写入文件是一个类似的过程。==

First, the file must be opened (as above).
==首先，必须打开文件（如上所述）。==

Then, the application can issue `write()` calls to update the file with new contents.
==然后，应用程序可以发出 `write()` 调用来使用新内容更新文件。==

Finally, the file is closed.
==最后，关闭文件。==

Unlike reading, writing to the file may also allocate a block (unless the block is being overwritten, for example).
==与读取不同，写入文件还可能分配一个块（例如，除非该块正在被覆盖）。==

When writing out a new file, each write not only has to write data to disk but has to first decide which block to allocate to the file and thus update other structures of the disk accordingly (e.g., the data bitmap and inode).
==写出一个新文件时，每次写入不仅必须将数据写入磁盘，还必须首先决定将哪个块分配给该文件，并相应地更新磁盘的其他结构（例如，数据位图和 inode）。==

Thus, each write to a file logically generates five I/Os: one to read the data bitmap (which is then updated to mark the newly-allocated block as used), one to write the bitmap (to reflect its new state to disk), two more to read and then write the inode (which is updated with the new block’s location), and finally one to write the actual block itself.
==因此，逻辑上对文件的每次写入都会产生五个 I/O：一个用于读取数据位图（然后更新该位图以将新分配的块标记为已使用），一个用于写入位图（以向磁盘反映其新状态），另外两个用于读取然后写入 inode（更新新块的位置），最后是一个用于写入实际块本身。==

The amount of write traffic is even worse when one considers a simple and common operation such as file creation.
==考虑到文件创建等简单且常见的操作时，写入流量的情况甚至更糟。==

To create a file, the file system must not only allocate an inode, but also allocate space within the directory containing the new file.
==为了创建文件，文件系统不仅必须分配一个 inode，还必须在包含新文件的目录中分配空间。==

The total amount of I/O traffic to do so is quite high: one read to the inode bitmap (to find a free inode), one write to the inode bitmap (to mark it allocated), one write to the new inode itself (to initialize it), one to the data of the directory (to link the high-level name of the file to its inode number), and one read and write to the directory inode to update it.
==这样做产生的总 I/O 流量相当高：一次读取 inode 位图（以查找空闲 inode），一次写入 inode 位图（将其标记为已分配），一次写入新 inode 本身（对其进行初始化），一次写入目录数据（将文件的高级名称与其 inode 编号链接），以及一次读取和写入目录 inode 以更新它。==

If the directory needs to grow to accommodate the new entry, additional I/Os (i.e., to the data bitmap, and the new directory block) will be needed too.
==如果目录需要增长以容纳新条目，则还需要额外的 I/O（即，对数据位图和新目录块的操作）。==

All that just to create a file!
==这一切仅仅是为了创建一个文件！==

40.7 Caching and Buffering
==40.7 缓存与缓冲==

As the examples above show, reading and writing files can be expensive, incurring many I/Os to the (slow) disk.
==正如上面的例子所示，读取和写入文件可能非常昂贵，会对（缓慢的）磁盘产生多次 I/O。==

To remedy what would clearly be a huge performance problem, most file systems aggressively use system memory (DRAM) to cache important blocks.
==为了补救显然巨大的性能问题，大多数文件系统会积极使用系统内存（DRAM）来缓存重要块。==

Imagine the open example above: without caching, every file open would require at least two reads for every level in the directory hierarchy (one to read the inode of the directory in question, and at least one to read its data).
==想象一下上面的打开示例：如果没有缓存，每次打开文件都需要对目录层次结构中的每一层至少进行两次读取（一次读取相关目录的 inode，至少一次读取其数据）。==

With a long pathname (e.g., `/1/2/3/ ... /100/file.txt`), the file system would literally perform hundreds of reads just to open the file!
==对于长路径名（例如 `/1/2/3/ ... /100/file.txt`），文件系统为了打开文件确实会执行数百次读取！==

Early file systems thus introduced a **fixed-size cache** to hold popular blocks.
==因此，早期的文件系统引入了**固定大小的缓存**来保存常用块。==

As in our discussion of virtual memory, strategies such as **LRU** and different variants would decide which blocks to keep in cache.
==正如我们在虚拟内存讨论中所述，**LRU** 等策略及其各种变体会决定哪些块保留在缓存中。==

This fixed-size cache would usually be allocated at boot time to be roughly 10% of total memory.
==这种固定大小的缓存通常在引导时分配，约占总内存的 10%。==

This **static partitioning** of memory, however, can be wasteful; what if the file system doesn’t need 10% of memory at a given point in time?
==然而，这种内存的**静态分区**可能会造成浪费；如果文件系统在特定时间点不需要 10% 的内存怎么办？==

With the fixed-size approach described above, unused pages in the file cache cannot be re-purposed for some other use, and thus go to waste.
==使用上述固定大小的方法，文件缓存中未使用的页面不能重新用于其他用途，从而造成浪费。==

Modern systems, in contrast, employ a **dynamic partitioning** approach.
==相比之下，现代系统采用**动态分区**方法。==

Specifically, many modern operating systems integrate virtual memory pages and file system pages into a **unified page cache** [S00].
==具体而言，许多现代操作系统将虚拟内存页和文件系统页集成到一个**统一页面缓存** [S00] 中。==

In this way, memory can be allocated more flexibly across virtual memory and file system, depending on which needs more memory at a given time.
==通过这种方式，内存可以更灵活地在虚拟内存和文件系统之间分配，具体取决于给定时间哪方需要更多内存。==

Now imagine the file open example with caching.
==现在想象一下带缓存的文件打开示例。==

The first open may generate a lot of I/O traffic to read in directory inode and data, but subsequent file opens of that same file (or files in the same directory) will mostly hit in the cache and thus no I/O is needed.
==第一次打开可能会产生大量的 I/O 流量来读入目录 inode 和数据，但随后对同一文件（或同一目录下的文件）的打开将大部分命中缓存，因此不需要 I/O。==

Let us also consider the effect of caching on writes.
==让我们也考虑一下缓存对写入的影响。==

Whereas read I/O can be avoided altogether with a sufficiently large cache, write traffic has to go to disk in order to become persistent.
==虽然通过足够大的缓存可以完全避免读取 I/O，但写入流量必须进入磁盘才能实现持久化。==

Thus, a cache does not serve as the same kind of filter on write traffic that it does for reads.
==因此，缓存对写入流量的过滤作用与对读取流量的不同。==

That said, **write buffering** (as it is sometimes called) certainly has a number of performance benefits.
==即便如此，**写入缓冲**（有时也这么叫）确实有很多性能上的好处。==

First, by delaying writes, the file system can **batch** some updates into a smaller set of I/Os; for example, if an inode bitmap is updated when one file is created and then updated moments later as another file is created, the file system saves an I/O by delaying the write after the first update.
==首先，通过延迟写入，文件系统可以将一些更新**批量处理**成更少的 I/O；例如，如果在创建一个文件时更新了 inode 位图，稍后在创建另一个文件时又更新了它，文件系统通过在第一次更新后延迟写入，节省了一次 I/O。==

Second, by buffering a number of writes in memory, the system can then **schedule** the subsequent I/Os and thus increase performance.
==其次，通过在内存中缓冲多次写入，系统随后可以对后续 I/O 进行**调度**，从而提高性能。==

Finally, some writes are avoided altogether by delaying them; for example, if an application creates a file and then deletes it, delaying the writes to reflect the file creation to disk avoids them entirely.
==最后，通过延迟写入，可以完全避免某些写入；例如，如果应用程序创建了一个文件然后又将其删除，通过延迟反映文件创建到磁盘的写入，可以完全避免这些写入。==

In this case, laziness (in writing blocks to disk) is a virtue.
==在这种情况下，（在将块写入磁盘方面的）懒惰是一种美德。==

For the reasons above, most modern file systems buffer writes in memory for anywhere between five and thirty seconds, representing yet another trade-off: if the system crashes before the updates have been propagated to disk, the updates are lost; however, by keeping writes in memory longer, performance can be improved by batching, scheduling, and even avoiding writes.
==由于上述原因，大多数现代文件系统在内存中缓冲写入的时间在 5 到 30 秒之间，这代表了另一种折衷：如果系统在更新传播到磁盘之前崩溃，更新就会丢失；然而，通过将写入在内存中保留更长时间，可以通过批量处理、调度甚至避免写入来提高性能。==

TIP: UNDERSTAND THE DURABILITY/PERFORMANCE TRADE-OFF
==提示：理解持久性/性能的折衷==

Storage systems often present a durability/performance trade-off to users.
==存储系统经常向用户呈现持久性与性能之间的折衷。==

If the user wishes data that is written to be immediately durable, the system must go through the full effort of committing the newly-written data to disk, and thus the write is slow (but safe).
==如果用户希望写入的数据立即持久化，系统必须全力将新写入的数据提交到磁盘，因此写入速度慢（但安全）。==

However, if the user can tolerate the loss of a little data, the system can buffer writes in memory for some time and write them later to the disk (in the background).
==然而，如果用户可以容忍丢失少量数据，系统可以在内存中缓冲写入一段时间，稍后再将其写入磁盘（在后台进行）。==

Doing so makes writes appear to complete quickly, thus improving perceived performance; however, if a crash occurs, writes not yet committed to disk will be lost, and hence the trade-off.
==这样做使写入看起来很快完成，从而提高了感知性能；然而，如果发生崩溃，尚未提交到磁盘的写入将会丢失，这就是折衷所在。==

To understand how to make this trade-off properly, it is best to understand what the application using the storage system requires; for example, while it may be tolerable to lose the last few images downloaded by your web browser, losing part of a database transaction that is adding money to your bank account may be less tolerable.
==为了理解如何妥善处理这种折衷，最好了解使用存储系统的应用程序的需求；例如，虽然丢失网页浏览器下载的最后几张图片可能是可以忍受的，但丢失向你的银行账户加钱的部分数据库事务可能就不那么可以忍受了。==

Unless you’re rich, of course; in that case, why do you care so much about hoarding every last penny?
==当然，除非你很有钱；在那这种情况下，你为什么要如此在意囤积每一分钱呢？==

Some applications (such as databases) don’t enjoy this trade-off.
==某些应用程序（如数据库）并不喜欢这种折衷。==

Thus, to avoid unexpected data loss due to write buffering, they simply force writes to disk, by calling `fsync()`, by using **direct I/O** interfaces that work around the cache, or by using the **raw disk** interface and avoiding the file system altogether.
==因此，为了避免由于写入缓冲导致的意外数据丢失，它们通过调用 `fsync()`、使用绕过缓存的**直接 I/O** 接口，或者使用**原始磁盘**接口并完全避开文件系统，简单地强制将数据写入磁盘。==

While most applications live with the trade-offs made by the file system, there are enough controls in place to get the system to do what you want it to, should the default not be satisfying.
==虽然大多数应用程序接受文件系统所做的折衷，但如果有足够多的控制措施，如果默认设置不令人满意，也可以让系统执行你想要的操作。==

40.8 Summary
==40.8 总结==

We have seen the basic machinery required in building a file system.
==我们已经看到了构建文件系统所需的基本机制。==

There needs to be some information about each file (metadata), usually stored in a structure called an **inode**.
==需要有关于每个文件的一些信息（元数据），通常存储在一个称为 **inode** 的结构中。==

Directories are just a specific type of file that store name $\rightarrow$ inode-number mappings.
==目录只是一种特殊类型的文件，存储“名称 $\rightarrow$ inode 编号”的映射。==

And other structures are needed too; for example, file systems often use a structure such as a **bitmap** to track which inodes or data blocks are free or allocated.
==还需要其他结构；例如，文件系统经常使用诸如**位图**之类的结构来追踪哪些 inode 或数据块是空闲的或已分配的。==

Locality and The Fast File System
==局部性与快速文件系统==

When the UNIX operating system was first introduced, the UNIX wizard himself Ken Thompson wrote the first file system.
==当 UNIX 操作系统首次推出时，UNIX 奇才肯·汤普森亲自编写了第一个文件系统。==

Let’s call that the “old UNIX file system”, and it was really simple.
==让我们称之为“旧 UNIX 文件系统”，它非常简单。==

Basically, its data structures looked like this on the disk:
==基本上，它在磁盘上的数据结构如下所示：==

`S | Inodes | Data`
`S | Inodes | Data`

The super block (S) contained information about the entire file system: how big the volume is, how many inodes there are, a pointer to the head of a free list of blocks, and so forth.
==超级块 (S) 包含有关整个文件系统的信息：卷有多大、有多少个 inode、指向块空闲列表头部的指针，等等。==

The inode region of the disk contained all the inodes for the file system.
==磁盘的 inode 区域包含了文件系统的所有 inode。==

Finally, most of the disk was taken up by data blocks.
==最后，磁盘的大部分空间被数据块占用。==

The good thing about the old file system was that it was simple, and supported the basic abstractions the file system was trying to deliver: files and the directory hierarchy.
==旧文件系统的优点在于它很简单，并且支持文件系统试图提供的基本抽象：文件和目录层次结构。==

This easy-to-use system was a real step forward from the clumsy, record-based storage systems of the past, and the directory hierarchy was a true advance over simpler, one-level hierarchies provided by earlier systems.
==这个易于使用的系统是对过去笨拙的、基于记录的存储系统的真正进步，而且目录层次结构比早期系统提供的更简单的单层层次结构更是一种真正的进步。==

41.1 The Problem: Poor Performance
==41.1 问题：性能低下==

The problem: performance was terrible.
==问题在于：性能非常糟糕。==

As measured by Kirk McKusick and his colleagues at Berkeley [MJLF84], performance started off bad and got worse over time, to the point where the file system was delivering only 2% of overall disk bandwidth!
==根据 Kirk McKusick 及其在伯克利的同事 [MJLF84] 的测量，性能起初就很差，并随着时间的推移而恶化，甚至到了文件系统仅能提供 2% 的总磁盘带宽的程度！==

The main issue was that the old UNIX file system treated the disk like it was a random-access memory; data was spread all over the place without regard to the fact that the medium holding the data was a disk, and thus had real and expensive positioning costs.
==主要问题在于，旧的 UNIX 文件系统将磁盘视为随机存取存储器；数据遍布各处，而无视承载数据的介质是磁盘这一事实，因此具有真实且昂贵的定位成本。==

For example, the data blocks of a file were often very far away from its inode, thus inducing an expensive seek whenever one first read the inode and then the data blocks of a file (a pretty common operation).
==例如，文件的数据块通常与其 inode 相距甚远，因此每当先读取 inode 然后读取文件数据块（这是一种非常常见的操作）时，都会引发昂贵的寻道。==

Worse, the file system would end up getting quite fragmented, as the free space was not carefully managed.
==更糟糕的是，由于空闲空间没有得到仔细管理，文件系统最终会变得非常碎片化。==

The free list would end up pointing to a bunch of blocks spread across the disk, and as files got allocated, they would simply take the next free block.
==空闲列表最终会指向分布在磁盘上的一堆块，当文件被分配时，它们只会占用下一个空闲块。==

The result was that a logically contiguous file would be accessed by going back and forth across the disk, thus reducing performance dramatically.
==结果是，在访问逻辑上连续的文件时，会在磁盘上前后移动，从而极大地降低性能。==

One other problem: the original block size was too small (512 bytes).
==另一个问题：原始块大小太小（512 字节）。==

Thus, transferring data from the disk was inherently inefficient.
==因此，从磁盘传输数据本质上是低效的。==

Smaller blocks were good because they minimized **internal fragmentation** (waste within the block), but bad for transfer as each block might require a positioning overhead to reach it.
==较小的块虽好，因为它们最小化了**内部碎片**（块内的浪费），但对于传输却不利，因为每个块都可能需要定位开销才能触达。==

41.2 FFS: Disk Awareness Is The Solution
==41.2 FFS：磁盘感知是解决方案==

A group at Berkeley decided to build a better, faster file system, which they cleverly called the **Fast File System (FFS)**.
==伯克利的一个小组决定构建一个更好、更快捷的文件系统，他们聪明地称之为**快速文件系统 (FFS)**。==

The idea was to design the file system structures and allocation policies to be “disk aware” and thus improve performance, which is exactly what they did.
==其想法是设计“磁盘感知”的文件系统结构和分配策略，从而提高性能，而这正是他们所做的。==

41.3 Organizing Structure: The Cylinder Group
==41.3 组织结构：柱面组==

The first step was to change the on-disk structures.
==第一步是更改磁盘上的结构。==

FFS divides the disk into a number of **cylinder groups**.
==FFS 将磁盘分成若干个**柱面组**。==

A single **cylinder** is a set of tracks on different surfaces of a hard drive that are the same distance from the center of the drive; it is called a cylinder because of its clear resemblance to the so-called geometrical shape.
==单个**柱面**是硬盘不同盘面上距离驱动器中心相同距离的一组磁道；它之所以被称为柱面，是因为它与所谓的几何形状非常相似。==

FFS aggregates $N$ consecutive cylinders into a group, and thus the entire disk can thus be viewed as a collection of cylinder groups.
==FFS 将 $N$ 个连续的柱面聚合为一个组，因此整个磁盘可以被视为柱面组的集合。==

Within each group, FFS needs to track whether the inodes and data blocks of the group are allocated.
==在每个组中，FFS 需要追踪该组的 inode 和数据块是否已分配。==

A per-group **inode bitmap (ib)** and **data bitmap (db)** serve this role for inodes and data blocks in each group.
==每个组中的**索引节点位图 (ib)** 和**数据位图 (db)** 分别负责追踪每个组中的 inode 和数据块。==

Finally, the **inode** and **data block** regions are just like those in the previous very-simple file system (VSFS).
==最后，**inode** 和**数据块**区域就像之前的极简文件系统 (VSFS) 中的一样。==

41.4 Policies: How To Allocate Files and Directories
==41.4 策略：如何分配文件和目录==

The basic mantra is simple: *keep related stuff together* (and its corollary, *keep unrelated stuff far apart*).
==基本原则很简单：*将相关的东西放在一起*（及其推论，*将不相关的东西分开放*）。==

Thus, to obey the mantra, FFS has to decide what is “related” and place it within the same block group; conversely, unrelated items should be placed into different block groups.
==因此，为了遵循该原则，FFS 必须决定什么是“相关的”并将其放在同一个块组中；相反，不相关的项应该放在不同的块组中。==

To achieve this end, FFS makes use of a few simple placement heuristics.
==为了达到这个目的，FFS 使用了一些简单的放置启发式方法。==

The first is the placement of directories.
==第一个是目录的放置。==

FFS employs a simple approach: find the cylinder group with a low number of allocated directories (to balance directories across groups) and a high number of free inodes (to subsequently be able to allocate a bunch of files), and put the directory data and inode in that group.
==FFS 采用了一种简单的方法：寻找已分配目录数量较少（为了在组之间平衡目录）且空闲 inode 数量较多（以便随后能够分配一堆文件）的柱面组，并将目录数据和 inode 放在该组中。==

For files, FFS does two things.
==对于文件，FFS 做两件事。==

First, it makes sure (in the general case) to allocate the data blocks of a file in the same group as its inode, thus preventing long seeks between inode and data (as in the old file system).
==首先，它确保（在一般情况下）将文件的数据块分配在与其 inode 相同的组中，从而防止 inode 和数据之间长距离寻道（如在旧文件系统中那样）。==

Second, it places all files that are in the same directory in the cylinder group of the directory they are in.
==其次，它将同一目录中的所有文件都放在该目录所在的柱面组中。==

41.6 The Large-File Exception
==41.6 大文件例外情况==

In FFS, there is one important exception to the general policy of file placement, and it arises for large files.
==在 FFS 中，文件放置的一般策略有一个重要的例外，即针对大文件。==

Without a different rule, a large file would entirely fill the block group it is first placed within (and maybe others).
==如果没有不同的规则，一个大文件会完全填满它最初被放置的块组（可能还有其他块组）。==

Filling a block group in this manner is undesirable, as it prevents subsequent “related” files from being placed within this block group, and thus may hurt file-access locality.
==以这种方式填满一个块组是不可取的，因为它会阻止后续的“相关”文件被放置在该块组中，从而可能损害文件访问的局部性。==

Thus, for large files, FFS does the following.
==因此，对于大文件，FFS 会执行以下操作。==

After some number of blocks are allocated into the first block group (e.g., 12 blocks, or the number of direct pointers available within an inode), FFS places the next “large” chunk of the file (e.g., those pointed to by the first indirect block) in another block group (perhaps chosen for its low utilization).
==在第一个块组中分配了一定数量的块（例如 12 个块，或 inode 中可用的直接指针数量）之后，FFS 将文件的下一个“大”块（例如，由第一个间接块指向的块）放在另一个块组中（可能是根据低利用率选择的）。==

Then, the next chunk of the file is placed in yet another different block group, and so on.
==然后，文件的下一个块被放置在另一个不同的块组中，依此类推。==

Specifically, if the chunk size is large enough, the file system will spend most of its time transferring data from disk and just a (relatively) little time seeking between chunks of the block.
==具体来说，如果块大小足够大，文件系统将花费大部分时间从磁盘传输数据，而只花费（相对）很少的时间在块的各个分块之间寻道。==

This process of reducing an overhead by doing more work per overhead paid is called **amortization** and is a common technique in computer systems.
==这种通过在每次支付的开销中做更多工作来减少开销的过程被称为**摊销**（amortization），是计算机系统中的一种常用技术。==

Let’s do an example: assume that the average positioning time (i.e., seek and rotation) for a disk is 10 ms.
==让我们举个例子：假设磁盘的平均定位时间（即寻道和旋转）为 10 毫秒。==

Assume further that the disk transfers data at 40 MB/s.
==进一步假设磁盘传输数据的速度为 40 MB/s。==

If your goal was to spend half our time seeking between chunks and half our time transferring data (and thus achieve 50% of peak disk performance), you would thus need to spend 10 ms transferring data for every 10 ms positioning.
==如果你的目标是花一半时间在块之间寻道，另一半时间传输数据（从而达到峰值磁盘性能的 50%），那么每定位 10 毫秒你就需要花费 10 毫秒来传输数据。==

So the question becomes: how big does a chunk have to be in order to spend 10 ms in transfer?
==所以问题变成了：为了在传输上花费 10 毫秒，一个块需要多大？==

$\frac{40 MB}{sec} \cdot \frac{1024 KB}{1 MB} \cdot \frac{1 sec}{1000 ms} \cdot 10 ms = 409.6 KB$
$\frac{40 MB}{sec} \cdot \frac{1024 KB}{1 MB} \cdot \frac{1 sec}{1000 ms} \cdot 10 ms = 409.6 KB$

Basically, what this equation says is this: if you transfer data at 40 MB/s, you need to transfer only 409.6KB every time you seek in order to spend half your time seeking and half your time transferring.
==基本上，这个方程说的是：如果你以 40 MB/s 的速度传输数据，每次寻道只需要传输 409.6KB，就可以让寻道和传输各占一半时间。==




Figure 41.3: FFS: Standard Versus Parameterized Placement
==图 41.3：FFS：标准布局与参数化布局的对比==

waste an entire 4KB block.
==浪费掉整整一个 4KB 数据块。==

As the file grew, the file system will continue allocating 512-byte blocks to it until it acquires a full 4KB of data.
==随着文件的增长，文件系统将继续为其分配 512 字节的块，直到它获得整整 4KB 的数据。==

At that point, FFS will find a 4KB block, copy the sub-blocks into it, and free the sub-blocks for future use.
==此时，FFS 将寻找一个 4KB 的块，将子块内容复制到其中，并释放这些子块以便将来使用。==

You might observe that this process is inefficient, requiring a lot of extra work for the file system (in particular, a lot of extra I/O to perform the copy).
==你可能会注意到这个过程是低效的，需要文件系统做大量的额外工作（特别是执行复制时的大量额外 I/O）。==

And you’d be right again!
==你又说对了！==

Thus, FFS generally avoided this pessimal behavior by modifying the `libc` library; the library would buffer writes and then issue them in 4KB chunks to the file system, thus avoiding the sub-block specialization entirely in most cases.
==因此，FFS 通常通过修改 `libc` 库来避免这种最差情况；该库会缓冲写入，然后以 4KB 为单位发给文件系统，从而在大多数情况下完全避免了子块细化的开销。==

A second neat thing that FFS introduced was a disk layout that was optimized for performance.
==FFS 引入的第二个巧妙之处是针对性能进行了优化的磁盘布局。==

In those times (before SCSI and other more modern device interfaces), disks were much less sophisticated and required the host CPU to control their operation in a more hands-on way.
==在那个时代（SCSI 和其他更现代的设备接口出现之前），磁盘远没有现在这么复杂，需要主机 CPU 以更直接的方式控制其运行。==

A problem arose in FFS when a file was placed on consecutive sectors of the disk, as on the left in Figure 41.3.
==当文件被放置在磁盘的连续扇区上时（如图 41.3 左侧所示），FFS 中出现了一个问题。==

In particular, the problem arose during sequential reads.
==特别是在顺序读取过程中会出现这个问题。==

FFS would first issue a read to block 0; by the time the read was complete, and FFS issued a read to block 1, it was too late: block 1 had rotated under the head and now the read to block 1 would incur a full rotation.
==FFS 会首先发出读取块 0 的指令；等到读取完成且 FFS 发出读取块 1 的指令时，已经太晚了：块 1 已经旋转过了磁头，现在读取块 1 将导致一个完整的旋转延迟。==

FFS solved this problem with a different layout, as you can see on the right in Figure 41.3.
==FFS 通过一种不同的布局解决了这个问题，正如你在图 41.3 右侧所看到的。==

By skipping over every other block (in the example), FFS has enough time to request the next block before it went past the disk head.
==通过跳过每一个间隔块（在示例中），FFS 就有足够的时间在块经过磁头之前请求下一个块。==

In fact, FFS was smart enough to figure out for a particular disk how many blocks it should skip in doing layout in order to avoid the extra rotations; this technique was called **parameterization**, as FFS would figure out the specific performance parameters of the disk and use those to decide on the exact staggered layout scheme.
==事实上，FFS 非常聪明，能够针对特定磁盘计算出在布局时应该跳过多少个块，以避免额外的旋转；这种技术被称为**参数化**（parameterization），因为 FFS 会计算出磁盘的具体性能参数，并利用这些参数来决定精确的交错布局方案。==

You might be thinking: this scheme isn’t so great after all.
==你可能会想：这个方案毕竟也不怎么样。==

In fact, you will only get 50% of peak bandwidth with this type of layout, because you have to go around each track twice just to read each block once.
==事实上，使用这种类型的布局，你只能获得峰值带宽的 50%，因为你必须绕磁道转两圈才能读完每个块一次。==

Fortunately, modern disks are much smarter: they internally read the entire track in and buffer it in an internal disk cache (often called a **track buffer** for this very reason).
==幸运的是，现代磁盘要聪明得多：它们会在内部读入整个磁道，并将其缓冲在内部磁盘缓存中（正因如此，这通常被称为**磁道缓冲器**）。==

Then, on subsequent reads to the track, the disk will just return the desired data from its cache.
==然后，在随后对该磁道的读取中，磁盘只需从其缓存中返回所需的数据。==

File systems thus no longer have to worry about these incredibly low-level details.
==因此，文件系统不再需要担心这些极低层级的细节。==

Abstraction and higher-level interfaces can be a good thing, when designed properly.
==当设计得当时，抽象和更高级别的接口可能是一件好事。==

Some other usability improvements were added as well.
==此外还增加了一些其他的易用性改进。==

FFS was one of the first file systems to allow for **long file names**, thus enabling more expressive names in the file system instead of the traditional fixed-size approach (e.g., 8 characters).
==FFS 是最早允许**长文件名**的文件系统之一，从而在文件系统中实现了更具表现力的命名，而不是传统的固定长度方式（例如 8 个字符）。==

Further, a new concept was introduced called a **symbolic link**.
==此外，还引入了一个名为**符号链接**（symbolic link）的新概念。==

As discussed in a previous chapter [AD14b], hard links are limited in that they both could not point to directories (for fear of introducing loops in the file system hierarchy) and that they can only point to files within the same volume (i.e., the inode number must still be meaningful).
==正如在之前的章节 [AD14b] 中讨论的那样，硬链接受到限制，因为它们既不能指向目录（担心在文件系统层级结构中引入环路），也只能指向同一卷内的文件（即 inode 编号必须仍然有意义）。==

Symbolic links allow the user to create an “alias” to any other file or directory on a system and thus are much more flexible.
==符号链接允许用户为系统上的任何其他文件或目录创建“别名”，因此更加灵活。==

FFS also introduced an atomic `rename()` operation for renaming files.
==FFS 还引入了一个用于重命名文件的原子 `rename()` 操作。==

Usability improvements, beyond the basic technology, also likely gained FFS a stronger user base.
==除了基础技术之外，易用性的改进也可能为 FFS 赢得了更强大的用户群。==

**41.8 Summary**
==**41.8 总结**==

The introduction of FFS was a watershed moment in file system history, as it made clear that the problem of file management was one of the most interesting issues within an operating system, and showed how one might begin to deal with that most important of devices, the hard disk.
==FFS 的引入是文件系统历史上的一个分水岭，因为它明确了文件管理问题是操作系统中最有趣的问题之一，并展示了人们该如何着手处理最重要的设备——硬盘。==

Since that time, hundreds of new file systems have developed, but still today many file systems take cues from FFS (e.g., Linux ext2 and ext3 are obvious intellectual descendants).
==从那时起，已经开发了数百种新的文件系统，但直到今天，许多文件系统仍从 FFS 中汲取灵感（例如，Linux ext2 和 ext3 是明显的智力后代）。==

Certainly all modern systems account for the main lesson of FFS: treat the disk like it’s a disk.
==当然，所有现代系统都考虑了 FFS 的主要教训：像对待磁盘一样对待磁盘。==

**References**
==**参考文献**==

[AD14a] “Operating Systems: Three Easy Pieces” (Chapter: Hard Disk Drives) by Remzi Arpaci-Dusseau and Andrea Arpaci-Dusseau.
==[AD14a] 《操作系统：三部曲》（章节：硬盘驱动器），作者：Remzi Arpaci-Dusseau 和 Andrea Arpaci-Dusseau。==

Arpaci-Dusseau Books, 2014.
==Arpaci-Dusseau 出版社，2014 年。==

There is no way you should be reading about FFS without having first understood hard drives in some detail.
==在没有详细了解硬盘驱动器之前，你不应该阅读有关 FFS 的内容。==

If you try to do so, please instead go directly to jail; do not pass go, and, critically, do not collect 200 much-needed simoleons.
==如果你尝试这样做，请直接去坐牢；不要经过起点，更重要的是，不要领取那 200 个急需的模拟币。==

[AD14b] “Operating Systems: Three Easy Pieces” (Chapter: File System Implementation) by Remzi Arpaci-Dusseau and Andrea Arpaci-Dusseau.
==[AD14b] 《操作系统：三部曲》（章节：文件系统实现），作者：Remzi Arpaci-Dusseau 和 Andrea Arpaci-Dusseau。==

Arpaci-Dusseau Books, 2014.
==Arpaci-Dusseau 出版社，2014 年。==

As above, it makes little sense to read this chapter unless you have read (and understood) the chapter on file system implementation.
==同上，除非你已经阅读（并理解）了关于文件系统实现的章节，否则阅读本章没有太大意义。==

Otherwise, we’ll be throwing around terms like “inode” and “indirect block” and you’ll be like “huh?” and that is no fun for either of us.
==否则，我们会到处抛出“inode”和“间接块”之类的术语，而你只会一脸茫然，这对我们双方都没有好处。==

[K94] “The Design of the SEER Predictive Caching System” by G. H. Kuenning.
==[K94] 《SEER 预测缓存系统的设计》，作者：G. H. Kuenning。==

MOBICOMM ’94, Santa Cruz, California, December 1994.
==MOBICOMM ’94，加利福尼亚州圣克鲁斯，1994 年 12 月。==

According to Kuenning, this is the best overview of the SEER project, which led to (among other things) the collection of these traces.
==根据 Kuenning 的说法，这是对 SEER 项目最好的概述，该项目促成了（除其他事项外）这些追踪数据的收集。==

[MJLF84] “A Fast File System for UNIX” by Marshall K. McKusick, William N. Joy, Sam J. Leffler, Robert S. Fabry.
==[MJLF84] 《一种用于 UNIX 的快速文件系统》，作者：Marshall K. McKusick，William N. Joy，Sam J. Leffler，Robert S. Fabry。==

ACM TOCS, 2:3, August 1984.
==ACM TOCS，2:3，1984 年 8 月。==

McKusick was recently honored with the IEEE Reynold B. Johnson award for his contributions to file systems, much of which was based on his work building FFS.
==McKusick 最近因其对文件系统的贡献被授予 IEEE Reynold B. Johnson 奖，其中大部分贡献是基于他构建 FFS 的工作。==

In his acceptance speech, he discussed the original FFS software: only 1200 lines of code!
==在获奖感言中，他谈到了最初的 FFS 软件：只有 1200 行代码！==

Modern versions are a little more complex, e.g., the BSD FFS descendant now is in the 50-thousand lines-of-code range.
==现代版本要复杂一些，例如，BSD FFS 的后代现在处于 5 万行代码的范围。==

[P98] “Hardware Technology Trends and Database Opportunities” by David A. Patterson.
==[P98] 《硬件技术趋势与数据库机遇》，作者：David A. Patterson。==

Keynote Lecture at SIGMOD ’98, June 1998.
==SIGMOD ’98 主旨演讲，1998 年 6 月。==

A great and simple overview of disk technology trends and how they change over time.
==对磁盘技术趋势及其随时间演变的一个极好且简单的概述。==

**Homework (Simulation)**
==**课后作业（模拟）**==

This section introduces `ffs.py`, a simple FFS simulator you can use to understand better how FFS-based file and directory allocation work.
==本节介绍了 `ffs.py`，这是一个简单的 FFS 模拟器，你可以用它来更好地理解基于 FFS 的文件和目录分配是如何工作的。==

See the README for details on how to run the simulator.
==有关如何运行模拟器的详细信息，请参阅 README。==

**Questions**
==**问题**==

1. Examine the file `in.largefile`, and then run the simulator with flag `-f in.largefile` and `-L 4`.
==1. 检查文件 `in.largefile`，然后使用标志 `-f in.largefile` 和 `-L 4` 运行模拟器。==

The latter sets the large-file exception to 4 blocks.
==后者将大文件例外设置为 4 个块。==

What will the resulting allocation look like?
==最终的分配会是什么样子的？==

Run with `-c` to check.
==使用 `-c` 运行以检查。==

2. Now run with `-L 30`.
==2. 现在使用 `-L 30` 运行。==

What do you expect to see?
==你期望看到什么？==

Once again, turn on `-c` to see if you were right.
==再次打开 `-c` 看看你是否正确。==

You can also use `-S` to see exactly which blocks were allocated to the file `/a`.
==你还可以使用 `-S` 来查看具体哪些块被分配给了文件 `/a`。==

3. Now we will compute some statistics about the file.
==3. 现在我们将计算一些关于文件的统计信息。==

The first is something we call **filespan**, which is the max distance between any two data blocks of the file or between the inode and any data block.
==第一个是我们称之为 **filespan** 的指标，它是文件的任何两个数据块之间，或者 inode 与任何数据块之间的最大距离。==

Calculate the filespan of `/a`.
==计算 `/a` 的 filespan。==

Run `ffs.py -f in.largefile -L 4 -T -c` to see what it is.
==运行 `ffs.py -f in.largefile -L 4 -T -c` 查看结果。==

Do the same with `-L 100`.
==对 `-L 100` 执行相同的操作。==

What difference do you expect in filespan as the large-file exception parameter changes from low values to high values?
==当大文件例外参数从低值变为高值时，你预期的 filespan 会有什么变化？==

4. Now let’s look at a new input file, `in.manyfiles`.
==4. 现在让我们看一个新的输入文件 `in.manyfiles`。==

How do you think the FFS policy will lay these files out across groups?
==你认为 FFS 策略将如何跨组布局这些文件？==

(you can run with `-v` to see what files and directories are created, or just `cat in.manyfiles`).
==（你可以使用 `-v` 运行来查看创建了哪些文件和目录，或者直接 `cat in.manyfiles`）。==

Run the simulator with `-c` to see if you were right.
==使用 `-c` 运行模拟器，看看你是否正确。==

5. A metric to evaluate FFS is called **dirspan**.
==5. 评估 FFS 的一个指标称为 **dirspan**。==

This metric calculates the spread of files within a particular directory, specifically the max distance between the inodes and data blocks of all files in the directory and the inode and data block of the directory itself.
==该指标计算特定目录内文件的分布情况，具体而言，是该目录中所有文件的 inode 和数据块，与目录自身的 inode 和数据块之间的最大距离。==

Run with `in.manyfiles` and the `-T` flag, and calculate the dirspan of the three directories.
==使用 `in.manyfiles` 和 `-T` 标志运行，并计算三个目录的 dirspan。==

Run with `-c` to check.
==使用 `-c` 运行以检查。==

How good of a job does FFS do in minimizing dirspan?
==FFS 在最小化 dirspan 方面做得如何？==

6. Now change the size of the inode table per group to 5 (`-i 5`).
==6. 现在将每个组的 inode 表大小更改为 5 (`-i 5`)。==

How do you think this will change the layout of the files?
==你认为这将如何改变文件的布局？==

Run with `-c` to see if you were right.
==使用 `-c` 运行，看看你是否正确。==

How does it affect the dirspan?
==它对 dirspan 有什么影响？==

7. Which group should FFS place inode of a new directory in?
==7. FFS 应该将新目录的 inode 放在哪个组中？==

The default (simulator) policy looks for the group with the most free inodes.
==默认（模拟器）策略是寻找拥有最多空闲 inode 的组。==

A different policy looks for a set of groups with the most free inodes.
==另一种策略是寻找一组拥有最多空闲 inode 的组。==

For example, if you run with `-A 2`, when allocating a new directory, the simulator will look at groups in pairs and pick the best pair for the allocation.
==例如，如果使用 `-A 2` 运行，在分配新目录时，模拟器将成对查看组，并选择最佳的一对进行分配。==

Run `./ffs.py -f in.manyfiles -i 5 -A 2 -c` to see how allocation changes with this strategy.
==运行 `./ffs.py -f in.manyfiles -i 5 -A 2 -c` 查看该策略下分配的变化。==

How does it affect dirspan?
==它对 dirspan 有什么影响？==

Why might this policy be good?
==为什么这个策略可能比较好？==

8. One last policy change we will explore relates to file fragmentation.
==8. 我们将探讨的最后一个策略更改与文件碎片有关。==

Run `./ffs.py -f in.fragmented -v` and see if you can predict how the files that remain are allocated.
==运行 `./ffs.py -f in.fragmented -v`，看看你是否能预测剩余文件的分配方式。==

Run with `-c` to confirm your answer.
==使用 `-c` 运行以确认你的答案。==

What is interesting about the data layout of file `/i`?
==文件 `/i` 的数据布局有什么有趣之处？==

Why is it problematic?
==为什么它是有问题的？==

9. A new policy, which we call **contiguous allocation** (`-C`), tries to ensure that each file is allocated contiguously.
==9. 一种被称为**连续分配** (`-C`) 的新策略，试图确保每个文件都被连续分配。==

Specifically, with `-C n`, the file system tries to ensure that $n$ contiguous blocks are free within a group before allocating a block.
==具体而言，使用 `-C n`，文件系统会尝试在分配一个块之前，确保组内有 $n$ 个连续的空闲块。==

Run `./ffs.py -f in.fragmented -v -C 2 -c` to see the difference.
==运行 `./ffs.py -f in.fragmented -v -C 2 -c` 查看区别。==

How does layout change as the parameter passed to `-C` increases?
==随着传递给 `-C` 的参数增加，布局会如何变化？==

Finally, how does `-C` affect filespan and dirspan?
==最后，`-C` 是如何影响 filespan 和 dirspan 的？==

**42**
**42**

**Crash Consistency: FSCK and Journaling**
==**崩溃一致性：FSCK 与日志**==

As we’ve seen thus far, the file system manages a set of data structures to implement the expected abstractions: files, directories, and all of the other metadata needed to support the basic abstraction that we expect from a file system.
==正如我们目前所见，文件系统管理着一组数据结构来实现预期的抽象：文件、目录以及支持我们对文件系统所期望的基本抽象所需的所有其他元数据。==

Unlike most data structures (for example, those found in memory of a running program), file system data structures must **persist**, i.e., they must survive over the long haul, stored on devices that retain data despite power loss (such as hard disks or flash-based SSDs).
==与大多数数据结构（例如运行程序内存中的数据结构）不同，文件系统的数据结构必须**持久化**（persist），即它们必须能够长期保存，存储在断电后仍能保留数据的设备上（如硬盘或基于闪存的 SSD）。==

One major challenge faced by a file system is how to update persistent data structures despite the presence of a **power loss** or **system crash**.
==文件系统面临的一个主要挑战是，在存在**断电**或**系统崩溃**的情况下，如何更新持久性数据结构。==

Specifically, what happens if, right in the middle of updating on-disk structures, someone trips over the power cord and the machine loses power?
==具体来说，如果在更新磁盘结构的途中，有人绊到了电源线导致机器断电，会发生什么？==

Or the operating system encounters a bug and crashes?
==或者操作系统遇到了 bug 并崩溃了？==

Because of power losses and crashes, updating a persistent data structure can be quite tricky, and leads to a new and interesting problem in file system implementation, known as the **crash-consistency problem**.
==由于断电和崩溃，更新持久性数据结构可能会非常棘手，并导致文件系统实现中的一个新而有趣的问题，即**崩溃一致性问题**（crash-consistency problem）。==

This problem is quite simple to understand.
==这个问题很容易理解。==

Imagine you have to update two on-disk structures, $A$ and $B$, in order to complete a particular operation.
==假设你必须更新两个磁盘结构 $A$ 和 $B$ 才能完成特定操作。==

Because the disk only services a single request at a time, one of these requests will reach the disk first (either $A$ or $B$).
==因为磁盘一次只能处理一个请求，所以这些请求中的一个会首先到达磁盘（要么是 $A$，要么是 $B$）。==

If the system crashes or loses power after one write completes, the on-disk structure will be left in an **inconsistent** state.
==如果系统在一次写入完成后崩溃或断电，磁盘结构将处于**不一致**的状态。==

And thus, we have a problem that all file systems need to solve:
==因此，我们遇到了一个所有文件系统都需要解决的问题：==

**THE CRUX: HOW TO UPDATE THE DISK DESPITE CRASHES**
==**核心问题：如何在崩溃的情况下更新磁盘**==

The system may crash or lose power between any two writes, and thus the on-disk state may only partially get updated.
==系统可能会在任何两次写入之间崩溃或断电，因此磁盘状态可能只得到了部分更新。==

After the crash, the system boots and wishes to mount the file system again (in order to access files and such).
==崩溃后，系统启动并希望再次挂载文件系统（以便访问文件等）。==

Given that crashes can occur at arbitrary points in time, how do we ensure the file system keeps the on-disk image in a reasonable state?
==鉴于崩溃可能发生在任何时间点，我们如何确保文件系统将磁盘镜像保持在合理的状态？==

In this chapter, we’ll describe this problem in more detail, and look at some methods file systems have used to overcome it.
==在本章中，我们将更详细地描述这个问题，并研究文件系统用来克服它的一些方法。==

We’ll begin by examining the approach taken by older file systems, known as **fsck** or the **file system checker**.
==我们将首先研究旧文件系统采取的方法，即 **fsck** 或**文件系统检查器**。==

We’ll then turn our attention to another approach, known as **journaling** (also known as **write-ahead logging**), a technique which adds a little bit of overhead to each write but recovers more quickly from crashes or power losses.
==然后，我们将注意力转向另一种方法，即**日志**（journaling，也称为**写前日志** write-ahead logging），这种技术给每次写入增加了一点点开销，但从崩溃或断电中恢复的速度更快。==

We will discuss the basic machinery of journaling, including a few different flavors of journaling that Linux ext3 [T98, PAA05] (a relatively modern journaling file system) implements.
==我们将讨论日志的基本机制，包括 Linux ext3 [T98, PAA05]（一种相对现代的日志文件系统）实现的几种不同类型的日志。==

**42.1 A Detailed Example**
==**42.1 一个详细的示例**==

To kick off our investigation of journaling, let’s look at an example.
==为了开始我们对日志的研究，让我们来看一个例子。==

We’ll need to use a workload that updates on-disk structures in some way.
==我们需要使用一种以某种方式更新磁盘结构的工作负载。==

Assume here that the workload is simple: the append of a single data block to an existing file.
==这里假设工作负载很简单：向现有文件追加一个数据块。==

The append is accomplished by opening the file, calling `lseek()` to move the file offset to the end of the file, and then issuing a single 4KB write to the file before closing it.
==追加操作是通过打开文件，调用 `lseek()` 将文件偏移量移动到文件末尾，然后在关闭文件之前向文件发出单个 4KB 写入来完成的。==

Let’s also assume we are using standard simple file system structures on the disk, similar to file systems we have seen before.
==我们还假设磁盘上使用的是标准的简单文件系统结构，类似于我们之前看到的文件系统。==

This tiny example includes an **inode bitmap** (with just 8 bits, one per inode), a **data bitmap** (also 8 bits, one per data block), **inodes** (8 total, numbered 0 to 7, and spread across four blocks), and **data blocks** (8 total, numbered 0 to 7).
==这个小例子包括一个 **inode 位图**（只有 8 位，每个 inode 一位）、一个**数据位图**（也是 8 位，每个数据块一位）、**inodes**（共 8 个，编号 0 到 7，分布在四个块中）和**数据块**（共 8 个，编号 0 到 7）。==

Here is a diagram of this file system:
==这是该文件系统的示意图：==

Bitmaps Inode Data Inodes Data Blocks I[v1] Da
==位图 Inode Data Inodes Data Blocks I[v1] Da==

0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7

If you look at the structures in the picture, you can see that a single inode is allocated (inode number 2), which is marked in the inode bitmap, and a single allocated data block (data block 4), also marked in the data bitmap.
==如果你看图中的结构，你可以看到分配了一个 inode（inode 编号 2），它在 inode 位图中标记；并且分配了一个数据块（数据块 4），它也在数据位图中标记。==

The inode is denoted I[v1], as it is the first version of this inode; it will soon be updated (due to the workload described above).
==该 inode 被表示为 I[v1]，因为它是该 inode 的第一个版本；由于上述工作负载，它很快就会被更新。==

Let’s peek inside this simplified inode too.
==我们也来看看这个简化版 inode 的内部。==

Inside of I[v1], we see:
==在 I[v1] 内部，我们看到：==

```
owner       : remzi
permissions : read-write
size        : 1
pointer     : 4
pointer     : null
pointer     : null
pointer     : null
```

In this simplified inode, the `size` of the file is 1 (it has one block allocated), the first direct pointer points to block 4 (the first data block of the file, Da), and all three other direct pointers are set to `null` (indicating that they are not used).
==在这个简化的 inode 中，文件的 `size` 为 1（它分配了一个块），第一个直接指针指向块 4（文件的第一个数据块 Da），而所有其他三个直接指针都设置为 `null`（表示它们未被使用）。==

Of course, real inodes have many more fields; see previous chapters for more information.
==当然，真实的 inode 有更多的字段；更多信息请参见之前的章节。==

When we append to the file, we are adding a new data block to it, and thus must update three on-disk structures: the inode (which must point to the new block and record the new larger size due to the append), the new data block $Db$, and a new version of the data bitmap (call it $B[v2]$) to indicate that the new data block has been allocated.
==当我们向文件追加内容时，我们要给它添加一个新的数据块，因此必须更新三个磁盘结构：inode（它必须指向新块并记录由于追加而产生的新文件大小）、新数据块 $Db$，以及数据位图的新版本（称之为 $B[v2]$）以指示新数据块已被分配。==

Thus, in the memory of the system, we have three blocks which we must write to disk.
==因此，在系统的内存中，我们有三个必须写入磁盘的块。==

The updated inode (inode version 2, or I[v2] for short) now looks like this:
==更新后的 inode（inode 版本 2，简称 I[v2]）现在看起来像这样：==

```
owner       : remzi
permissions : read-write
size        : 2
pointer     : 4
pointer     : 5
pointer     : null
pointer     : null
```

The updated data bitmap ($B[v2]$) now looks like this: `00001100`.
==更新后的数据位图 ($B[v2]$) 现在看起来像这样：`00001100`。==

Finally, there is the data block ($Db$), which is just filled with whatever it is users put into files.
==最后是数据块 ($Db$)，它只是填充了用户放入文件中的任何内容。==

Stolen music, perhaps?
==也许是盗版音乐？==

What we would like is for the final on-disk image of the file system to look like this:
==我们希望文件系统最终的磁盘镜像看起来像这样：==

Bitmaps Inode Data Inodes Data Blocks I[v2] Da Db
==位图 Inode Data Inodes Data Blocks I[v2] Da Db==

0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7

To achieve this transition, the file system must perform three separate writes to the disk, one each for the inode ($I[v2]$), bitmap ($B[v2]$), and data block ($Db$).
==为了实现这种转变，文件系统必须对磁盘执行三次独立的写入，分别针对 inode ($I[v2]$)、位图 ($B[v2]$) 和数据块 ($Db$)。==

Note that these writes usually don’t happen immediately when the user issues a `write()` system call; rather, the dirty inode, bitmap, and new data will sit in main memory (in the **page cache** or **buffer cache**) for some time first; then, when the file system finally decides to write them to disk (after say 5 seconds or 30 seconds), the file system will issue the requisite write requests to the disk.
==请注意，这些写入通常不会在用户发出 `write()` 系统调用时立即发生；相反，脏 inode、位图和新数据会先在主存（**页缓存**或**缓冲缓存**）中存放一段时间；然后，当文件系统最终决定将它们写入磁盘时（比如 5 秒或 30 秒后），文件系统将向磁盘发出必要的写入请求。==

Unfortunately, a crash may occur and thus interfere with these updates to the disk.
==不幸的是，可能会发生崩溃，从而干扰这些对磁盘的更新。==

In particular, if a crash happens after one or two of these writes have taken place, but not all three, the file system could be left in a funny state.
==特别是，如果崩溃发生在完成一两次写入之后，但还没完成全部三次，文件系统可能会处于一种奇怪的状态。==

**Crash Scenarios**
==**崩溃场景**==

To understand the problem better, let’s look at some example crash scenarios.
==为了更好地理解这个问题，让我们看看一些示例崩溃场景。==

Imagine only a single write succeeds; there are thus three possible outcomes, which we list here:
==假设只有一次写入成功；因此有三种可能的结果，我们在此列出：==

* **Just the data block ($Db$) is written to disk.**
==* **只有数据块 ($Db$) 写入了磁盘。**==

In this case, the data is on disk, but there is no inode that points to it and no bitmap that even says the block is allocated.
==在这种情况下，数据在磁盘上，但没有指向它的 inode，甚至没有位图指示该块已被分配。==

Thus, it is as if the write never occurred.
==因此，这就好像写入从未发生过一样。==

This case is not a problem at all, from the perspective of file-system crash consistency.
==从文件系统崩溃一致性的角度来看，这种情况根本不是问题。==

* **Just the updated inode ($I[v2]$) is written to disk.**
==* **只有更新后的 inode ($I[v2]$) 写入了磁盘。**==

In this case, the inode points to the disk address (5) where $Db$ was about to be written, but $Db$ has not yet been written there.
==在这种情况下，inode 指向了 $Db$ 即将写入的磁盘地址 (5)，但 $Db$ 尚未写入那里。==

Thus, if we trust that pointer, we will read **garbage data** from the disk (the old contents of disk address 5).
==因此，如果我们信任该指针，我们将从磁盘读取到**垃圾数据**（磁盘地址 5 的旧内容）。==

Further, we have a new problem, which we call a **file-system inconsistency**.
==此外，我们遇到了一个新问题，我们称之为**文件系统不一致性**。==

The on-disk bitmap is telling us that data block 5 has not been allocated, but the inode is saying that it has.
==磁盘上的位图告诉我们数据块 5 尚未分配，但 inode 却说它已经分配了。==

The disagreement between the bitmap and the inode is an inconsistency in the data structures of the file system; to use the file system, we must somehow resolve this problem (more on that below).
==位图和 inode 之间的分歧是文件系统数据结构中的一种不一致性；为了使用文件系统，我们必须设法解决这个问题（详见下文）。==

* **Just the updated bitmap ($B[v2]$) is written to disk.**
==* **只有更新后的位图 ($B[v2]$) 写入了磁盘。**==

In this case, the bitmap indicates that block 5 is allocated, but there is no inode that points to it.
==在这种情况下，位图指示块 5 已分配，但没有 inode 指向它。==

Thus the file system is inconsistent again; if left unresolved, this write would result in a **space leak**, as block 5 would never be used by the file system.
==因此文件系统再次不一致；如果不解决，这次写入将导致**空间泄漏**，因为块 5 永远不会被文件系统使用。==

There are also three more crash scenarios in this attempt to write three blocks to disk.
==在这次尝试将三个块写入磁盘的过程中，还有另外三种崩溃场景。==

In these cases, two writes succeed and the last one fails:
==在这些情况下，两次写入成功，最后一次失败：==

* **The inode ($I[v2]$) and bitmap ($B[v2]$) are written to disk, but not data ($Db$).**
==* **inode ($I[v2]$) 和位图 ($B[v2]$) 写入了磁盘，但数据 ($Db$) 没有。**==

In this case, the file system metadata is completely consistent: the inode has a pointer to block 5, the bitmap indicates that 5 is in use, and thus everything looks OK from the perspective of the file system’s metadata.
==在这种情况下，文件系统元数据是完全一致的：inode 有一个指向块 5 的指针，位图指示块 5 正在使用中，因此从文件系统元数据的角度来看，一切都显得正常。==

But there is one problem: 5 has garbage in it again.
==但有一个问题：块 5 中又是垃圾数据。==

* **The inode ($I[v2]$) and the data block ($Db$) are written, but not the bitmap ($B[v2]$).**
==* **inode ($I[v2]$) 和数据块 ($Db$) 写入了，但位图 ($B[v2]$) 没有。**==

In this case, we have the inode pointing to the correct data on disk, but again have an inconsistency between the inode and the old version of the bitmap (B1).
==在这种情况下，我们的 inode 指向了磁盘上正确的数据，但 inode 与旧版本的位图 (B1) 之间再次出现了不一致。==

Thus, we once again need to resolve the problem before using the file system.
==因此，在处理文件系统之前，我们再次需要解决这个问题。==

* **The bitmap ($B[v2]$) and data block ($Db$) are written, but not the inode ($I[v2]$).**
==* **位图 ($B[v2]$) 和数据块 ($Db$) 写入了，但 inode ($I[v2]$) 没有。**==

In this case, we again have an inconsistency between the inode and the data bitmap.
==在这种情况下，inode 和数据位图之间再次出现了不一致。==

However, even though the block was written and the bitmap indicates its usage, we have no idea which file it belongs to, as no inode points to the file.
==然而，尽管该块已写入且位图指示其已被使用，我们却不知道它属于哪个文件，因为没有 inode 指向该文件。==

**The Crash Consistency Problem**
==**崩溃一致性问题**==

Hopefully, from these crash scenarios, you can see the many problems that can occur to our on-disk file system image because of crashes: we can have inconsistency in file system data structures; we can have space leaks; we can return garbage data to a user; and so forth.
==希望通过这些崩溃场景，你可以看到崩溃会对我们的磁盘文件系统镜像造成的许多问题：文件系统数据结构可能不一致；可能会出现空间泄漏；可能会向用户返回垃圾数据；等等。==

What we’d like to do ideally is move the file system from one consistent state (e.g., before the file got appended to) to another **atomically** (e.g., after the inode, bitmap, and new data block have been written to disk).
==理想情况下，我们希望将文件系统**原子地**（atomically）从一个一致状态（例如，文件被追加之前）转换到另一个一致状态（例如，inode、位图和新数据块都已写入磁盘之后）。==

Unfortunately, we can’t do this easily because the disk only commits one write at a time, and crashes or power loss may occur between these updates.
==不幸的是，我们无法轻易做到这一点，因为磁盘一次只能提交一个写入，而这些更新之间可能会发生崩溃或断电。==

We call this general problem the **crash-consistency problem** (we could also call it the **consistent-update problem**).
==我们称这个普遍问题为**崩溃一致性问题**（也可以称之为**一致性更新问题**）。==

**42.2 Solution #1: The File System Checker**
==**42.2 解决方案 #1：文件系统检查器**==

Early file systems took a simple approach to crash consistency.
==早期的文件系统对崩溃一致性采取了一种简单的方法。==

Basically, they decided to let inconsistencies happen and then fix them later (when rebooting).
==基本上，它们决定让不一致性发生，然后稍后（重启时）再修复它们。==

A classic example of this lazy approach is found in a tool that does this: `fsck`.
==这种惰性方法的一个经典例子见于一个专门做这件事的工具：`fsck`。==

`fsck` is a UNIX tool for finding such inconsistencies and repairing them [MK96]; similar tools to check and repair a disk partition exist on different systems.
==`fsck` 是一个用于查找并修复此类不一致性的 UNIX 工具 [MK96]；不同系统上都存在类似的用于检查和修复磁盘分区的工具。==

Note that such an approach can’t fix all problems; consider, for example, the case above where the file system looks consistent but the inode points to garbage data.
==注意，这种方法不能解决所有问题；例如，考虑上述情况，文件系统看起来一致，但 inode 指向的是垃圾数据。==

The only real goal is to make sure the file system metadata is internally consistent.
==唯一的真正目标是确保文件系统元数据内部一致。==

The tool `fsck` operates in a number of phases, as summarized in McKusick and Kowalski’s paper [MK96].
==工具 `fsck` 在多个阶段运行，如 McKusick 和 Kowalski 的论文 [MK96] 中所总结的。==

It is run **before** the file system is mounted and made available (`fsck` assumes that no other file-system activity is on-going while it runs); once finished, the on-disk file system should be consistent and thus can be made accessible to users.
==它在文件系统被挂载并变为可用**之前**运行（`fsck` 假设在其运行时没有其他文件系统活动正在进行）；一旦完成，磁盘上的文件系统应该是一致的，从而可以被用户访问。==

Here is a basic summary of what `fsck` does:
==以下是 `fsck` 所做工作的基本总结：==

* **Superblock:** `fsck` first checks if the superblock looks reasonable, mostly doing sanity checks such as making sure the file system size is greater than the number of blocks that have been allocated.
==* **超级块：** `fsck` 首先检查超级块是否看起来合理，主要是进行完整性检查，例如确保文件系统大小大于已分配的块数。==

Usually the goal of these sanity checks is to find a suspect (corrupt) superblock; in this case, the system (or administrator) may decide to use an alternate copy of the superblock.
==通常这些完整性检查的目标是找到一个可疑（损坏）的超级块；在这种情况下，系统（或管理员）可能会决定使用超级块的备选副本。==

* **Free blocks:** Next, `fsck` scans the inodes, indirect blocks, double indirect blocks, etc., to build an understanding of which blocks are currently allocated within the file system.
==* **空闲块：** 接下来，`fsck` 扫描 inode、间接块、双重间接块等，以了解文件系统内当前分配了哪些块。==

It uses this knowledge to produce a correct version of the allocation bitmaps; thus, if there is any inconsistency between bitmaps and inodes, it is resolved by trusting the information within the inodes.
==它利用这些信息来生成分配位图的正确版本；因此，如果位图和 inode 之间存在任何不一致，将通过信任 inode 中的信息来解决。==

The same type of check is performed for all the inodes, making sure that all inodes that look like they are in use are marked as such in the inode bitmaps.
==对所有 inode 执行同类型的检查，确保所有看起来正在使用的 inode 在 inode 位图中都被标记为已使用。==

* **Inode state:** Each inode is checked for corruption or other problems.
==* **Inode 状态：** 检查每个 inode 是否损坏或其他问题。==

For example, `fsck` makes sure that each allocated inode has a valid type field (e.g., regular file, directory, symbolic link, etc.).
==例如，`fsck` 确保每个分配的 inode 都有一个有效的类型字段（例如，普通文件、目录、符号链接等）。==

If there are problems with the inode fields that are not easily fixed, the inode is considered suspect and cleared by `fsck`; the inode bitmap is correspondingly updated.
==如果 inode 字段中存在不容易修复的问题，该 inode 将被视为可疑并由 `fsck` 清除；inode 位图也会相应更新。==

* **Inode links:** `fsck` also verifies the link count of each allocated inode.
==* **Inode 链接：** `fsck` 还验证每个已分配 inode 的链接计数。==

As you may recall, the link count indicates the number of different directories that contain a reference (i.e., a link) to this particular file.
==你可能还记得，链接计数表示包含对该特定文件引用（即链接）的不同目录的数量。==

To verify the link count, `fsck` scans through the entire directory tree, starting at the root directory, and builds its own link counts for every file and directory in the file system.
==为了验证链接计数，`fsck` 从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。==

If there is a mismatch between the newly-calculated count and that found within an inode, corrective action must be taken, usually by fixing the count within the inode.
==如果新计算的计数与 inode 中的计数不匹配，必须采取纠正措施，通常是修正 inode 内部的计数。==

If an allocated inode is discovered but no directory refers to it, it is moved to the `lost+found` directory.
==如果发现一个已分配的 inode 但没有目录引用它，它将被移动到 `lost+found` 目录中。==

* **Duplicates:** `fsck` also checks for duplicate pointers, i.e., cases where two different inodes refer to the same block.
==* **重复项：** `fsck` 还会检查重复指针，即两个不同的 inode 指向同一个块的情况。==

If one inode is obviously bad, it may be cleared.
==如果一个 inode 明显是坏的，它可能会被清除。==

Alternately, the pointed-to block could be copied, thus giving each inode its own copy as desired.
==或者，可以复制所指向的块，从而根据需要为每个 inode 提供其自己的副本。==

* **Bad blocks:** A check for bad block pointers is also performed while scanning through the list of all pointers.
==* **坏块：** 在扫描所有指针列表时，还会执行坏块指针检查。==

A pointer is considered “bad” if it obviously points to something outside its valid range, e.g., it has an address that refers to a block greater than the partition size.
==如果一个指针明显指向其有效范围之外的内容，则被认为是“坏”的，例如，它的地址指向大于分区大小的块。==

In this case, `fsck` can’t do anything too intelligent; it just removes (clears) the pointer from the inode or indirect block.
==在这种情况下，`fsck` 做不了太聪明的事情；它只是从 inode 或间接块中移除（清除）该指针。==

* **Directory checks:** `fsck` does not understand the contents of user files; however, directories hold specifically formatted information created by the file system itself.
==* **目录检查：** `fsck` 不理解用户文件的内容；然而，目录保存了由文件系统自身创建的特定格式信息。==

Thus, `fsck` performs additional integrity checks on the contents of each directory, making sure that “.” and “..” are the first entries, that each inode referred to in a directory entry is allocated, and ensuring that no directory is linked to more than once in the entire hierarchy.
==因此，`fsck` 对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前两个条目，目录条目中引用的每个 inode 都是已分配的，并确保整个层级结构中没有目录被链接超过一次。==

As you can see, building a working `fsck` requires intricate knowledge of the file system; making sure such a piece of code works correctly in all cases can be challenging [G+08].
==如你所见，构建一个可运行的 `fsck` 需要对文件系统有深入的了解；确保这样一段代码在所有情况下都能正确运行是很有挑战性的 [G+08]。==

However, `fsck` (and similar approaches) have a bigger and perhaps more fundamental problem: they are **too slow**.
==然而，`fsck`（及类似方法）有一个更大、或许更根本的问题：它们**太慢了**。==

With a very large disk volume, scanning the entire disk to find all the allocated blocks and read the entire directory tree may take many minutes or hours.
==对于非常大的磁盘卷，扫描整个磁盘以找到所有分配的块并读取整个目录树可能需要花费数分钟或数小时。==

Performance of `fsck`, as disks grew in capacity and RAIDs grew in popularity, became prohibitive (despite recent advances [M+13]).
==随着磁盘容量的增加和 RAID 的普及，`fsck` 的性能变得令人望而却步（尽管最近有所进展 [M+13]）。==

At a higher level, the basic premise of `fsck` seems just a tad irrational.
==在更高层面上，`fsck` 的基本前提似乎有一点点不合理。==

Consider our example above, where just three blocks are written to the disk; it is incredibly expensive to scan the entire disk to fix problems that occurred during an update of just three blocks.
==考虑我们上面的例子，其中只向磁盘写入了三个块；扫描整个磁盘来修复仅在三个块的更新过程中发生的问题是极其昂贵的。==

This situation is akin to dropping your keys on the floor in your bedroom, and then commencing a **search-the-entire-house-for-keys** recovery algorithm, starting in the basement and working your way through every room.
==这种情况类似于你把钥匙掉在卧室的地板上，然后开始执行一个“搜遍全家找钥匙”的恢复算法，从地下室开始，挨个房间搜寻。==

It works but is wasteful.
==它有效，但很浪费。==

Thus, as disks (and RAIDs) grew, researchers and practitioners started to look for other solutions.
==因此，随着磁盘（和 RAID）的发展，研究人员和从业者开始寻找其他解决方案。==

**42.3 Solution #2: Journaling (or Write-Ahead Logging)**
==**42.3 解决方案 #2：日志（或写前日志）**==

Probably the most popular solution to the consistent update problem is to steal an idea from the world of database management systems.
==解决一致性更新问题最流行的方法可能是从数据库管理系统领域借鉴一个想法。==

That idea, known as **write-ahead logging**, was invented to address exactly this type of problem.
==这个被称为**写前日志**的想法正是为了解决这类问题而发明的。==

In file systems, we usually call write-ahead logging **journaling** for historical reasons.
==在文件系统中，由于历史原因，我们通常将写前日志称为**日志**（journaling）。==

The first file system to do this was Cedar [H87], though many modern file systems use the idea, including Linux ext3 and ext4, reiserfs, IBM’s JFS, SGI’s XFS, and Windows NTFS.
==第一个这样做的文件系统是 Cedar [H87]，尽管许多现代文件系统都使用了这个想法，包括 Linux ext3 和 ext4、reiserfs、IBM 的 JFS、SGI 的 XFS 和 Windows NTFS。==

The basic idea is as follows.
==基本思想如下。==

When updating the disk, before overwriting the structures in place, first write down a little note (somewhere else on the disk, in a well-known location) describing what you are about to do.
==在更新磁盘时，在就地覆盖结构之前，先写下一个小笔记（在磁盘的其他地方，一个众所周知的位置），描述你即将要做什么。==

Writing this note is the “write ahead” part, and we write it to a structure that we organize as a “log”; hence, write-ahead logging.
==写下这个笔记就是“写前”部分，我们将其写入一个被组织为“日志”的结构中；因此得名写前日志。==

By writing the note to disk, you are guaranteeing that if a crash takes places during the update (overwrite) of the structures you are updating, you can go back and look at the note you made and try again; thus, you will know exactly what to fix (and how to fix it) after a crash, instead of having to scan the entire disk.
==通过将笔记写入磁盘，你可以保证如果在更新（覆盖）你正在更新的结构期间发生崩溃，你可以回头查看你做的笔记并重试；因此，在崩溃后你将确切知道要修复什么（以及如何修复），而不必扫描整个磁盘。==

By design, journaling thus adds a bit of work during updates to greatly reduce the amount of work required during recovery.
==通过这种设计，日志在更新期间增加了一点工作量，以大幅减少恢复期间所需的工作量。==

We’ll now describe how **Linux ext3**, a popular journaling file system, incorporates journaling into the file system.
==我们现在将描述流行的日志文件系统 **Linux ext3** 是如何将日志融入文件系统的。==

Most of the on-disk structures are identical to **Linux ext2**, e.g., the disk is divided into block groups, and each block group contains an inode bitmap, data bitmap, inodes, and data blocks.
==大多数磁盘结构与 **Linux ext2** 相同，例如，磁盘被划分为块组，每个块组包含 inode 位图、数据位图、inode 和数据块。==

The new key structure is the **journal** itself, which occupies some small amount of space within the partition or on another device.
==新的关键结构是**日志**本身，它在分区内或另一个设备上占据少量的空间。==

Thus, an ext2 file system (without journaling) looks like this:
==因此，一个 ext2 文件系统（没有日志）看起来像这样：==

`Super | Group 0 | Group 1 | . . . | Group N`
==`超级块 | 组 0 | 组 1 | . . . | 组 N`==

Assuming the journal is placed within the same file system image (though sometimes it is placed on a separate device, or as a file within the file system), an ext3 file system with a journal looks like this:
==假设日志放置在同一个文件系统镜像中（尽管有时它被放置在独立的设备上，或者作为文件系统内的一个文件），带日志的 ext3 文件系统看起来像这样：==

`Super | Journal | Group 0 | Group 1 | . . . | Group N`
==`超级块 | 日志 | 组 0 | 组 1 | . . . | 组 N`==

The real difference is just the presence of the journal, and of course, how it is used.
==真正的区别仅在于日志的存在，当然，还有它是如何被使用的。==

**Data Journaling**
==**数据日志**==

Let’s look at a simple example to understand how **data journaling** works.
==让我们看一个简单的例子来理解**数据日志**（data journaling）是如何工作的。==

Data journaling is available as a mode with the Linux ext3 file system, from which much of this discussion is based.
==数据日志是 Linux ext3 文件系统的一种可选模式，本次讨论的大部分内容都基于此。==

Say we have our canonical update again, where we wish to write the inode ($I[v2]$), bitmap ($B[v2]$), and data block ($Db$) to disk again.
==假设我们再次遇到经典的更新情况，我们希望再次将 inode ($I[v2]$)、位图 ($B[v2]$) 和数据块 ($Db$) 写入磁盘。==

Before writing them to their final disk locations, we are now first going to write them to the log (a.k.a. journal).
==在将它们写入最终磁盘位置之前，我们现在首先将它们写入日志（又称 journal）。==

This is what this will look like in the log:
==这就是它在日志中的样子：==

`Journal: | TxB | I[v2] | B[v2] | Db | TxE |`
==`日志： | 事务开始 | I[v2] | B[v2] | Db | 事务结束 |`==

You can see we have written five blocks here.
==你可以看到我们在这里写了五个块。==

The **transaction begin** (TxB) tells us about this update, including information about the pending update to the file system (e.g., the final addresses of the blocks $I[v2]$, $B[v2]$, and $Db$), and some kind of **transaction identifier** (TID).
==**事务开始** (TxB) 告知我们这次更新的信息，包括文件系统待处理更新的信息（例如块 $I[v2]$、$B[v2]$ 和 $Db$ 的最终地址），以及某种**事务标识符** (TID)。==

The middle three blocks just contain the exact contents of the blocks themselves; this is known as **physical logging** as we are putting the exact physical contents of the update in the journal (an alternate idea, **logical logging**, puts a more compact logical representation of the update in the journal, e.g., “this update wishes to append data block Db to file X”, which is a little more complex but can save space in the log and perhaps improve performance).
==中间的三个块只包含块本身的精确内容；这被称为**物理日志**（physical logging），因为我们将更新的精确物理内容放入日志中（另一种想法是**逻辑日志** logical logging，它将更新的更紧凑的逻辑表示放入日志中，例如“此更新希望将数据块 Db 追加到文件 X”，这稍微复杂一些，但可以节省日志空间并可能提高性能）。==

The final block (TxE) is a marker of the end of this transaction, and will also contain the TID.
==最后一个块 (TxE) 是该事务结束的标记，也将包含 TID。==

Once this transaction is safely on disk, we are ready to overwrite the old structures in the file system; this process is called **checkpointing**.
==一旦该事务安全地存入磁盘，我们就准备好覆盖文件系统中的旧结构了；这个过程被称为**检查点**（checkpointing）。==

Thus, to **checkpoint** the file system (i.e., bring it up to date with the pending update in the journal), we issue the writes $I[v2]$, $B[v2]$, and $Db$ to their disk locations as seen above; if these writes complete successfully, we have successfully checkpointed the file system and are basically done.
==因此，为了对文件系统执行**检查点**（即，使其与日志中待处理的更新保持一致），我们向上述磁盘位置发出 $I[v2]$、$B[v2]$ 和 $Db$ 的写入请求；如果这些写入成功完成，我们就成功地对文件系统执行了检查点，基本上就大功告成了。==

Thus, our initial sequence of operations:
==因此，我们最初的操作序列如下：==

1. **Journal write:** Write the transaction, including a transaction-begin block, all pending data and metadata updates, and a transaction-end block, to the log; wait for these writes to complete.
==1. **日志写入：** 将事务（包括事务开始块、所有待处理的数据和元数据更新以及事务结束块）写入日志；等待这些写入完成。==

2. **Checkpoint:** Write the pending metadata and data updates to their final locations in the file system.
==2. **检查点：** 将待处理的元数据和数据更新写入它们在文件系统中的最终位置。==

In our example, we would write TxB, $I[v2]$, $B[v2]$, $Db$, and TxE to the journal first.
==在我们的例子中，我们会先将 TxB、$I[v2]$、$B[v2]$、$Db$ 和 TxE 写入日志。==

When these writes complete, we would complete the update by checkpointing $I[v2]$, $B[v2]$, and $Db$, to their final locations on disk.
==当这些写入完成时，我们将通过把 $I[v2]$、$B[v2]$ 和 $Db$ 检查点到它们在磁盘上的最终位置来完成更新。==

Things get a little trickier when a crash occurs during the writes to the journal.
==当在写入日志期间发生崩溃时，事情会变得有点复杂。==

Here, we are trying to write the set of blocks in the transaction (e.g., TxB, $I[v2]$, $B[v2]$, $Db$, TxE) to disk.
==在这里，我们试图将事务中的一组块（例如 TxB、$I[v2]$、$B[v2]$、$Db$、TxE）写入磁盘。==

One simple way to do this would be to issue each one at a time, waiting for each to complete, and then issuing the next.
==一种简单的方法是逐个发出请求，等待每个请求完成，然后再发出下一个。==

However, this is slow.
==然而，这很慢。==

Ideally, we’d like to issue all five block writes at once, as this would turn five writes into a single sequential write and thus be faster.
==理想情况下，我们希望一次性发出所有五个块的写入，因为这会将五次写入变成一次顺序写入，从而更快。==

However, this is unsafe, for the following reason: given such a big write, the disk internally may perform scheduling and complete small pieces of the big write in any order.
==然而，这是不安全的，原因如下：考虑到这么大的写入量，磁盘内部可能会进行调度，并以任何顺序完成大写入中的小片段。==

Thus, the disk internally may (1) write TxB, $I[v2]$, $B[v2]$, and TxE and only later (2) write $Db$.
==因此，磁盘内部可能会 (1) 写入 TxB、$I[v2]$、$B[v2]$ 和 TxE，而稍后才 (2) 写入 $Db$。==

Unfortunately, if the disk loses power between (1) and (2), this is what ends up on disk:
==不幸的是，如果磁盘在 (1) 和 (2) 之间失去动力，磁盘上的最终结果如下：==

`Journal: | TxB id=1 | I[v2] | B[v2] | ?? | TxE id=1 |`
==`日志： | TxB id=1 | I[v2] | B[v2] | ?? | TxE id=1 |`==

Why is this a problem?
==为什么这是一个问题？==

Well, the transaction looks like a valid transaction (it has a begin and an end with matching sequence numbers).
==嗯，这个事务看起来像一个有效的事务（它有一个开始和结束，且序列号匹配）。==

Further, the file system can’t look at that fourth block and know it is wrong; after all, it is arbitrary user data.
==此外，文件系统无法通过查看第四个块来判断它是错误的；毕竟，它是任意的用户数据。==

Thus, if the system now reboots and runs recovery, it will replay this transaction, and ignorantly copy the contents of the garbage block ‘??’ to the location where $Db$ is supposed to live.
==因此，如果系统现在重启并运行恢复，它将重放该事务，并无知地将垃圾块 ‘??’ 的内容复制到 $Db$ 应该存放的位置。==

This is bad for arbitrary user data in a file; it is much worse if it happens to a critical piece of file system, such as the superblock, which could render the file system unmountable.
==这对于文件中的任意用户数据来说是很糟糕的；如果它发生在文件系统的关键部分（如超级块），情况会糟糕得多，可能会导致文件系统无法挂载。==

**ASIDE: FORCING WRITES TO DISK**
==**旁注：强制写入磁盘**==

To enforce ordering between two disk writes, modern file systems have to take a few extra precautions.
==为了强制执行两次磁盘写入之间的顺序，现代文件系统必须采取一些额外的预防措施。==

In olden times, forcing ordering between two writes, $A$ and $B$, was easy: just issue the write of $A$ to the disk, wait for the disk to interrupt the OS when the write is complete, and then issue the write of $B$.
==在过去，强制两次写入 $A$ 和 $B$ 之间的顺序很容易：只需向磁盘发出 $A$ 的写入，等待磁盘在写入完成时中断操作系统，然后发出 $B$ 的写入。==

Things got slightly more complex due to the increased use of write caches within disks.
==由于磁盘内写入缓存的使用增加，情况变得稍微复杂了一些。==

With write buffering enabled (sometimes called **immediate reporting**), a disk will inform the OS the write is complete when it simply has been placed in the disk’s memory cache, and has not yet reached disk.
==当启用写入缓冲（有时称为**立即报告**）时，磁盘会在写入仅被放入磁盘内存缓存而尚未到达磁盘时，就通知操作系统写入已完成。==

If the OS then issues a subsequent write, it is not guaranteed to reach the disk after previous writes; thus ordering between writes is not preserved.
==如果操作系统随后发出后续写入，则不能保证它会在先前的写入之后到达磁盘；因此，写入之间的顺序无法得到保持。==

One solution is to disable write buffering.
==一种解决方案是禁用写入缓冲。==

However, more modern systems take extra precautions and issue explicit **write barriers**; such a barrier, when it completes, guarantees that all writes issued before the barrier will reach disk before any writes issued after the barrier.
==然而，更现代的系统会采取额外的预防措施，并发出显式的**写入屏障**（write barriers）；这种屏障在完成时保证，在屏障之前发出的所有写入都将在屏障之后发出的任何写入之前到达磁盘。==

All of this machinery requires a great deal of trust in the correct operation of the disk.
==所有这些机制都需要对磁盘的正确运行抱有极大的信任。==

Unfortunately, recent research shows that some disk manufacturers, in an effort to deliver “higher performing” disks, explicitly ignore write-barrier requests, thus making the disks seemingly run faster but at the risk of incorrect operation [C+13, R+11].
==不幸的是，最近的研究表明，一些磁盘制造商为了提供“更高性能”的磁盘，明确忽略了写入屏障请求，从而使磁盘看起来运行得更快，但却冒着运行错误的风险 [C+13, R+11]。==

As Kahan said, the fast almost always beats out the slow, even if the fast is wrong.
==正如 Kahan 所说，快几乎总是胜过慢，即使快是错误的。==

**ASIDE: OPTIMIZING LOG WRITES**
==**旁注：优化日志写入**==

You may have noticed a particular inefficiency of writing to the log.
==你可能已经注意到写入日志的一种特定低效性。==

Namely, the file system first has to write out the transaction-begin block and contents of the transaction; only after these writes complete can the file system send the transaction-end block to disk.
==也就是说，文件系统首先必须写出事务开始块和事务内容；只有在这些写入完成后，文件系统才能将事务结束块发送到磁盘。==

The performance impact is clear, if you think about how a disk works: usually an extra rotation is incurred (think about why).
==如果你思考一下磁盘是如何工作的，性能影响就很清楚了：通常会产生一次额外的旋转延迟（想想为什么）。==

One of our former graduate students, Vijayan Prabhakaran, had a simple idea to fix this problem [P+05].
==我们以前的一位研究生 Vijayan Prabhakaran 提出了一个简单的想法来解决这个问题 [P+05]。==

When writing a transaction to the journal, include a checksum of the contents of the journal in the begin and end blocks.
==在向日志写入事务时，在开始块和结束块中包含日志内容的校验和。==

Doing so enables the file system to write the entire transaction at once, without incurring a wait; if, during recovery, the file system sees a mismatch in the computed checksum versus the stored checksum in the transaction, it can conclude that a crash occurred during the write of the transaction and thus discard the file-system update.
==这样做使文件系统能够一次性写入整个事务，而无需等待；如果在恢复期间，文件系统发现计算出的校验和与事务中存储的校验和不匹配，它可以断定在事务写入过程中发生了崩溃，从而放弃该文件系统更新。==

Thus, with a small tweak in the write protocol and recovery system, a file system can achieve faster common-case performance; on top of that, the system is slightly more reliable, as any reads from the journal are now protected by a checksum.
==因此，通过对写入协议和恢复系统进行微调，文件系统可以实现更快的常见情况性能；除此之外，系统稍微更可靠一些，因为现在从日志中读取的任何内容都受到校验和的保护。==

This simple fix was attractive enough to gain the notice of Linux file system developers, who then incorporated it into the next generation Linux file system, called (you guessed it!) **Linux ext4**.
==这个简单的修复方案非常有吸引力，引起了 Linux 文件系统开发人员的注意，随后他们将其纳入了下一代 Linux 文件系统，即（你猜对了！）**Linux ext4**。==

It now ships on millions of machines worldwide, including the Android handheld platform.
==它现在已安装在全球数百万台机器上，包括 Android 手持平台。==

Thus, every time you write to disk on many Linux-based systems, a little code developed at Wisconsin makes your system a little faster and more reliable.
==因此，在许多基于 Linux 的系统上，每当你向磁盘写入数据时，威斯康星大学开发的一点代码都会让你的系统变得更快、更可靠一些。==

To avoid this problem, the file system issues the transactional write in two steps.
==为了避免这个问题，文件系统分两步发出事务性写入。==

First, it writes all blocks except the TxE block to the journal, issuing these writes all at once.
==首先，它将除 TxE 块之外的所有块写入日志，一次性发出这些写入。==

When these writes complete, the journal will look something like this (assuming our append workload again):
==当这些写入完成时，日志看起来就像这样（再次假设我们的追加工作负载）：==

`Journal: | TxB id=1 | I[v2] | B[v2] | Db |`
==`日志： | TxB id=1 | I[v2] | B[v2] | Db |`==

When those writes complete, the file system issues the write of the TxE block, thus leaving the journal in this final, safe state:
==当这些写入完成时，文件系统发出 TxE 块的写入，从而使日志处于最终的安全状态：==

`Journal: | TxB id=1 | I[v2] | B[v2] | Db | TxE id=1 |`
==`日志： | TxB id=1 | I[v2] | B[v2] | Db | TxE id=1 |`==

An important aspect of this process is the **atomicity** guarantee provided by the disk.
==这个过程的一个重要方面是磁盘提供的**原子性**（atomicity）保证。==

It turns out that the disk guarantees that any 512-byte write will either happen or not (and never be half-written); thus, to make sure the write of TxE is atomic, one should make it a single 512-byte block.
==事实证明，磁盘保证任何 512 字节的写入要么发生，要么不发生（永远不会只写一半）；因此，为了确保 TxE 的写入是原子的，应该将其设为单个 512 字节的块。==

Thus, our current protocol to update the file system, with each of its three phases labeled:
==因此，我们当前的更新文件系统的协议如下，其三个阶段分别标记为：==

1. **Journal write:** Write the contents of the transaction (including TxB, metadata, and data) to the log; wait for these writes to complete.
==1. **日志写入：** 将事务内容（包括 TxB、元数据和数据）写入日志；等待这些写入完成。==

2. **Journal commit:** Write the transaction commit block (containing TxE) to the log; wait for write to complete; transaction is said to be **committed**.
==2. **日志提交：** 将事务提交块（包含 TxE）写入日志；等待写入完成；此时事务被称为已**提交**（committed）。==

3. **Checkpoint:** Write the contents of the update (metadata and data) to their final on-disk locations.
==3. **检查点：** 将更新内容（元数据和数据）写入它们的最终磁盘位置。==

**Recovery**
==**恢复**==

Let’s now understand how a file system can use the contents of the journal to **recover** from a crash.
==现在让我们了解文件系统如何利用日志内容从崩溃中**恢复**（recover）。==

A crash may happen at any time during this sequence of updates.
==崩溃可能在这一系列更新过程中的任何时刻发生。==

If the crash happens before the transaction is written safely to the log (i.e., before Step 2 above completes), then our job is easy: the pending update is simply skipped.
==如果崩溃发生在事务安全地写入日志之前（即在上述步骤 2 完成之前），那么我们的工作很简单：只需跳过待处理的更新。==

If the crash happens after the transaction has committed to the log, but before the checkpoint is complete, the file system can **recover** the update as follows.
==如果崩溃发生在事务已提交到日志之后，但在检查点完成之前，文件系统可以按如下方式**恢复**更新。==

When the system boots, the file system recovery process will scan the log and look for transactions that have committed to the disk; these transactions are thus **replayed** (in order), with the file system again attempting to write out the blocks in the transaction to their final on-disk locations.
==当系统启动时，文件系统恢复过程将扫描日志并寻找已提交到磁盘的事务；因此，这些事务将被**重放**（replayed，按顺序执行），文件系统再次尝试将事务中的块写入它们的最终磁盘位置。==

This form of logging is one of the simplest forms there is, and is called **redo logging**.
==这种形式的日志是现存最简单的形式之一，被称为**重做日志**（redo logging）。==

By recovering the committed transactions in the journal, the file system ensures that the on-disk structures are consistent, and thus can proceed by mounting the file system and readying itself for new requests.
==通过恢复日志中已提交的事务，文件系统确保磁盘结构是一致的，从而可以继续挂载文件系统并准备好处理新请求。==

Note that it is fine for a crash to happen at any point during checkpointing, even after some of the updates to the final locations of the blocks have completed.
==注意，在检查点过程中的任何一点发生崩溃都是可以的，即使在某些块到最终位置的更新已经完成后。==

In the worst case, some of these updates are simply performed again during recovery.
==在最坏的情况下，其中一些更新在恢复期间只是简单地再次执行。==

Because recovery is a rare operation (only taking place after an unexpected system crash), a few redundant writes are nothing to worry about.
==因为恢复是一种罕见的操作（仅在意外系统崩溃后发生），所以少量冗余写入无需担心。==

**Batching Log Updates**
==**批量日志更新**==

You might have noticed that the basic protocol could add a lot of extra disk traffic.
==你可能已经注意到，基本协议可能会增加大量的额外磁盘流量。==

For example, imagine we create two files in a row, called `file1` and `file2`, in the same directory.
==例如，假设我们在同一个目录中连续创建两个文件，分别称为 `file1` 和 `file2`。==

To create one file, one has to update a number of on-disk structures, minimally including: the inode bitmap (to allocate a new inode), the newly-created inode of the file, the data block of the parent directory containing the new directory entry, and the parent directory inode (which now has a new modification time).
==为了创建一个文件，必须更新许多磁盘结构，至少包括：inode 位图（用于分配新的 inode）、新创建的文件 inode、包含新目录项的父目录数据块，以及父目录 inode（它现在有了新的修改时间）。==

With journaling, we logically commit all of this information to the journal for each of our two file creations; because the files are in the same directory, and assuming they even have inodes within the same inode block, this means that if we’re not careful, we’ll end up writing these same blocks over and over.
==通过日志，我们逻辑上为两次文件创建分别向日志提交所有这些信息；因为文件在同一个目录中，并且假设它们的 inode 甚至在同一个 inode 块内，这意味着如果我们不小心，最终会一遍又一遍地写入这些相同的块。==

To remedy this problem, some file systems do not commit each update to disk one at a time (e.g., Linux ext3); rather, one can buffer all updates into a global transaction.
==为了解决这个问题，一些文件系统并不一次向磁盘提交一个更新（例如 Linux ext3）；相反，人们可以将所有更新缓冲到一个全局事务中。==

In our example above, when the two files are created, the file system just marks the in-memory inode bitmap, inodes of the files, directory data, and directory inode as dirty, and adds them to the list of blocks that form the current transaction.
==在上面的例子中，当创建两个文件时，文件系统只是将内存中的 inode 位图、文件的 inode、目录数据和目录 inode 标记为脏，并将它们添加到构成当前事务的块列表中。==

When it is finally time to write these blocks to disk (say, after a timeout of 5 seconds), this single global transaction is committed containing all of the updates described above.
==当最终需要将这些块写入磁盘时（比如在 5 秒超时后），这个包含上述所有更新的单一全局事务被提交。==

Thus, by buffering updates, a file system can avoid excessive write traffic to disk in many cases.
==因此，通过缓冲更新，文件系统在许多情况下可以避免过多的磁盘写入流量。==

**Making The Log Finite**
==**使日志有限**==

We thus have arrived at a basic protocol for updating file-system on-disk structures.
==至此，我们得出了更新文件系统磁盘结构的基本协议。==

The file system buffers updates in memory for some time; when it is finally time to write to disk, the file system first carefully writes out the details of the transaction to the journal (a.k.a. write-ahead log); after the transaction is complete, the file system checkpoints those blocks to their final locations on disk.
==文件系统将更新在内存中缓冲一段时间；当最终需要写入磁盘时，文件系统首先小心地将事务详情写入日志（又称写前日志）；事务完成后，文件系统将这些块检查点到它们在磁盘上的最终位置。==

However, the log is of a finite size.
==然而，日志的大小是有限的。==

If we keep adding transactions to it (as in this figure), it will soon fill.
==如果我们不断地向其中添加事务（如图所示），它很快就会填满。==

What do you think happens then?
==你认为那时会发生什么？==

`Journal: | Tx1 | Tx2 | Tx3 | Tx4 | Tx5 | ... |`
==`日志： | Tx1 | Tx2 | Tx3 | Tx4 | Tx5 | ... |`==

Two problems arise when the log becomes full.
==当日志变满时，会出现两个问题。==

The first is simpler, but less critical: the larger the log, the longer recovery will take, as the recovery process must replay all the transactions within the log (in order) to recover.
==第一个问题较简单，但不那么关键：日志越大，恢复所需的时间就越长，因为恢复过程必须（按顺序）重放日志中的所有事务才能恢复。==

The second is more of an issue: when the log is full (or nearly full), no further transactions can be committed to the disk, thus making the file system “less than useful” (i.e., useless).
==第二个问题更为严重：当日志已满（或接近已满）时，无法再向磁盘提交更多事务，从而使文件系统变得“不太有用”（即无用）。==

To address these problems, journaling file systems treat the log as a circular data structure, re-using it over and over; this is why the journal is sometimes referred to as a **circular log**.
==为了解决这些问题，日志文件系统将日志视为循环数据结构，反复重用；这就是为什么日志有时被称为**循环日志**（circular log）。==

To do so, the file system must take action some time after a checkpoint.
==为此，文件系统必须在检查点之后的某个时间采取行动。==

Specifically, once a transaction has been checkpointed, the file system should free the space it was occupying within the journal, allowing the log space to be reused.
==具体来说，一旦一个事务被检查点，文件系统就应该释放它在日志中占据的空间，从而允许重用日志空间。==

There are many ways to achieve this end; for example, you could simply mark the oldest and newest non-checkpointed transactions in the log in a **journal superblock**; all other space is free.
==有很多方法可以达到这个目的；例如，你只需在**日志超级块**中标记日志中最旧和最新的未检查点事务；所有其他空间都是空闲的。==

Here is a graphical depiction:
==这是一个图形化描述：==

`Journal: | Journal Super | Tx1 | Tx2 | Tx3 | Tx4 | Tx5 | ... |`
==`日志： | 日志超级块 | Tx1 | Tx2 | Tx3 | Tx4 | Tx5 | ... |`==

In the journal superblock (not to be confused with the main file system superblock), the journaling system records enough information to know which transactions have not yet been checkpointed, and thus reduces recovery time as well as enables re-use of the log in a circular fashion.
==在日志超级块（不要与主文件系统超级块混淆）中，日志系统记录了足够的信息，以了解哪些事务尚未被检查点，从而缩短了恢复时间，并实现了日志的循环重用。==

And thus we add another step to our basic protocol:
==因此，我们在基本协议中增加了另一个步骤：==

1. **Journal write:** Write the contents of the transaction (containing TxB and the contents of the update) to the log; wait for these writes to complete.
==1. **日志写入：** 将事务内容（包含 TxB 和更新内容）写入日志；等待这些写入完成。==

2. **Journal commit:** Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction is now **committed**.
==2. **日志提交：** 将事务提交块（包含 TxE）写入日志；等待写入完成；事务现在已**提交**。==

3. **Checkpoint:** Write the contents of the update to their final locations within the file system.
==3. **检查点：** 将更新内容写入文件系统中的最终位置。==

4. **Free:** Some time later, mark the transaction free in the journal by updating the journal superblock.
==4. **释放：** 一段时间后，通过更新日志超级块，将该事务在日志中标记为释放。==

Thus we have our final data journaling protocol.
==至此，我们得到了最终的数据日志协议。==

But there is still a problem: we are writing each data block to the disk **twice**, which is a heavy cost to pay, especially for something as rare as a system crash.
==但仍然存在一个问题：我们将每个数据块向磁盘写入了**两次**，这是一个沉重的代价，特别是对于像系统崩溃这样罕见的事情。==

Can you figure out a way to retain consistency without writing data twice?
==你能想出一种在不写入两次数据的情况下保持一致性的方法吗？==

**Metadata Journaling**
==**元数据日志**==

Although recovery is now fast (scanning the journal and replaying a few transactions as opposed to scanning the entire disk), normal operation of the file system is slower than we might desire.
==尽管现在的恢复速度很快（扫描日志并重放少量事务，而不是扫描整个磁盘），但文件系统的正常运行速度可能比我们预期的要慢。==

In particular, for each write to disk, we are now also writing to the journal first, thus doubling write traffic; this doubling is especially painful during sequential write workloads, which now will proceed at half the peak write bandwidth of the drive.
==特别是对于每次磁盘写入，我们现在还要先写入日志，从而使写入流量翻倍；这种翻倍在顺序写入工作负载中尤其痛苦，因为现在的写入速度只有驱动器峰值带宽的一半。==

Further, between writes to the journal and writes to the main file system, there is a costly seek, which adds noticeable overhead for some workloads.
==此外，在写入日志和写入主文件系统之间存在昂贵的寻道，这为某些工作负载增加了明显的开销。==

Because of the high cost of writing every data block to disk twice, people have tried a few different things in order to speed up performance.
==由于将每个数据块写入磁盘两次的成本很高，人们尝试了几种不同的方法来提高性能。==

For example, the mode of journaling we described above is often called **data journaling** (as in Linux ext3), as it journals all user data (in addition to the metadata of the file system).
==例如，我们上面描述的日志模式通常被称为**数据日志**（data journaling，如 Linux ext3 中），因为它记录了所有用户数据（以及文件系统的元数据）。==

A simpler (and more common) form of journaling is sometimes called **ordered journaling** (or just **metadata journaling**), and it is nearly the same, except that user data is **not** written to the journal.
==一种更简单（且更常见）的日志形式有时被称为**有序日志**（ordered journaling，或简称为**元数据日志** metadata journaling），它几乎是一样的，只是用户数据**不**写入日志。==

Thus, when performing the same update as above, the following information would be written to the journal:
==因此，在执行与上述相同的更新时，以下信息将被写入日志：==

`Journal: | TxB | I[v2] | B[v2] | TxE |`
==`日志： | TxB | I[v2] | B[v2] | TxE |`==

The data block $Db$, previously written to the log, would instead be written to the file system proper, avoiding the extra write; given that most I/O traffic to the disk is data, not writing data twice substantially reduces the I/O load of journaling.
==之前被写入日志的数据块 $Db$ 现在将直接写入文件系统本身，从而避免了额外的写入；鉴于磁盘的大部分 I/O 流量是数据，不写入两次数据可大幅减轻日志的 I/O 负载。==

The modification does raise an interesting question, though: when should we write data blocks to disk?
==不过，这种修改确实提出了一个有趣的问题：我们应该在什么时候将数据块写入磁盘？==

Let’s again consider our example append of a file to understand the problem better.
==让我们再次考虑追加文件的例子，以便更好地理解这个问题。==

The update consists of three blocks: $I[v2]$, $B[v2]$, and $Db$.
==更新由三个块组成：$I[v2]$、$B[v2]$ 和 $Db$。==

The first two are both metadata and will be logged and then checkpointed; the latter will only be written once to the file system.
==前两个都是元数据，将被记录日志并进行检查点；后者将只向文件系统写入一次。==

When should we write $Db$ to disk? Does it matter?
==我们应该在什么时候将 $Db$ 写入磁盘？这有关系吗？==

As it turns out, the ordering of the data write does matter for metadata-only journaling.
==事实证明，对于仅元数据日志，数据写入的顺序确实很重要。==

For example, what if we write $Db$ to disk **after** the transaction (containing $I[v2]$ and $B[v2]$) completes?
==例如，如果我们是在事务（包含 $I[v2]$ 和 $B[v2]$）完成后才将 $Db$ 写入磁盘，会发生什么？==

Unfortunately, this approach has a problem: the file system is consistent but $I[v2]$ may end up pointing to garbage data.
==不幸的是，这种方法有一个问题：文件系统是一致的，但 $I[v2]$ 最终可能会指向垃圾数据。==

Specifically, consider the case where $I[v2]$ and $B[v2]$ are written but $Db$ did not make it to disk.
==具体来说，考虑这样一种情况：$I[v2]$ 和 $B[v2]$ 已写入，但 $Db$ 未能写入磁盘。==

The file system will then try to recover.
==文件系统随后将尝试恢复。==

Because $Db$ is **not** in the log, the file system will replay writes to $I[v2]$ and $B[v2]$, and produce a consistent file system (from the perspective of file-system metadata).
==因为 $Db$ **不在**日志中，文件系统将重放对 $I[v2]$ 和 $B[v2]$ 的写入，并产生一个一致的文件系统（从文件系统元数据的角度来看）。==

However, $I[v2]$ will be pointing to garbage data, i.e., at whatever was in the slot where $Db$ was headed.
==然而，$I[v2]$ 将指向垃圾数据，即指向 $Db$ 原本要存放的位置中的任何内容。==

To ensure this situation does not arise, some file systems (e.g., Linux ext3) write data blocks (of regular files) to the disk **first**, before related metadata is written to disk.
==为了确保不出现这种情况，一些文件系统（例如 Linux ext3）会**首先**将（普通文件的）数据块写入磁盘，然后再将相关的元数据写入磁盘。==

Specifically, the protocol is as follows:
==具体来说，协议如下：==

1. **Data write:** Write data to final location; wait for completion (the wait is optional; see below for details).
==1. **数据写入：** 将数据写入最终位置；等待完成（等待是可选的；详见下文）。==

2. **Journal metadata write:** Write the begin block and metadata to the log; wait for writes to complete.
==2. **日志元数据写入：** 将开始块和元数据写入日志；等待写入完成。==

3. **Journal commit:** Write the transaction commit block (containing TxE) to the log; wait for the write to complete; the transaction (including data) is now **committed**.
==3. **日志提交：** 将事务提交块（包含 TxE）写入日志；等待写入完成；此时事务（包括数据）已**提交**。==

4. **Checkpoint metadata:** Write the contents of the metadata update to their final locations within the file system.
==4. **元数据检查点：** 将元数据更新内容写入文件系统中的最终位置。==

5. **Free:** Later, mark the transaction free in journal superblock.
==5. **释放：** 稍后，在日志超级块中将事务标记为释放。==

By forcing the data write first, a file system can guarantee that a pointer will never point to garbage.
==通过强制首先写入数据，文件系统可以保证指针永远不会指向垃圾。==

Indeed, this rule of “write the pointed-to object before the object that points to it” is at the core of crash consistency, and is exploited even further by other crash consistency schemes [GP94] (see below for details).
==事实上，这种“在指向某个对象的对象之前写入被指向的对象”的规则是崩溃一致性的核心，并被其他崩溃一致性方案 [GP94] 进一步利用（详见下文）。==

In most systems, metadata journaling (akin to ordered journaling of ext3) is more popular than full data journaling.
==在大多数系统中，元数据日志（类似于 ext3 的有序日志）比完整数据日志更受欢迎。==

For example, Windows NTFS and SGI’s XFS both use some form of metadata journaling.
==例如，Windows NTFS 和 SGI 的 XFS 都使用某种形式的元数据日志。==

Linux ext3 gives you the option of choosing either data, ordered, or unordered modes (in unordered mode, data can be written at any time).
==Linux ext3 允许你选择数据模式、有序模式或无序模式（在无序模式下，数据可以在任何时间写入）。==

All of these modes keep metadata consistent; they vary in their semantics for data.
==所有这些模式都能保持元数据一致；它们在数据的语义上有所不同。==

Finally, note that forcing the data write to complete (Step 1) before issuing writes to the journal (Step 2) is not required for correctness, as indicated in the protocol above.
==最后，请注意，如上述协议所示，在向日志发出写入（步骤 2）之前强制完成数据写入（步骤 1）并不是正确性所必需的。==

Specifically, it would be fine to concurrently issue writes to data, the transaction-begin block, and journaled metadata; the only real requirement is that Steps 1 and 2 complete before the issuing of the journal commit block (Step 3).
==具体而言，同时发出对数据、事务开始块和日志元数据的写入是可以的；唯一真正的要求是步骤 1 和 2 在发出日志提交块（步骤 3）之前完成。==

**Tricky Case: Block Reuse**
==**棘手案例：块重用**==

There are some interesting corner cases that make journaling more tricky, and thus are worth discussing.
==有一些有趣的边缘情况使日志变得更加复杂，因此值得讨论。==

A number of them revolve around block reuse; as Stephen Tweedie (one of the main forces behind ext3) said:
==其中许多情况围绕着块重用展开；正如 Stephen Tweedie（ext3 背后的主要推动力之一）所说：==

“What’s the hideous part of the entire system? ... It’s deleting files. Everything to do with delete is hairy. Everything to do with delete... you have nightmares around what happens if blocks get deleted and then reallocated.” [T00]
==“整个系统最可怕的部分是什么？……是删除文件。所有与删除有关的事情都很棘手。所有与删除有关的事情……如果你做噩梦，梦见的准是如果块被删除然后又重新分配会发生什么。”[T00]==

The particular example Tweedie gives is as follows.
==Tweedie 给出的具体例子如下。==

Suppose you are using some form of metadata journaling (and thus data blocks for files are **not** journaled).
==假设你正在使用某种形式的元数据日志（因此文件的数据块**不**记录日志）。==

Let’s say you have a directory called `foo`.
==假设你有一个名为 `foo` 的目录。==

The user adds an entry to `foo` (say by creating a file), and thus the contents of `foo` (because directories are considered metadata) are written to the log; assume the location of the `foo` directory data is block 1000.
==用户向 `foo` 中添加了一个条目（例如通过创建文件），因此 `foo` 的内容（因为目录被视为元数据）被写入日志；假设 `foo` 目录数据的位置是块 1000。==

The log thus contains something like this:
==因此，日志中包含类似这样的内容：==

`Journal: | TxB id=1 I[foo] ptr:1000 | D[foo] [final addr:1000] | TxE id=1 |`
==`日志： | TxB id=1 I[foo] ptr:1000 | D[foo] [最终地址:1000] | TxE id=1 |`==

At this point, the user deletes everything in the directory and the directory itself, freeing up block 1000 for reuse.
==此时，用户删除了目录中的所有内容以及目录本身，释放了块 1000 以供重用。==

Finally, the user creates a new file (say `bar`), which ends up reusing the same block (1000) that used to belong to `foo`.
==最后，用户创建了一个新文件（比如 `bar`），它最终重用了曾经属于 `foo` 的同一个块 (1000)。==

The inode of `bar` is committed to disk, as is its data; note, however, because metadata journaling is in use, only the inode of `bar` is committed to the journal; the newly-written data in block 1000 in the file `bar` is **not** journaled.
==`bar` 的 inode 及其数据都已提交到磁盘；但请注意，由于使用了元数据日志，只有 `bar` 的 inode 被提交到了日志；文件 `bar` 中块 1000 的新写入数据**没有**记录日志。==

`Journal: | TxB id=1 ... | D[foo] ... | TxE id=1 | TxB id=2 I[bar] ptr:1000 | TxE id=2 |`
==`日志： | TxB id=1 ... | D[foo] ... | TxE id=1 | TxB id=2 I[bar] ptr:1000 | TxE id=2 |`==

Now assume a crash occurs and all of this information is still in the log.
==现在假设发生了崩溃，而所有这些信息仍保存在日志中。==

During replay, the recovery process simply replays everything in the log, including the write of directory data in block 1000; the replay thus overwrites the user data of current file `bar` with old directory contents!
==在重放期间，恢复过程只需重放日志中的所有内容，包括块 1000 中目录数据的写入；因此，重放操作会用旧的目录内容覆盖当前文件 `bar` 的用户数据！==

Clearly this is not a correct recovery action, and certainly it will be a surprise to the user when reading the file `bar`.
==显然这不是正确的恢复操作，而且用户在读取文件 `bar` 时肯定会大吃一惊。==

There are a number of solutions to this problem.
==针对这个问题有多种解决方案。==

One could, for example, never reuse blocks until the delete of said blocks is checkpointed out of the journal.
==例如，可以在该块的删除操作从日志中检查点清除之前，永远不重用该块。==

What Linux ext3 does instead is to add a new type of record to the journal, known as a **revoke** record.
==Linux ext3 采取的方法是向日志添加一种新类型的记录，称为**撤销**（revoke）记录。==

In the case above, deleting the directory would cause a revoke record to be written to the journal.
==在上述情况下，删除目录会导致向日志写入一条撤销记录。==

When replaying the journal, the system first scans for such revoke records; any such revoked data is never replayed, thus avoiding the problem mentioned above.
==在重放日志时，系统首先扫描此类撤销记录；任何此类撤销的数据都不会被重写，从而避免了上述问题。==

**Wrapping Up Journaling: A Timeline**
==**总结日志：时间线**==

Before ending our discussion of journaling, we summarize the protocols we have discussed with timelines depicting each of them.
==在结束对日志的讨论之前，我们用描绘每种协议的时间线来总结我们讨论过的协议。==

Figure 42.1 shows the protocol when journaling data and metadata, whereas Figure 42.2 shows the protocol when journaling only metadata.
==图 42.1 显示了同时记录数据和元数据日志时的协议，而图 42.2 显示了仅记录元数据日志时的协议。==

In each figure, time increases in the downward direction, and each row in the figure shows the logical time that a write can be issued or might complete.
==在每张图中，时间按向下方向递增，图中的每一行显示了写入可能发出或可能完成的逻辑时间。==

For example, in the data journaling protocol (Figure 42.1), the writes of the transaction begin block (TxB) and the contents of the transaction can logically be issued at the same time, and thus can be completed in any order; however, the write to the transaction end block (TxE) must not be issued until said previous writes complete.
==例如，在数据日志协议（图 42.1）中，事务开始块 (TxB) 和事务内容的写入可以在逻辑上同时发出，因此可以以任何顺序完成；然而，在上述先前写入完成之前，不得发出事务结束块 (TxE) 的写入。==

Similarly, the checkpointing writes to data and metadata blocks cannot begin until the transaction end block has committed.
==同样，在事务结束块提交之前，不能开始对数据和元数据块的检查点写入。==

Horizontal dashed lines show where write-ordering requirements must be obeyed.
==水平虚线表示必须遵守写入顺序要求的地方。==

A similar timeline is shown for the metadata journaling protocol.
==元数据日志协议也显示了类似的时间线。==

Figure 42.1: Data Journaling Timeline
==图 42.1：数据日志时间线==

Journal | File System
==日志 | 文件系统==

TxB | Contents | TxE | Metadata | Data
==TxB | 内容 | TxE | 元数据 | 数据==

(metadata) (data)
==(元数据) (数据)==

issue | issue | issue
==发出 | 发出 | 发出==

complete | complete | complete
==完成 | 完成 | 完成==

----------------------------------
----------------------------------

issue
==发出==

complete
==完成==

----------------------------------
----------------------------------

issue | issue
==发出 | 发出==

complete | complete
==完成 | 完成==




==### 第 42 章：崩溃一致性（续）==

Figure 42.2: Metadata Journaling Timeline
==图 42.2：元数据日志时间线==

that the data write can logically be issued at the same time as the writes to the transaction begin and the contents of the journal; however, it must be issued and complete before the transaction end has been issued.
==数据写入在逻辑上可以与事务开始及日志内容写入同时发布；但是，它必须在事务结束发布之前完成发布并执行完毕。==

Finally, note that the time of completion marked for each write in the timelines is arbitrary.
==最后，请注意，时间线中标记的每次写入的完成时间是任意的。==

In a real system, completion time is determined by the I/O subsystem, which may reorder writes to improve performance.
==在实际系统中，完成时间由 I/O 子系统决定，子系统可能会为了提高性能而对写入进行重排序。==

The only guarantees about ordering that we have are those that must be enforced for protocol correctness (and are shown via the horizontal dashed lines in the figures).
==我们拥有的关于顺序的唯一保证是那些为了协议正确性而必须强制执行的保证（并在图中通过水平虚线显示）。==

#### 42.4 Solution #3: Other Approaches
==#### 42.4 解决方案 #3：其他方法==

We’ve thus far described two options in keeping file system metadata consistent: a lazy approach based on `fsck`, and a more active approach known as journaling.
==到目前为止，我们已经描述了保持文件系统元数据一致性的两种选择：一种是基于 `fsck` 的惰性方法，另一种是被称为日志记录（journaling）的更主动的方法。==

However, these are not the only two approaches.
==然而，这两者并非仅有的方法。==

One such approach, known as **Soft Updates** [GP94], was introduced by Ganger and Patt.
==其中一种被称为 **软更新**（Soft Updates）[GP94] 的方法，是由 Ganger 和 Patt 提出的。==

This approach carefully orders all writes to the file system to ensure that the on-disk structures are never left in an inconsistent state.
==这种方法仔细地安排所有写入文件系统的顺序，以确保磁盘上的结构永远不会处于不一致的状态。==

For example, by writing a pointed-to data block to disk before the inode that points to it, we can ensure that the inode never points to garbage; similar rules can be derived for all the structures of the file system.
==例如，通过在指向数据块的 inode 之前先将该数据块写入磁盘，我们可以确保 inode 永远不会指向垃圾数据；对于文件系统的所有结构，都可以推导出类似的规则。==

Implementing **Soft Updates** can be a challenge, however; whereas the journaling layer described above can be implemented with relatively little knowledge of the exact file system structures, **Soft Updates** requires intricate knowledge of each file system data structure and thus adds a fair amount of complexity to the system.
==然而，实现 **软更新** 可能是一个挑战；上述的日志层可以在对具体文件系统结构了解相对较少的情况下实现，而 **软更新** 则需要对每个文件系统数据结构有精细的了解，因此给系统增加了相当大的复杂性。==

Another approach is known as **copy-on-write** (yes, **COW**), and is used in a number of popular file systems, including Sun’s ZFS [B07].
==另一种方法被称为 **写时复制**（没错，就是 **COW**），并被用于许多流行的文件系统，包括 Sun 的 ZFS [B07]。==

This technique never overwrites files or directories in place; rather, it places new updates to previously unused locations on disk.
==这项技术从不原位覆盖文件或目录；相反，它将新的更新放在磁盘上之前未使用的位置。==

After a number of updates are completed, **COW** file systems flip the root structure of the file system to include pointers to the newly updated structures.
==在完成一定数量的更新后，**COW** 文件系统会翻转文件系统的根结构，使其包含指向新更新结构的指针。==

Doing so makes keeping the file system consistent straightforward.
==这样做使得保持文件系统一致性变得简单直接。==

We’ll be learning more about this technique when we discuss the log-structured file system (LFS) in a future chapter; LFS is an early example of a **COW**.
==在未来的章节中讨论日志结构文件系统（LFS）时，我们将学到更多关于这项技术的知识；LFS 是 **COW** 的一个早期范例。==

Another approach is one we just developed here at Wisconsin.
==另一种方法是我们刚刚在威斯康星大学开发的。==

In this technique, entitled **backpointer-based consistency** (or **BBC**), no ordering is enforced between writes.
==在这项名为 **基于后向指针的一致性**（或 **BBC**）的技术中，写入之间不强制执行任何顺序。==

To achieve consistency, an additional **back pointer** is added to every block in the system; for example, each data block has a reference to the inode to which it belongs.
==为了实现一致性，系统中的每个块都增加了一个额外的 **后向指针**；例如，每个数据块都有一个指向它所属 inode 的引用。==

When accessing a file, the file system can determine if the file is consistent by checking if the forward pointer (e.g., the address in the inode or direct block) points to a block that refers back to it.
==访问文件时，文件系统可以通过检查前向指针（例如 inode 或直接块中的地址）是否指向一个引用回它的块，来确定文件是否一致。==

If so, everything must have safely reached disk and thus the file is consistent; if not, the file is inconsistent, and an error is returned.
==如果是这样，那么所有内容肯定都已安全到达磁盘，因此文件是一致的；如果不是，文件就是不一致的，并返回错误。==

By adding back pointers to the file system, a new form of lazy crash consistency can be attained [C+12].
==通过向文件系统添加后向指针，可以实现一种新型的惰性崩溃一致性 [C+12]。==

Finally, we also have explored techniques to reduce the number of times a journal protocol has to wait for disk writes to complete.
==最后，我们还探索了一些技术，用以减少日志协议必须等待磁盘写入完成的次数。==

Entitled **optimistic crash consistency** [C+13], this new approach issues as many writes to disk as possible by using a generalized form of the **transaction checksum** [P+05], and includes a few other techniques to detect inconsistencies should they arise.
==这种被称为 **乐观崩溃一致性** [C+13] 的新方法，通过使用 **事务校验和** [P+05] 的通用形式，尽可能多地向磁盘发布写入，并包含其他几种技术来检测可能出现的不一致。==

For some workloads, these optimistic techniques can improve performance by an order of magnitude.
==对于某些工作负载，这些乐观技术可以将性能提高一个数量级。==

However, to truly function well, a slightly different disk interface is required [C+13].
==然而，为了真正发挥作用，需要一种略有不同的磁盘接口 [C+13]。==

==### 第 43 章：日志结构文件系统 (Log-structured File Systems)==

In the early 90’s, a group at Berkeley led by Professor John Ousterhout and graduate student Mendel Rosenblum developed a new file system known as the **log-structured file system** [RO91].
==20 世纪 90 年代初，伯克利大学由 John Ousterhout 教授和研究生 Mendel Rosenblum 领导的一个小组开发了一种新型文件系统，称为 **日志结构文件系统** [RO91]。==

Their motivation to do so was based on the following observations:
==他们这样做的动机基于以下观察：==

**System memories are growing:** As memory gets bigger, more data can be cached in memory.
==**系统内存正在增长：** 随着内存变大，更多数据可以缓存在内存中。==

As more data is cached, disk traffic increasingly consists of writes, as reads are serviced by the cache.
==随着缓存的数据增多，磁盘流量越来越多地由写入组成，因为读取由缓存提供服务。==

Thus, file system performance is largely determined by its write performance.
==因此，文件系统的性能在很大程度上取决于其写入性能。==

**There is a large gap between random I/O performance and sequential I/O performance:** Hard-drive transfer bandwidth has increased a great deal over the years [P98]; as more bits are packed into the surface of a drive, the bandwidth when accessing said bits increases.
==**随机 I/O 性能与顺序 I/O 性能之间存在巨大差距：** 多年来，硬盘的传输带宽大幅增加 [P98]；随着更多位被封装到驱动器表面，访问这些位时的带宽也会增加。==

Seek and rotational delay costs, however, have decreased slowly; it is challenging to make cheap and small motors spin the platters faster or move the disk arm more quickly.
==然而，寻道和旋转延迟成本下降缓慢；让廉价且微小的电机使盘片转动得更快或使磁盘臂移动得更迅速极具挑战。==

Thus, if you are able to use disks in a sequential manner, you gain a sizeable performance advantage over approaches that cause seeks and rotations.
==因此，如果你能够以顺序方式使用磁盘，那么与导致寻道和旋转的方法相比，你将获得显著的性能优势。==

**Existing file systems perform poorly on many common workloads:** For example, FFS [MJLF84] would perform a large number of writes to create a new file of size one block: one for a new inode, one to update the inode bitmap, one to the directory data block that the file is in, one to the directory inode to update it, one to the new data block that is a part of the new file, and one to the data bitmap to mark the data block as allocated.
==**现有文件系统在许多常见工作负载下表现不佳：** 例如，FFS [MJLF84] 在创建一个大小为一个块的新文件时，会执行大量写入：一个用于新 inode，一个用于更新 inode 位图，一个写入该文件所在的目录数据块，一个写入目录 inode 以更新它，一个写入作为新文件一部分的新数据块，还有一个写入数据位图以将数据块标记为已分配。==

Thus, although FFS places all of these blocks within the same block group, FFS incurs many short seeks and subsequent rotational delays and thus performance falls far short of peak sequential bandwidth.
==因此，尽管 FFS 将所有这些块放在同一个块组内，但 FFS 仍会产生许多短寻道和随后的旋转延迟，因此性能远低于峰值顺序带宽。==

**File systems are not RAID-aware:** For example, both RAID-4 and RAID-5 have the **small-write problem** where a logical write to a single block causes 4 physical I/Os to take place.
==**文件系统不具备 RAID 感知能力：** 例如，RAID-4 和 RAID-5 都有 **小写问题**，即对单个块的逻辑写入会导致 4 次物理 I/O。==

Existing file systems do not try to avoid this worst-case RAID writing behavior.
==现有文件系统并不试图避免这种最糟糕的 RAID 写入行为。==

#### 43.1 Writing To Disk Sequentially
==#### 43.1 顺序写入磁盘==

We thus have our first challenge: how do we transform all updates to file-system state into a series of sequential writes to disk?
==因此，我们面临第一个挑战：如何将对文件系统状态的所有更新转化为磁盘上的一系列顺序写入？==

To understand this better, let’s use a simple example.
==为了更好地理解这一点，让我们使用一个简单的例子。==

Imagine we are writing a data block $D$ to a file.
==假设我们要将一个数据块 $D$ 写入文件。==

Writing the data block to disk might result in the following on-disk layout, with $D$ written at disk address $A0$:
==将该数据块写入磁盘可能会导致以下磁盘布局，其中 $D$ 写入磁盘地址 $A0$：==

However, when a user writes a data block, it is not only data that gets written to disk; there is also other **metadata** that needs to be updated.
==然而，当用户写入一个数据块时，不仅是数据被写入磁盘；还有其他 **元数据** 需要更新。==

In this case, let’s also write the **inode** ($I$) of the file to disk, and have it point to the data block $D$.
==在这种情况下，让我们也将文件的 **inode** ($I$) 写入磁盘，并使其指向数据块 $D$。==

This basic idea, of simply writing all updates (such as data blocks, inodes, etc.) to the disk sequentially, sits at the heart of LFS.
==这种简单地将所有更新（如数据块、inode 等）按顺序写入磁盘的基本思想，是 LFS 的核心。==

#### 43.2 Writing Sequentially And Effectively
==#### 43.2 有效且顺序地写入==

To achieve this end, LFS uses an ancient technique known as **write buffering**.
==为了达到这个目的，LFS 使用了一种古老的技术，称为 **写入缓冲**。==

Before writing to the disk, LFS keeps track of updates in memory; when it has received a sufficient number of updates, it writes them to disk all at once, thus ensuring efficient use of the disk.
==在写入磁盘之前，LFS 在内存中跟踪更新；当收到足够数量的更新时，它会一次性将它们写入磁盘，从而确保磁盘的高效利用。==

The large chunk of updates LFS writes at one time is referred to by the name of a **segment**.
==LFS 一次写入的大块更新被称为 **段**（segment）。==

#### 43.3 How Much To Buffer?
==#### 43.3 需要缓冲多少？==

To obtain a concrete answer, let’s assume we are writing out $D$ MB.
==为了得到一个具体的答案，假设我们要写出 $D$ MB 的数据。==

The time to write out this chunk of data ($T_{write}$) is the positioning time $T_{position}$ plus the time to transfer $D$ ($\frac{D}{R_{peak}}$), or:
==写出这块数据的时间（$T_{write}$）是定位时间 $T_{position}$ 加上传输 $D$ 所需的时间（$\frac{D}{R_{peak}}$），即：==

$T_{write} = T_{position} + \frac{D}{R_{peak}}$ (43.1)

And thus the effective rate of writing ($R_{effective}$), which is just the amount of data written divided by the total time to write it, is:
==因此，有效写入速率（$R_{effective}$）即写入的数据量除以写入的总时间，为：==

$R_{effective} = \frac{D}{T_{write}} = \frac{D}{T_{position} + \frac{D}{R_{peak}}}$ (43.2)

In mathematical form, this means we want $R_{effective} = F \times R_{peak}$.
==以数学形式表示，这意味着我们希望 $R_{effective} = F \times R_{peak}$。==

$D = \frac{F}{1 - F} \times R_{peak} \times T_{position}$ (43.6)

Let’s do an example, with a disk with a positioning time of 10 milliseconds and peak transfer rate of 100 MB/s; assume we want an effective bandwidth of 90% of peak ($F = 0.9$).
==让我们举个例子，假设磁盘定位时间为 10 毫秒，峰值传输速率为 100 MB/s；假设我们想要达到峰值 90% 的有效带宽（$F = 0.9$）。==

In this case, $D = \frac{0.9}{0.1} \times 100\text{ MB/s} \times 0.01\text{ seconds} = 9\text{ MB}$.
==在这种情况下，$D = \frac{0.9}{0.1} \times 100\text{ MB/s} \times 0.01\text{ 秒} = 9\text{ MB}$。==

#### 43.4 Problem: Finding Inodes
==#### 43.4 问题：查找 Inode==

In LFS, life is more difficult. Why? Well, we’ve managed to scatter the inodes all throughout the disk!
==在 LFS 中，情况变得更加困难。为什么呢？因为我们设法将 inode 散布在整个磁盘上！==

Worse, we never overwrite in place, and thus the latest version of an inode (i.e., the one we want) keeps moving.
==更糟糕的是，我们从不原位覆盖，因此 inode 的最新版本（即我们想要的版本）一直在移动位置。==

#### 43.5 Solution Through Indirection: The Inode Map
==#### 43.5 通过间接层解决：Inode 映射表==

To remedy this, the designers of LFS introduced a level of indirection between inode numbers and the inodes through a data structure called the **inode map** (**imap**).
==为了补救这一点，LFS 的设计者通过一种名为 **inode 映射表**（**imap**）的数据结构，在 inode 编号和 inode 之间引入了一个间接层。==

The **imap** is a structure that takes an inode number as input and produces the disk address of the most recent version of the inode.
==**imap** 是一种将 inode 编号作为输入并产生该 inode 最新版本磁盘地址的结构。==

#### 43.6 Completing The Solution: The Checkpoint Region
==#### 43.6 完善方案：检查点区域==

LFS has just such a fixed place on disk for this, known as the **checkpoint region** (**CR**).
==LFS 在磁盘上有一个固定的位置来实现这一点，被称为 **检查点区域**（**CR**）。==

The **checkpoint region** contains pointers to (i.e., addresses of) the latest pieces of the inode map, and thus the inode map pieces can be found by reading the CR first.
==**检查点区域** 包含指向（即地址）inode 映射表最新部分的指针，因此通过首先读取 CR 就可以找到 inode 映射表的分块。==

#### 43.9 A New Problem: Garbage Collection
==#### 43.9 新问题：垃圾回收==

LFS leaves old versions of file structures scattered throughout the disk. We (rather unceremoniously) call these old versions **garbage**.
==LFS 将文件结构的旧版本散布在整个磁盘上。我们（相当不客气地）将这些旧版本称为 **垃圾**（garbage）。==

However, LFS instead keeps only the latest live version of a file; thus (in the background), LFS must periodically find these old dead versions of file data, inodes, and other structures, and **clean** them.
==然而，LFS 相反只保留文件的最新活动版本；因此（在后台），LFS 必须定期查找这些过时的文件数据、inode 和其他结构的旧版本，并 **清理** 它们。==

The LFS cleaner works on a segment-by-segment basis, thus clearing up large chunks of space for subsequent writing.
==LFS 清理器以段为单位进行工作，从而为后续写入腾出大块空间。==

#### 43.12 Crash Recovery And The Log
==#### 43.12 崩溃恢复与日志==

To ensure that the CR update happens atomically, LFS actually keeps two CRs, one at either end of the disk, and writes to them alternately.
==为了确保 CR 更新原子化地发生，LFS 实际上保留了两个 CR，分别位于磁盘的两端，并轮流对它们进行写入。==

If the system crashes during a CR update, LFS can detect this by seeing an inconsistent pair of timestamps.
==如果系统在 CR 更新期间崩溃，LFS 可以通过看到不一致的时间戳对来检测到这一点。==

LFS will always choose to use the most recent CR that has consistent timestamps, and thus consistent update of the CR is achieved.
==LFS 将始终选择使用具有一致时间戳的最新 CR，从而实现 CR 的一致性更新。==




Compute the liveness again, and check if you are right with -c.
==重新计算活跃度，并使用 -c 检查你的结果是否正确。==

What is the main difference between writing a file all at once (as we do here) versus doing it one block at a time (as above)?
==一次性写入整个文件（如我们在此所做的）与一次写入一个块（如上所述）之间的主要区别是什么？==

What does this tell you about the importance of buffering updates in main memory as the real LFS does?
==关于像真实的 LFS 那样在主内存中缓冲更新的重要性，这告诉了你什么？==

7. Let’s do another specific example.
==7. 让我们看另一个具体的例子。==

First, run the following: `./lfs.py -L c,/foo:w,/foo,0,1`.
==首先，运行以下命令：`./lfs.py -L c,/foo:w,/foo,0,1`。==

What does this set of commands do?
==这组命令的作用是什么？==

Now, run `./lfs.py -L c,/foo:w,/foo,7,1`.
==现在，运行 `./lfs.py -L c,/foo:w,/foo,7,1`。==

What does this set of commands do?
==这组命令的作用是什么？==

How are the two different?
==这两者有何不同？==

What can you tell about the size field in the inode from these two sets of commands?
==从这两组命令中，你能发现 inode 中的 size（大小）字段有什么特点？==

8. Now let’s look explicitly at file creation versus directory creation.
==8. 现在让我们明确地对比一下文件创建与目录创建。==

Run simulations `./lfs.py -L c,/foo` and `./lfs.py -L d,/foo` to create a file and then a directory.
==运行模拟命令 `./lfs.py -L c,/foo` 和 `./lfs.py -L d,/foo` 来分别创建一个文件和一个目录。==

What is similar about these runs, and what is different?
==这些运行过程有哪些相似之处，又有哪些不同之处？==

9. The LFS simulator supports hard links as well.
==9. LFS 模拟器也支持硬链接。==

Run the following to study how they work: `./lfs.py -L c,/foo:l,/foo,/bar:l,/foo,/goo -o -i`.
==运行以下命令来研究它们是如何工作的：`./lfs.py -L c,/foo:l,/foo,/bar:l,/foo,/goo -o -i`。==

What blocks are written out when a hard link is created?
==创建硬链接时会写出哪些块？==

How is this similar to just creating a new file, and how is it different?
==这与仅创建一个新文件有何相似之处，又有何不同？==

How does the reference count field change as links are created?
==随着链接的创建，引用计数（reference count）字段是如何变化的？==

10. LFS makes many different policy decisions.
==10. LFS 会做出许多不同的策略决策。==

We do not explore many of them here – perhaps something left for the future – but here is a simple one we do explore: the choice of inode number.
==我们在这里不会探讨其中的大部分策略——或许留给以后——但这里有一个我们将要探讨的简单策略：inode 编号的选择。==

First, run `./lfs.py -p c100 -n 10 -o -a s` to show the usual behavior with the "sequential" allocation policy, which tries to use free inode numbers nearest to zero.
==首先，运行 `./lfs.py -p c100 -n 10 -o -a s` 以展示“顺序”分配策略的通常行为，该策略尝试使用最接近零的空闲 inode 编号。==

Then, change to a "random" policy by running `./lfs.py -p c100 -n 10 -o -a r` (the -p c100 flag ensures 100 percent of the random operations are file creations).
==然后，通过运行 `./lfs.py -p c100 -n 10 -o -a r` 切换到“随机”策略（-p c100 标志确保 100% 的随机操作都是文件创建）。==

What on-disk differences does a random policy versus a sequential policy result in?
==随机策略与顺序策略相比，会导致磁盘上出现哪些差异？==

What does this say about the importance of choosing inode numbers in a real LFS?
==关于在真实的 LFS 中选择 inode 编号的重要性，这说明了什么？==

11. One last thing we’ve been assuming is that the LFS simulator always updates the checkpoint region after each update.
==11. 我们一直假设的最后一件事是 LFS 模拟器在每次更新后都会更新检查点区域（checkpoint region）。==

In the real LFS, that isn’t the case: it is updated periodically to avoid long seeks.
==在真实的 LFS 中并非如此：它是定期更新的，以避免长时间的寻道。==

Run `./lfs.py -N -i -o -s 1000` to see some operations and the intermediate and final states of the file system when the checkpoint region isn’t forced to disk.
==运行 `./lfs.py -N -i -o -s 1000` 来观察在不强制将检查点区域写入磁盘时，文件系统的一些操作以及中间和最终状态。==

What would happen if the checkpoint region is never updated?
==如果检查点区域永远不更新会发生什么？==

What if it is updated periodically?
==如果是定期更新又会怎样？==

Could you figure out how to recover the file system to the latest state by rolling forward in the log?
==你能否想出如何通过在日志中“向前滚动”（rolling forward）来将文件系统恢复到最新状态？==

**44 Flash-based SSDs**
==**44 基于闪存的固态硬盘 (SSDs)**==

After decades of hard-disk drive dominance, a new form of persistent storage device has recently gained significance in the world.
==在硬盘驱动器统治了数十年之后，一种新型的持久化存储设备最近在全球范围内变得举足轻重。==

Generically referred to as **solid-state storage**, such devices have no mechanical or moving parts like hard drives; rather, they are simply built out of transistors, much like memory and processors.
==这类设备通称为**固态存储**，它们不像硬盘驱动器那样拥有机械或移动部件；相反，它们仅由晶体管构建而成，非常类似于内存和处理器。==

However, unlike typical random-access memory (e.g., DRAM), such a solid-state storage device (a.k.a., an **SSD**) retains information despite power loss, and thus is an ideal candidate for use in persistent storage of data.
==然而，与典型的随机存取存储器（如 DRAM）不同，这种固态存储设备（又称 **SSD**）在断电后仍能保留信息，因此是用于数据持久化存储的理想选择。==

The technology we’ll focus on is known as **flash** (more specifically, **NAND-based flash**), which was created by Fujio Masuoka in the 1980s [M+14].
==我们将重点关注的技术被称为**闪存**（更具体地说，是**基于 NAND 的闪存**），它是由舛冈富士雄（Fujio Masuoka）在 20 世纪 80 年代发明的 [M+14]。==

Flash, as we’ll see, has some unique properties.
==正如我们将看到的，闪存具有一些独特的属性。==

For example, to write to a given chunk of it (i.e., a **flash page**), you first have to erase a bigger chunk (i.e., a **flash block**), which can be quite expensive.
==例如，要写入其中的一个特定块（即**闪存页**），你必须先擦除一个更大的块（即**闪存块**），这可能代价非常高。==

In addition, writing too often to a page will cause it to **wear out**.
==此外，过于频繁地向某个页写入会导致其**磨损**。==

These two properties make construction of a flash-based SSD an interesting challenge:
==这两个属性使得构建基于闪存的 SSD 成为一个有趣的挑战：==

**CRUX: HOW TO BUILD A FLASH-BASED SSD**
==**关键问题：如何构建基于闪存的 SSD**==

How can we build a flash-based SSD?
==我们如何构建一个基于闪存的 SSD？==

How can we handle the expensive nature of erasing?
==我们如何处理擦除操作的高昂代价？==

How can we build a device that lasts a long time, given that repeated overwrite will wear the device out?
==考虑到重复覆写会磨损设备，我们如何构建一个寿命长久的设备？==

Will the march of progress in technology ever cease?
==技术的进步步伐会停止吗？==

Or cease to amaze?
==或者停止带给人惊喜？==

**44.1 Storing a Single Bit**
==**44.1 存储单个位**==

Flash chips are designed to store one or more bits in a single transistor; the level of charge trapped within the transistor is mapped to a binary value.
==闪存芯片设计用于在单个晶体管中存储一个或多个位；陷在晶体管内的电荷水平被映射为一个二进制值。==

In a **single-level cell (SLC)** flash, only a single bit is stored within a transistor (i.e., 1 or 0); with a **multi-level cell (MLC)** flash, two bits are encoded into different levels of charge, e.g., 00, 01, 10, and 11 are represented by low, somewhat low, somewhat high, and high levels.
==在**单层单元 (SLC)** 闪存中，晶体管内仅存储一个位（即 1 或 0）；而在**多层单元 (MLC)** 闪存中，两个位被编码为不同的电荷水平，例如，00、01、10 和 11 分别由低、较低、较高和高水平表示。==

There is even **triple-level cell (TLC)** flash, which encodes 3 bits per cell.
==甚至还有**三层单元 (TLC)** 闪存，每个单元编码 3 个位。==

Overall, SLC chips achieve higher performance and are more expensive.
==总的来说，SLC 芯片性能更高，但也更昂贵。==

**TIP: BE CAREFUL WITH TERMINOLOGY**
==**提示：注意术语的使用**==

You may have noticed that some terms we have used many times before (blocks, pages) are being used within the context of a flash, but in slightly different ways than before.
==你可能已经注意到，我们之前多次使用过的一些术语（块、页）在闪存的语境中也在使用，但其含义与之前略有不同。==

New terms are not created to make your life harder (although they may be doing just that), but arise because there is no central authority where terminology decisions are made.
==创建新术语并不是为了让你的生活变得更艰难（尽管它们确实起到了这种作用），而是因为没有一个中央机构来进行术语决策。==

What is a block to you may be a page to someone else, and vice versa, depending on the context.
==对你来说是一个“块”的东西，对别人来说可能是一个“页”，反之亦然，这取决于具体的上下文。==

Your job is simple: to know the appropriate terms within each domain, and use them such that people well-versed in the discipline can understand what you are talking about.
==你的任务很简单：了解每个领域中的适当术语，并正确使用它们，以便该领域的专业人士能够理解你在说什么。==

It’s one of those times where the only solution is simple but sometimes painful: use your memory.
==在这些情况下，唯一的解决办法既简单但有时又令人痛苦：动用你的记忆力。==

Of course, there are many details as to exactly how such bit-level storage operates, down at the level of device physics.
==当然，关于这种位级存储究竟如何运作，在设备物理层面上还有许多细节。==

While beyond the scope of this book, you can read more about it on your own [J10].
==虽然这超出了本书的范围，但你可以自行阅读更多相关资料 [J10]。==

**44.2 From Bits to Banks/Planes**
==**44.2 从位到银行/平面**==

As they say in ancient Greece, storing a single bit (or a few) does not a storage system make.
==正如古希腊人所说，仅存储一个位（或几个位）并不能构成一个存储系统。==

Hence, flash chips are organized into **banks** or **planes** which consist of a large number of cells.
==因此，闪存芯片被组织成**银行 (banks)** 或**平面 (planes)**，它们由大量的单元组成。==

A bank is accessed in two different sized units: **blocks** (sometimes called **erase blocks**), which are typically of size 128 KB or 256 KB, and **pages**, which are a few KB in size (e.g., 4KB).
==访问银行时有两种不同大小的单位：**块**（有时称为**擦除块**），其大小通常为 128 KB 或 256 KB；以及**页**，其大小为几 KB（例如 4KB）。==

Within each bank there are a large number of blocks; within each block, there are a large number of pages.
==在每个银行内部有大量的块；在每个块内部，有大量的页。==

When thinking about flash, you must remember this new terminology, which is different than the blocks we refer to in disks and RAIDs and the pages we refer to in virtual memory.
==在思考闪存时，你必须记住这一套新术语，它与我们在磁盘和 RAID 中提到的“块”以及在虚拟内存中提到的“页”是不同的。==

Figure 44.1 shows an example of a flash plane with blocks and pages; there are three blocks, each containing four pages, in this simple example.
==图 44.1 显示了一个包含块和页的闪存平面示例；在这个简单的例子中，有三个块，每个块包含四个页。==

We’ll see below why we distinguish between blocks and pages; it turns out this distinction is critical for flash operations such as reading and writing, and even more so for the overall performance of the device.
==我们将在下文中看到为什么要区分块和页；事实证明，这种区分对于闪存的读写操作至关重要，对于设备的整体性能更是如此。==

The most important (and weird) thing you will learn is that to write to a page within a block, you first have to **erase the entire block**; this tricky detail makes building a flash-based SSD an interesting and worthwhile challenge, and the subject of the second-half of the chapter.
==你将学到的最重要（也是最奇怪）的一点是，要写入块中的某个页，你必须先**擦除整个块**；这个棘手的细节使得构建基于闪存的 SSD 成为一个有趣且值得挑战的任务，也是本章后半部分的主题。==

**44.3 Basic Flash Operations**
==**44.3 闪存基础操作**==

Given this flash organization, there are three low-level operations that a flash chip supports.
==考虑到这种闪存结构，闪存芯片支持三种底层操作。==

The **read** command is used to read a page from the flash; **erase** and **program** are used in tandem to write.
==**read**（读取）命令用于从闪存中读取一个页；**erase**（擦除）和 **program**（编程）则配合使用来完成写入操作。==

The details:
==详细信息如下：==

• **Read (a page)**: A client of the flash chip can read any page (e.g., 2KB or 4KB), simply by specifying the read command and appropriate page number to the device.
==• **读取（一个页）**：闪存芯片的客户端可以读取任何页（例如 2KB 或 4KB），只需向设备指定读取命令和相应的页号即可。==

This operation is typically quite fast, 10s of microseconds or so, regardless of location on the device, and (more or less) regardless of the location of the previous request (quite unlike a disk).
==无论在设备的什么位置，也（或多或少）无论上一个请求的位置在哪里（这与磁盘完全不同），此操作通常都非常快，大约在几十微秒左右。==

Being able to access any location uniformly quickly means the device is a **random access** device.
==能够统一且快速地访问任何位置，意味着该设备是一个**随机存取**设备。==

• **Erase (a block)**: Before writing to a *page* within a flash, the nature of the device requires that you first **erase** the entire **block** the page lies within.
==• **擦除（一个块）**：在向闪存中的*页*写入之前，由于设备的物理特性，要求你必须先**擦除**该页所在的整个**块**。==

Erase, importantly, destroys the contents of the block (by setting each bit to the value 1); therefore, you must be sure that any data you care about in the block has been copied elsewhere (to memory, or perhaps to another flash block) *before* executing the erase.
==重要的是，擦除会破坏块的内容（通过将每个位设置为 1）；因此，你必须确保在执行擦除*之前*，块中任何你关心的数据都已复制到其他地方（内存，或者可能是另一个闪存块）。==

The erase command is quite expensive, taking a few milliseconds to complete.
==擦除命令代价相当高，需要几毫秒才能完成。==

Once finished, the entire block is reset and each page is ready to be programmed.
==一旦完成，整个块就会重置，每个页都准备好进行编程。==

• **Program (a page)**: Once a block has been erased, the **program** command can be used to change some of the 1’s within a page to 0’s, and write the desired contents of a page to the flash.
==• **编程（一个页）**：一旦一个块被擦除，**program** 命令就可以用来将页内的某些 1 改为 0，并将所需的页内容写入闪存。==

Programming a page is less expensive than erasing a block, but more costly than reading a page, usually taking around 100s of microseconds on modern flash chips.
==对页进行编程的代价比擦除块要小，但比读取页要高，在现代闪存芯片上通常需要 100 微秒左右。==

One way to think about flash chips is that each page has a **state** associated with it.
==思考闪存芯片的一种方式是，每个页都关联有一个**状态**。==

Pages start in an `INVALID` state.
==页的初始状态为 `INVALID`（无效）。==

By erasing the block that a page resides within, you set the state of the page (and all pages within that block) to `ERASED`, which resets the content of each page in the block but also (importantly) makes them programmable.
==通过擦除页所在的块，你可以将该页（以及该块内的所有页）的状态设置为 `ERASED`（已擦除），这会重置块中每个页的内容，而且（重要的是）使它们变得可编程。==

When you program a page, its state changes to `VALID`, meaning its contents have been set and can be read.
==当你对一个页进行编程时，它的状态会变为 `VALID`（有效），这意味着它的内容已经设置好并且可以被读取。==

Reads do not affect these states (although you should only read from pages that have been programmed).
==读取操作不会影响这些状态（尽管你只能读取已经编程过的页）。==

Once a page has been programmed, the only way to change its contents is to erase the entire block within which the page resides.
==一旦一个页被编程，更改其内容的唯一方法就是擦除该页所在的整个块。==

Here is an example of states transition after various erase and program operations within a 4-page block:
==以下是在一个 4 页块内经过各种擦除和编程操作后的状态转换示例：==

`iiii` Initial: pages in block are invalid (i)
==`iiii` 初始状态：块中的页是无效的 (i)==

`Erase() -> EEEE` State of pages in block set to erased (E)
==`Erase() -> EEEE` 块中页的状态设置为已擦除 (E)==

`Program(0) -> VEEE` Program page 0; state set to valid (V)
==`Program(0) -> VEEE` 对第 0 页进行编程；状态设置为有效 (V)==

`Program(0) -> error` Cannot re-program page after programming
==`Program(0) -> error` 编程后无法再次对该页进行编程==

`Program(1) -> VVEE` Program page 1
==`Program(1) -> VVEE` 对第 1 页进行编程==

`Erase() -> EEEE` Contents erased; all pages programmable
==`Erase() -> EEEE` 内容已擦除；所有页均可编程==

**A Detailed Example**
==**一个详细的例子**==

Because the process of writing (i.e., erasing and programming) is so unusual, let’s go through a detailed example to make sure it makes sense.
==由于写入过程（即擦除和编程）非常特殊，让我们通过一个详细的例子来确保你理解了它。==

In this example, imagine we have the following four 8-bit pages, within a 4-page block (both unrealistically small sizes, but useful within this example); each page is `VALID` as each has been previously programmed.
==在这个例子中，假设我们在一个 4 页的块中有以下四个 8 位页（这两个尺寸在现实中都小得不切实际，但在本例中很有用）；每个页都是 `VALID`（有效）的，因为每个页之前都已被编程。==

Now say we wish to write to page 0, filling it with new contents.
==现在假设我们希望写入第 0 页，为其填充新内容。==

To write any page, we must first erase the entire block.
==要写入任何页，我们必须先擦除整个块。==

Let’s assume we do so, thus leaving the block in this state:
==假设我们执行了此操作，从而使块处于这种状态：==

Good news! We could now go ahead and program page 0, for example with the contents `00000011`, overwriting the old page 0 (contents `00011000`) as desired.
==好消息！我们现在可以继续对第 0 页进行编程，例如使用内容 `00000011`，按预期覆盖旧的第 0 页（内容 `00011000`）。==

After doing so, our block looks like this:
==完成之后，我们的块看起来像这样：==

And now the bad news: the previous contents of pages 1, 2, and 3 are all gone!
==现在是坏消息：第 1、2 和 3 页之前的内容全都消失了！==

Thus, before overwriting any page *within* a block, we must first move any data we care about to another location (e.g., memory, or elsewhere on the flash).
==因此，在覆盖块*内*的任何页之前，我们必须首先将我们关心的任何数据移动到另一个位置（例如，内存或闪存的其他地方）。==

The nature of erase will have a strong impact on how we design flash-based SSDs, as we’ll soon learn about.
==擦除的特性将对我们如何设计基于闪存的 SSD 产生深远影响，我们很快就会了解到这一点。==

**Summary**
==**总结**==

To summarize, reading a page is easy: just read the page.
==总而言之，读取页很简单：直接读就行。==

Flash chips do this quite well, and quickly; in terms of performance, they offer the potential to greatly exceed the random read performance of modern disk drives, which are slow due to mechanical seek and rotation costs.
==闪存芯片在这方面表现出色且迅速；在性能方面，它们有可能大大超过现代磁盘驱动器的随机读取性能，而磁盘驱动器由于机械寻道和旋转成本而变得缓慢。==

Writing a page is trickier; the entire block must first be erased (taking care to first move any data we care about to another location), and then the desired page programmed.
==写入页则更为复杂；必须先擦除整个块（注意先将关心的任何数据移动到另一个位置），然后对所需的页进行编程。==

Not only is this expensive, but frequent repetitions of this program/erase cycle can lead to the biggest reliability problem flash chips have: **wear out**.
==这不仅代价高昂，而且频繁重复这种“编程/擦除”循环会导致闪存芯片面临最大的可靠性问题：**磨损**。==

When designing a storage system with flash, the performance and reliability of writing is a central focus.
==在设计使用闪存的存储系统时，写入的性能和可靠性是核心关注点。==

We’ll soon learn more about how modern SSDs attack these issues, delivering excellent performance and reliability despite these limitations.
==我们很快就会学到更多关于现代 SSD 如何解决这些问题的知识，从而在存在这些局限性的情况下依然提供卓越的性能和可靠性。==

**44.4 Flash Performance And Reliability**
==**44.4 闪存性能与可靠性**==

Because we’re interested in building a storage device out of raw flash chips, it is worthwhile to understand their basic performance characteristics.
==因为我们有兴趣利用原始闪存芯片构建存储设备，所以了解其基本性能特征是值得的。==

Figure 44.2 presents a rough summary of some numbers found in the popular press [V12].
==图 44.2 给出了大众媒体上常见的一些数字的粗略总结 [V12]。==

Therein, the author presents the basic operation latency of reads, programs, and erases across SLC, MLC, and TLC flash, which store 1, 2, and 3 bits of information per cell, respectively.
==在其中，作者展示了 SLC、MLC 和 TLC 闪存的读取、编程和擦除的基础操作延迟，这些闪存每个单元分别存储 1、2 和 3 位信息。==

As we can see from the table, read latencies are quite good, taking just 10s of microseconds to complete.
==从表中可以看出，读取延迟相当好，只需几十微秒即可完成。==

Program latency is higher and more variable, as low as 200 microseconds for SLC, but higher as you pack more bits into each cell; to get good write performance, you will have to make use of multiple flash chips in parallel.
==编程延迟更高且更具波动性，SLC 闪存最低为 200 微秒，但随着每个单元容纳更多位，延迟也会随之增加；为了获得良好的写入性能，你必须并行使用多个闪存芯片。==

Finally, erases are quite expensive, taking a few milliseconds typically.
==最后，擦除操作代价非常高，通常需要几毫秒。==

Dealing with this cost is central to modern flash storage design.
==处理这种成本是现代闪存存储设计的核心。==

Let’s now consider reliability of flash chips.
==现在让我们考虑闪存芯片的可靠性。==

Unlike mechanical disks, which can fail for a wide variety of reasons (including the gruesome and quite physical head crash, where the drive head actually makes contact with the recording surface), flash chips are pure silicon and in that sense have fewer reliability issues to worry about.
==机械磁盘可能由于各种原因失效（包括可怕且非常具有物理破坏性的磁头崩溃，即驱动器磁头实际上接触到了记录表面），与此不同，闪存芯片是纯硅制品，从这个意义上说，需要担心的可靠性问题较少。==

The primary concern is **wear out**; when a flash block is erased and programmed, it slowly accrues a little bit of extra charge.
==主要的担忧是**磨损**；当一个闪存块被擦除和编程时，它会慢慢积累一点额外的电荷。==

Over time, as that extra charge builds up, it becomes increasingly difficult to differentiate between a 0 and a 1.
==随着时间的推移，随着额外电荷的积累，区分 0 和 1 变得越来越困难。==

At the point where it becomes impossible, the block becomes unusable.
==当这种区分变得不可能时，该块就变得无法使用了。==

The typical lifetime of a block is currently not well known.
==块的典型寿命目前尚不十分清楚。==

Manufacturers rate MLC-based blocks as having a 10,000 P/E (Program/Erase) cycle lifetime; that is, each block can be erased and programmed 10,000 times before failing.
==制造商将基于 MLC 的块额定为 10,000 次 P/E（编程/擦除）循环寿命；也就是说，每个块在失效前可以被擦除和编程 10,000 次。==

SLC-based chips, because they store only a single bit per transistor, are rated with a longer lifetime, usually 100,000 P/E cycles.
==基于 SLC 的芯片由于每个晶体管只存储一位，其额定寿命更长，通常为 100,000 次 P/E 循环。==

However, recent research has shown that lifetimes are much longer than expected [BD10].
==然而，最近的研究表明，寿命比预期的要长得多 [BD10]。==

One other reliability problem within flash chips is known as **disturbance**.
==闪存芯片内的另一个可靠性问题被称为**干扰 (disturbance)**。==

When accessing a particular page within a flash, it is possible that some bits get flipped in neighboring pages; such bit flips are known as **read disturbs** or **program disturbs**, depending on whether the page is being read or programmed, respectively.
==当访问闪存中的特定页时，相邻页中的某些位可能会发生翻转；这种位翻转被称为**读取干扰**或**编程干扰**，分别取决于该页是在被读取还是被编程。==

**TIP: THE IMPORTANCE OF BACKWARDS COMPATIBILITY**
==**提示：向后兼容性的重要性**==

Backwards compatibility is always a concern in layered systems.
==在分层系统中，向后兼容性始终是一个值得关注的问题。==

By defining a stable interface between two systems, one enables innovation on each side of the interface while ensuring continued interoperability.
==通过在两个系统之间定义稳定的接口，可以在确保持续互操作性的同时，允许接口两侧各自进行创新。==

Such an approach has been quite successful in many domains: operating systems have relatively stable APIs for applications, disks provide the same block-based interface to file systems, and each layer in the IP networking stack provides a fixed unchanging interface to the layer above.
==这种方法在许多领域都非常成功：操作系统为应用程序提供相对稳定的 API，磁盘为文件系统提供相同的基于块的接口，IP 网络堆栈中的每一层都为上一层提供固定不变的接口。==

Not surprisingly, there can be a downside to such rigidity, as interfaces defined in one generation may not be appropriate in the next.
==不出所料，这种僵化也有其弊端，因为某一代定义的接口在下一代可能就不再适用。==

In some cases, it may be useful to think about redesigning the entire system entirely.
==在某些情况下，考虑彻底重新设计整个系统可能会很有用。==

An excellent example is found in the Sun ZFS file system [B07]; by reconsidering the interaction of file systems and RAID, the creators of ZFS envisioned (and then realized) a more effective integrated whole.
==Sun ZFS 文件系统 [B07] 就是一个绝佳的例子；通过重新考虑文件系统和 RAID 的交互，ZFS 的创造者设想（并随后实现了）一个更有效的集成整体。==

**44.5 From Raw Flash to Flash-Based SSDs**
==**44.5 从原始闪存到基于闪存的 SSD**==

Given our basic understanding of flash chips, we now face our next task: how to turn a basic set of flash chips into something that looks like a typical storage device.
==既然我们对闪存芯片有了基本的了解，现在面临下一个任务：如何将一组基础的闪存芯片转变为看起来像典型存储设备的东西。==

The standard storage interface is a simple block-based one, where blocks (sectors) of size 512 bytes (or larger) can be read or written, given a block address.
==标准的存储接口是简单的基于块的接口，在这种接口下，给定一个块地址，就可以读取或写入大小为 512 字节（或更大）的块（扇区）。==

The task of the flash-based SSD is to provide that standard block interface atop the raw flash chips inside it.
==基于闪存的 SSD 的任务就是在其内部的原始闪存芯片之上提供这种标准的块接口。==

Internally, an SSD consists of some number of flash chips (for persistent storage).
==在内部，一个 SSD 由若干闪存芯片组成（用于持久化存储）。==

An SSD also contains some amount of volatile (i.e., non-persistent) memory (e.g., SRAM); such memory is useful for caching and buffering of data as well as for mapping tables, which we’ll learn about below.
==SSD 还包含一定量的易失性（即非持久性）内存（例如 SRAM）；这种内存对于数据缓存、缓冲以及映射表（我们将在下文了解到）非常有用。==

Finally, an SSD contains control logic to orchestrate device operation.
==最后，SSD 包含控制逻辑来协调设备的运行。==

See Agrawal et. al for details [A+08]; a simplified block diagram is seen in Figure 44.3 (page 7).
==详情请参阅 Agrawal 等人的文章 [A+08]；简化的框图见图 44.3（第 7 页）。==

One of the essential functions of this control logic is to satisfy client reads and writes, turning them into internal flash operations as need be.
==这种控制逻辑的核心功能之一是满足客户端的读写请求，并根据需要将其转换为内部闪存操作。==

The **flash translation layer**, or **FTL**, provides exactly this functionality.
==**闪存转换层**（或 **FTL**）正是提供了这种功能。==

The FTL takes read and write requests on **logical blocks** (that comprise the device interface) and turns them into low-level read, erase, and program commands on the underlying **physical blocks** and **physical pages** (that comprise the actual flash device).
==FTL 接收对**逻辑块**（构成设备接口）的读写请求，并将其转换为对底层**物理块**和**物理页**（构成实际闪存设备）的底层读取、擦除和编程命令。==

The FTL should accomplish this task with the goal of delivering excellent performance and high reliability.
==FTL 应该以提供卓越性能和高可靠性为目标来完成这项任务。==

Excellent performance, as we’ll see, can be realized through a combination of techniques.
==正如我们将看到的，卓越的性能可以通过多种技术的结合来实现。==

One key will be to utilize multiple flash chips **in parallel**; although we won’t discuss this technique much further, suffice it to say that all modern SSDs use multiple chips internally to obtain higher performance.
==其中一个关键是**并行**利用多个闪存芯片；虽然我们不会进一步讨论这种技术，但可以肯定的是，所有现代 SSD 都在内部使用多个芯片以获得更高的性能。==

Another performance goal will be to reduce **write amplification**, which is defined as the total write traffic (in bytes) issued to the flash chips by the FTL divided by the total write traffic (in bytes) issued by the client to the SSD.
==另一个性能目标是减少**写入放大**，其定义为 FTL 发送到闪存芯片的总写入流量（以字节为单位）除以客户端发送到 SSD 的总写入流量（以字节为单位）。==

As we’ll see below, naive approaches to FTL construction will lead to high write amplification and low performance.
==正如我们将在下文中看到的，幼稚的 FTL 构建方法会导致高写入放大和低性能。==

High reliability will be achieved through the combination of a few different approaches.
==高可靠性将通过几种不同方法的结合来实现。==

One main concern, as discussed above, is **wear out**.
==如上所述，一个主要问题是**磨损**。==

If a single block is erased and programmed too often, it will become unusable; as a result, the FTL should try to spread writes across the blocks of the flash as evenly as possible, ensuring that all of the blocks of the device wear out at roughly the same time; doing so is called **wear leveling** and is an essential part of any modern FTL.
==如果单个块被擦除和编程过于频繁，它将变得不可用；因此，FTL 应尝试尽可能均匀地将写入分布在闪存的各个块上，确保设备的所有块大致在同一时间磨损；这样做被称为**磨损均衡**，是任何现代 FTL 的重要组成部分。==

Another reliability concern is program disturbance.
==另一个可靠性问题是编程干扰。==

To minimize such disturbance, FTLs will commonly program pages within an erased block in order, from low page to high page.
==为了尽量减少这种干扰，FTL 通常会按照从低页到高页的顺序对已擦除块内的页进行编程。==

This sequential-programming approach minimizes disturbance and is widely utilized.
==这种顺序编程方法可以最大限度地减少干扰，并被广泛采用。==

**44.6 FTL Organization: A Bad Approach**
==**44.6 FTL 组织：一种糟糕的方法**==

The simplest organization of an FTL would be something we call **direct mapped**.
==FTL 最简单的组织形式是我们所谓的**直接映射**。==

In this approach, a read to logical page $N$ is mapped directly to a read of physical page $N$.
==在这种方法中，对逻辑页 $N$ 的读取被直接映射到对物理页 $N$ 的读取。==

A write to logical page $N$ is more complicated; the FTL first has to read in the entire block that page $N$ is contained within; it then has to erase the block; finally, the FTL programs the old pages as well as the new one.
==对逻辑页 $N$ 的写入则更为复杂；FTL 首先必须读入包含页 $N$ 的整个块；然后必须擦除该块；最后，FTL 对旧页以及新页进行编程。==

As you can probably guess, the direct-mapped FTL has many problems, both in terms of performance as well as reliability.
==正如你大概能猜到的，直接映射的 FTL 在性能和可靠性方面都存在许多问题。==

The performance problems come on each write: the device has to read in the entire block (costly), erase it (quite costly), and then program it (costly).
==性能问题出现在每次写入时：设备必须读入整个块（代价高），擦除它（代价非常高），然后编程（代价高）。==

The end result is severe write amplification (proportional to the number of pages in a block) and as a result, terrible write performance, even slower than typical hard drives with their mechanical seeks and rotational delays.
==最终结果是严重的写入放大（与块中的页数成正比），从而导致糟糕的写入性能，甚至比具有机械寻道和旋转延迟的典型硬盘驱动器还要慢。==

Even worse is the reliability of this approach.
==这种方法的可靠性甚至更糟。==

If file system metadata or user file data is repeatedly overwritten, the same block is erased and programmed, over and over, rapidly wearing it out and potentially losing data.
==如果文件系统元数据或用户文件数据被反复覆盖，同一个块就会被一遍又一遍地擦除和编程，迅速磨损并可能导致数据丢失。==

The direct mapped approach simply gives too much control over wear out to the client workload; if the workload does not spread write load evenly across its logical blocks, the underlying physical blocks containing popular data will quickly wear out.
==直接映射方法仅仅是将磨损的控制权过多地交给了客户端工作负载；如果工作负载没有将其写入负载均匀地分布在逻辑块上，那么包含热门数据的底层物理块将很快磨损。==

For both reliability and performance reasons, a direct-mapped FTL is a bad idea.
==出于可靠性和性能方面的考虑，直接映射的 FTL 是个坏主意。==

**44.7 A Log-Structured FTL**
==**44.7 日志结构 FTL**==

For these reasons, most FTLs today are **log structured**, an idea useful in both storage devices (as we’ll see now) and file systems above them (e.g., in **log-structured file systems**).
==出于这些原因，当今大多数 FTL 都是**日志结构化**的，这一理念在存储设备（正如我们现在所看到的）以及其上层的文件系统（例如在**日志结构文件系统**中）中都非常有用。==

Upon a write to logical block $N$, the device appends the write to the next free spot in the currently-being-written-to block; we call this style of writing **logging**.
==在向逻辑块 $N$ 写入时，设备会将写入内容追加到当前正在写入块的下一个空闲位置；我们称这种写入方式为**日志记录 (logging)**。==

To allow for subsequent reads of block $N$, the device keeps a **mapping table** (in its memory, and persistent, in some form, on the device); this table stores the physical address of each logical block in the system.
==为了允许后续读取块 $N$，设备会维护一个**映射表**（保存在其内存中，并以某种形式持久化存储在设备上）；该表存储了系统中每个逻辑块的物理地址。==

Let’s go through an example to make sure we understand how the basic log-based approach works.
==让我们通过一个例子来确保我们理解了基本的基于日志的方法是如何工作的。==

To the client, the device looks like a typical disk, in which it can read and write 512-byte sectors (or groups of sectors).
==对于客户端来说，该设备看起来像一个典型的磁盘，在其中可以读取和写入 512 字节的扇区（或扇区组）。==

For simplicity, assume that the client is reading or writing 4-KB sized chunks.
==为简单起见，假设客户端读取或写入的是 4 KB 大小的块。==

Let us further assume that the SSD contains some large number of 16-KB sized blocks, each divided into four 4-KB pages; these parameters are unrealistic (flash blocks usually consist of more pages) but will serve our didactic purposes quite well.
==我们进一步假设 SSD 包含大量 16 KB 大小的块，每个块分为四个 4 KB 的页；这些参数虽然不切实际（闪存块通常包含更多页），但非常符合我们的教学目的。==

Assume the client issues the following sequence of operations:
==假设客户端发出以下操作序列：==

• Write(100) with contents a1
==• Write(100)，内容为 a1==

• Write(101) with contents a2
==• Write(101)，内容为 a2==

• Write(2000) with contents b1
==• Write(2000)，内容为 b1==

• Write(2001) with contents b2
==• Write(2001)，内容 for b2==

These **logical block addresses** (e.g., 100) are used by the client of the SSD (e.g., a file system) to remember where information is located.
==这些**逻辑块地址**（例如 100）被 SSD 的客户端（例如文件系统）用来记住信息所在的位置。==

Internally, the device must transform these block writes into the erase and program operations supported by the raw hardware, and somehow record, for each logical block address, which **physical page** of the SSD stores its data.
==在内部，设备必须将这些块写入转换为原始硬件支持的擦除和编程操作，并以某种方式记录每个逻辑块地址由 SSD 的哪个**物理页**存储其数据。==

Assume that all blocks of the SSD are currently not valid, and must be erased before any page can be programmed.
==假设 SSD 的所有块当前都无效，并且在对任何页进行编程之前必须先进行擦除。==

When the first write is received by the SSD (to logical block 100), the FTL decides to write it to physical block 0, which contains four physical pages: 0, 1, 2, and 3.
==当 SSD 收到第一次写入（针对逻辑块 100）时，FTL 决定将其写入物理块 0，该块包含四个物理页：0、1、2 和 3。==

Because the block is not erased, we cannot write to it yet; the device must first issue an erase command to block 0.
==由于该块尚未擦除，我们还不能写入；设备必须先向块 0 发出擦除命令。==

Block 0 is now ready to be programmed.
==块 0 现在已准备好进行编程。==

Most SSDs will write pages in order (i.e., low to high), reducing reliability problems related to **program disturbance**.
==大多数 SSD 会按顺序（即从低到高）写入页，以减少与**编程干扰**相关的可靠性问题。==

The SSD then directs the write of logical block 100 into physical page 0.
==然后，SSD 将逻辑块 100 的写入导向物理页 0。==

But what if the client wants to *read* logical block 100? How can it find where it is?
==但如果客户端想要*读取*逻辑块 100 呢？它如何找到它的位置？==

The SSD must transform a read issued to logical block 100 into a read of physical page 0.
==SSD 必须将向逻辑块 100 发出的读取请求转换为对物理页 0 的读取。==

To accommodate such functionality, when the FTL writes logical block 100 to physical page 0, it records this fact in an **in-memory mapping table**.
==为了实现这种功能，当 FTL 将逻辑块 100 写入物理页 0 时，它会将这一事实记录在一个**内存映射表**中。==

Now you can see what happens when the client writes to the SSD.
==现在你可以看到当客户端向 SSD 写入时会发生什么。==

The SSD finds a location for the write, usually just picking the next free page; it then programs that page with the block’s contents, and records the logical-to-physical mapping in its mapping table.
==SSD 为写入寻找一个位置，通常只是挑选下一个空闲页；然后它用该块的内容对该页进行编程，并在其映射表中记录逻辑到物理的映射。==

Subsequent reads simply use the table to **translate** the logical block address presented by the client into the physical page number required to read the data.
==随后的读取只需使用该表将客户端提供的逻辑块地址**转换**为读取数据所需的物理页号。==

Let’s now examine the rest of the writes in our example write stream: 101, 2000, and 2001.
==现在让我们检查示例写入流中剩余的写入：101、2000 和 2001。==

The log-based approach by its nature improves performance (erases only being required once in a while, and the costly read-modify-write of the direct-mapped approach avoided altogether), and greatly enhances reliability.
==日志结构化方法从本质上提高了性能（只需偶尔进行一次擦除，并完全避免了直接映射方法中代价高昂的“读取-修改-写入”），并且大大增强了可靠性。==

The FTL can now spread writes across all pages, performing what is called **wear leveling** and increasing the lifetime of the device.
==FTL 现在可以将写入分布在所有页上，执行所谓的**磨损均衡**，从而延长设备的寿命。==

**ASIDE: FTL MAPPING INFORMATION PERSISTENCE**
==**旁注：FTL 映射信息的持久化**==

You might be wondering: what happens if the device loses power? Does the in-memory mapping table disappear?
==你可能会想：如果设备断电了会发生什么？内存中的映射表会消失吗？==

Clearly, such information cannot truly be lost, because otherwise the device would not function as a persistent storage device.
==显然，这些信息不能真正丢失，否则设备就无法作为持久化存储设备工作。==

An SSD must have some means of recovering mapping information.
==SSD 必须有某种恢复映射手段的方法。==

The simplest thing to do is to record some mapping information with each page, in what is called an **out-of-band (OOB)** area.
==最简单的方法是在每个页中记录一些映射信息，这被称为**带外 (OOB)** 区域。==

When the device loses power and is restarted, it must reconstruct its mapping table by scanning the OOB areas and reconstructing the mapping table in memory.
==当设备断电并重启时，它必须通过扫描 OOB 区域并在内存中重建映射表来恢复。==

This basic approach has its problems; scanning a large SSD to find all necessary mapping information is slow.
==这种基础方法也有其问题；扫描大型 SSD 以查找所有必要的映射信息速度很慢。==

To overcome this limitation, some higher-end devices use more complex logging and **checkpointing** techniques to speed up recovery.
==为了克服这一局限，一些高端设备使用更复杂的日志记录和**检查点**技术来加速恢复。==

Unfortunately, this basic approach to log structuring has some downsides.
==不幸的是，这种基础的日志结构方法也有一些缺点。==

The first is that overwrites of logical blocks lead to something we call **garbage**, i.e., old versions of data around the drive and taking up space.
==第一个缺点是，逻辑块的覆写会导致产生我们所谓的**垃圾**，即分布在驱动器周围并占用空间的旧版本数据。==

The device has to periodically perform **garbage collection (GC)** to find said blocks and free space for future writes; excessive garbage collection drives up write amplification and lowers performance.
==设备必须定期执行**垃圾回收 (GC)**，以找到这些块并为将来的写入释放空间；过度的垃圾回收会推高写入放大并降低性能。==

The second is high cost of in-memory mapping tables; the larger the device, the more memory such tables need.
==第二个缺点是内存映射表的成本高昂；设备越大，此类表需要的内存就越多。==

**44.8 Garbage Collection**
==**44.8 垃圾回收**==

The first cost of any log-structured approach such as this one is that garbage is created, and therefore **garbage collection** (i.e., dead-block reclamation) must be performed.
==像这样的日志结构化方法的第一项成本就是会产生垃圾，因此必须执行**垃圾回收**（即死块回收）。==

Now, let’s assume that blocks 100 and 101 are written to again, with contents c1 and c2.
==现在，假设对块 100 和 101 再次进行写入，内容为 c1 和 c2。==

The writes are written to the next free pages (in this case, physical pages 4 and 5), and the mapping table is updated accordingly.
==这些写入被写到下一个空闲页（在本例中为物理页 4 和 5），并相应地更新映射表。==

Note that the device must have first erased block 1 to make such programming possible.
==请注意，设备必须首先擦除块 1 才能使此类编程成为可能。==

The problem we have now should be obvious: physical pages 0 and 1, although marked `VALID`, have **garbage** in them, i.e., the old versions of blocks 100 and 101.
==我们现在面临的问题显而易见：物理页 0 和 1 虽然被标记为 `VALID`，但其中包含**垃圾**，即块 100 和 101 的旧版本。==

Because of the log-structured nature of the device, overwrites create garbage blocks, which the device must reclaim to provide free space for new writes to take place.
==由于设备的日志结构特性，覆写会产生垃圾块，设备必须回收这些块，以便为新的写入提供空闲空间。==

The process of finding garbage blocks (also called **dead blocks**) and reclaiming them for future use is called garbage collection, and it is an important component of any modern SSD.
==寻找垃圾块（也称为**死块**）并回收它们以供将来使用的过程被称为垃圾回收，它是任何现代 SSD 的重要组成部分。==

The basic process is simple: find a block that contains one or more garbage pages, read in the **live** (non-garbage) pages from that block, write out those live pages to the log, and (finally) reclaim the entire block for use in writing.
==基本过程很简单：找出一个包含一个或多个垃圾页的块，从该块中读入**活跃**（非垃圾）页，将这些活跃页写回到日志末尾，并（最后）回收整个块以供写入使用。==

Let’s now illustrate with an example.
==现在让我们用一个例子来说明。==

The device decides it wants to reclaim any dead pages within block 0 above.
==设备决定要回收上面块 0 中的任何死页。==

Block 0 has two dead blocks (pages 0 and 1) and two live blocks (pages 2 and 3, which contain blocks 2000 and 2001, respectively).
==块 0 有两个死块（页 0 和 1）和两个活跃块（页 2 和 3，它们分别包含块 2000 和 2001）。==

To do so, the device will:
==为此，设备将：==

• Read live data (pages 2 and 3) from block 0
==• 从块 0 读取活跃数据（页 2 和 3）==

• Write live data to end of the log
==• 将活跃数据写入日志末尾==

• Erase block 0 (freeing it for later usage)
==• 擦除块 0（释放它以供以后使用）==

For the garbage collector to function, there must be enough information within each block to enable the SSD to determine whether each page is live or dead.
==为了使垃圾回收器正常工作，每个块中必须包含足够的信息，使 SSD 能够确定每个页是活跃的还是死掉的。==

One natural way to achieve this end is to store, at some location within each block, information about which logical blocks are stored within each page.
==实现这一目标的一种自然方法是在每个块的某个位置存储有关每个页中存储了哪些逻辑块的信息。==

The device can then use the mapping table to determine whether each page within the block holds live data or not.
==然后，设备可以使用映射表来确定块内的每个页是否持有活跃数据。==

By checking the mapping table (which, before garbage collection, contained 100->4, 101->5, 2000->2, 2001->3), the device can readily determine whether each of the pages within the SSD block holds live information.
==通过检查映射表（在垃圾回收之前，映射表包含 100->4, 101->5, 2000->2, 2001->3），设备可以轻松确定 SSD 块内的每个页是否持有活跃信息。==

As you can see, garbage collection can be expensive, requiring reading and rewriting of live data.
==如你所见，垃圾回收可能代价很高，因为它需要读取和重写活跃数据。==

The ideal candidate for reclamation is a block that consists of only dead pages; in this case, the block can immediately be erased and used for new data, without expensive data migration.
==最理想的回收对象是仅由死页组成的块；在这种情况下，该块可以立即被擦除并用于新数据，而无需昂贵的数据迁移。==

**ASIDE: A NEW STORAGE API KNOWN AS TRIM**
==**旁注：一种名为 TRIM 的新存储 API**==

When we think of hard drives, we usually just think of the most basic interface to read and write them.
==当我们想到硬盘驱动器时，我们通常只会想到读写它们的最基础接口。==

With log-structured SSDs, and indeed, any device that keeps a flexible and changing mapping of logical-to-physical blocks, a new interface is useful, known as the **trim** operation.
==对于日志结构化的 SSD，以及任何保持灵活且不断变化的逻辑到物理块映射的设备，一种名为 **trim** 操作的新接口非常有用。==

The trim operation takes an address (and possibly a length) and simply informs the device that the block(s) specified by the address (and length) have been deleted.
==TRIM 操作接收一个地址（可能还有一个长度），并简单地通知设备，由该地址（和长度）指定的块已被删除。==

The device thus no longer has to track any information about the given address range.
==因此，设备不再需要跟踪有关给定地址范围的任何信息。==

For a standard hard drive, trim isn’t particularly useful, because the drive has a static mapping of block addresses to specific platter, track, and sector(s).
==对于标准的硬盘驱动器，TRIM 并不是特别有用，因为驱动器具有块地址到特定盘片、磁道和扇区的静态映射。==

For a log-structured SSD, however, it is highly useful to know that a block is no longer needed, as the SSD can then remove this information from the FTL and later reclaim the physical space during garbage collection.
==然而，对于日志结构的 SSD，知道一个块不再被需要是非常有用的，因为 SSD 随后可以从 FTL 中删除此信息，并在以后的垃圾回收期间回收物理空间。==

To reduce GC costs, some SSDs **overprovision** the device [A+08]; by adding extra flash capacity, cleaning can be delayed and pushed to the background.
==为了降低垃圾回收 (GC) 成本，一些 SSD 会对设备进行**超额配置 (overprovision)** [A+08]；通过增加额外的闪存容量，清理工作可以延迟并推送到后台进行。==

**44.9 Mapping Table Size**
==**44.9 映射表大小**==

The second cost of log-structuring is the potential for extremely large mapping tables, with one entry for each 4-KB page of the device.
==日志结构化的第二个成本是可能产生极大的映射表，设备的每个 4 KB 页都需要一个表项。==

With a large 1-TB SSD, for example, a single 4-byte entry per 4-KB page results in 1 GB of memory needed by the device, just for these mappings!
==例如，对于一个 1 TB 的大型 SSD，每个 4 KB 页对应一个 4 字节的表项，仅这些映射就需要设备提供 1 GB 的内存！==

Thus, this **page-level** FTL scheme is impractical.
==因此，这种**页级** FTL 方案是不切实际的。==

**Block-Based Mapping**
==**基于块的映射**==

One approach to reduce the costs of mapping is to only keep a pointer per *block* of the device, instead of per page, reducing the amount of mapping information by a factor of $\frac{Size_{block}}{Size_{page}}$.
==一种降低映射成本的方法是仅为设备的每个*块*（而不是每个页）保留一个指针，从而将映射信息量减少到原来的 $\frac{Size_{block}}{Size_{page}}$。==

This **block-level** FTL is akin to having bigger page sizes in a virtual memory system.
==这种**块级** FTL 类似于在虚拟内存系统中使用更大的页大小。==

Unfortunately, using a block-based mapping inside a log-based FTL does not work very well for performance reasons.
==不幸的是，出于性能原因，在日志结构 FTL 中使用基于块的映射效果并不理想。==

The biggest problem arises when a “small write” occurs (i.e., one that is less than the size of a physical block).
==最大的问题出现在发生“小额写入”时（即写入量小于物理块的大小）。==

In this case, the FTL must read a large amount of live data from the old block and copy it into a new one (along with the data from the small write).
==在这种情况下，FTL 必须从旧块中读取大量活跃数据，并将其复制到新块中（连同来自小额写入的数据）。==

This data copying increases write amplification greatly and thus decreases performance.
==这种数据复制大大增加了写入放大，从而降低了性能。==

**Hybrid Mapping**
==**混合映射**==

To enable flexible writing but also reduce mapping costs, many modern FTLs employ a **hybrid mapping** technique.
==为了实现灵活的写入并降低映射成本，许多现代 FTL 采用了**混合映射**技术。==

With this approach, the FTL keeps a few blocks erased and directs all writes to them; these are called **log blocks**.
==通过这种方法，FTL 保持几个块处于已擦除状态，并将所有写入导向它们；这些块被称为**日志块 (log blocks)**。==

Because the FTL wants to be able to write any page to any location within the log block without all the copying required by a pure block-based mapping, it keeps **per-page** mappings for these log blocks.
==由于 FTL 希望能够将任何页写入日志块内的任何位置，而不需要纯基于块的映射所需的所有复制操作，因此它为这些日志块保留了**每页 (per-page)** 映射。==

The FTL thus logically has two types of mapping table in its memory: a small set of per-page mappings in what we’ll call the **log table**, and a larger set of per-block mappings in the **data table**.
==因此，FTL 的内存中逻辑上存在两种类型的映射表：一组较小的每页映射，我们称之为**日志表 (log table)**；以及一组较大的每块映射，称为**数据表 (data table)**。==

When looking for a particular logical block, the FTL will first consult the log table; if the logical block’s location is not found there, the FTL will then consult the data table to find its location.
==在寻找特定的逻辑块时，FTL 会首先咨询日志表；如果在那里没有找到该逻辑块的位置，FTL 随后会咨询数据表来查找其位置。==

The key to the hybrid mapping strategy is keeping the number of log blocks small.
==混合映射策略的关键在于保持日志块的数量较少。==

To keep the number of log blocks small, the FTL has to periodically examine log blocks and **switch** them into blocks that can be pointed to by only a single block pointer.
==为了保持日志块数量较少，FTL 必须定期检查日志块，并将它们**转换 (switch)** 为只能由单个块指针指向的块。==

This switch is accomplished by one of three main techniques: **switch merge**, **partial merge**, or **full merge**.
==这种转换通过三种主要技术之一完成：**交换合并 (switch merge)**、**部分合并 (partial merge)** 或**全合并 (full merge)**。==

**44.10 Wear Leveling**
==**44.10 磨损均衡**==

Finally, a related background activity that modern FTLs must implement is **wear leveling**.
==最后，现代 FTL 必须实现的另一项相关后台活动是**磨损均衡**。==

The basic idea is simple: because multiple erase/program cycles will wear out a flash block, the FTL should try its best to spread that work across all the blocks of the device evenly.
==基本思想很简单：由于多次擦除/编程循环会磨损闪存块，因此 FTL 应尽最大努力将这些工作均匀地分布在设备的所有块上。==

In this manner, all blocks will wear out at roughly the same time, instead of a few “popular” blocks quickly becoming unusable.
==通过这种方式，所有块大致会在同一时间磨损，而不是少数“热门”块迅速变得无法使用。==

**44.11 SSD Performance And Cost**
==**44.11 SSD 性能与成本**==

Unlike hard disk drives, flash-based SSDs have no mechanical components, and in fact are in many ways more similar to DRAM, in that they are “random access” devices.
==与硬盘驱动器不同，基于闪存的 SSD 没有机械部件，事实上在许多方面更类似于 DRAM，因为它们是“随机存取”设备。==

The biggest difference in performance, as compared to disk drives, is realized when performing random reads and writes; while a typical disk drive can only perform a few hundred random I/Os per second, SSDs can do much better.
==与磁盘驱动器相比，最大的性能差异体现在执行随机读写时；虽然典型的磁盘驱动器每秒只能执行几百次随机 I/O，但 SSD 的表现要好得多。==

The reason for such unexpectedly good random-write performance is due to the log-structured design of many SSDs, which transforms random writes into sequential ones and improves performance.
==如此出色的随机写入性能归功于许多 SSD 的日志结构设计，它将随机写入转换为顺序写入并提高了性能。==

So why haven’t SSDs completely replaced hard drives as the storage medium of choice?
==那么，为什么 SSD 还没有完全取代硬盘驱动器成为首选的存储介质呢？==

The answer is simple: **cost**, or more specifically, cost per unit of capacity.
==答案很简单：**成本**，或者更具体地说，是单位容量的成本。==

If performance is the main concern, SSDs are a terrific choice.
==如果性能是主要考虑因素，那么 SSD 是一个极好的选择。==

If, on the other hand, you are assembling a large data center and wish to store massive amounts of information, the large cost difference will drive you towards hard drives.
==另一方面，如果你正在组建一个大型数据中心并希望存储海量信息，巨大的成本差异会让你倾向于选择硬盘驱动器。==

As long as the price gap exists, hard drives are here to stay.
==只要价格差距依然存在，硬盘驱动器就将继续存在。==

**44.12 Summary**
==**44.12 总结**==

Flash-based SSDs are becoming a common presence in laptops, desktops, and servers inside the datacenters that power the world’s economy.
==基于闪存的 SSD 正日益普遍地出现在笔记本电脑、台式机以及驱动全球经济的数据中心服务器中。==

This chapter is just the first step in understanding the state of the art.
==本章仅仅是理解这一前沿技术的第一步。==

Don’t just read academic papers; also read about recent advances in the popular press.
==不要只读学术论文；也要关注大众媒体上关于最新进展的报道。==

Dive in and learn more about this “iceberg” of research on your own.
==深入钻研，自行探索这一研究领域的“冰山”。==

Be careful though; icebergs can sink even the mightiest of ships.
==不过要小心；冰山甚至能撞沉最强大的舰船。==




==### 第一步：数据清洗 | 第二步：句子切分 | 第三步：输出格式==

ASIDE: KEY SSD TERMS
==侧栏：SSD 关键术语==

A flash chip consists of many banks, each of which is organized into **erase blocks** (sometimes just called **blocks**).
==一个闪存芯片由许多 bank 组成，每个 bank 被组织成**擦除块**（有时简称为**块**）。==

Each block is further subdivided into some number of **pages**.
==每个块进一步细分为若干个**页**。==

Blocks are large (128KB–2MB) and contain many pages, which are relatively small (1KB–8KB).
==块的容量很大（128KB–2MB），包含许多相对较小的页（1KB–8KB）。==

To read from flash, issue a read command with an address and length; this allows a client to read one or more pages.
==要从闪存读取，需发出带有地址和长度的读取命令；这允许客户端读取一个或多个页。==

Writing flash is more complex.
==写入闪存则更为复杂。==

First, the client must **erase** the entire block (which deletes all information within the block).
==首先，客户端必须**擦除**整个块（这将删除该块内的所有信息）。==

Then, the client can **program** each page exactly once, thus completing the write.
==然后，客户端可以对每个页进行精确的一次**编程**，从而完成写入。==

A new **trim** operation is useful to tell the device when a particular block (or range of blocks) is no longer needed.
==一种新的 **trim** 操作很有用，它能告知设备何时不再需要特定的块（或块范围）。==

Flash reliability is mostly determined by **wear out**; if a block is erased and programmed too often, it will become unusable.
==闪存的可靠性主要由**磨损**决定；如果一个块被过度频繁地擦除和编程，它将变得不可用。==

A flash-based **solid-state storage device (SSD)** behaves as if it were a normal block-based read/write disk; by using a **flash translation layer (FTL)**, it transforms reads and writes from a client into reads, erases, and programs to underlying flash chips.
==基于闪存的**固态存储设备 (SSD)** 的表现就像一个普通的基于块的读/写磁盘；通过使用**闪存转换层 (FTL)**，它将来自客户端的读取和写入操作转换为对底层闪存芯片的读取、擦除和编程。==

Most FTLs are **log-structured**, which reduces the cost of writing by minimizing erase/program cycles.
==大多数 FTL 都是**日志结构化**的，这通过减少擦除/编程周期来降低写入成本。==

An in-memory translation layer tracks where logical writes were located within the physical medium.
==一个内存中的转换层负责跟踪逻辑写入在物理介质中的位置。==

One key problem with log-structured FTLs is the cost of **garbage collection**, which leads to **write amplification**.
==日志结构化 FTL 的一个关键问题是**垃圾回收**的成本，这会导致**写入放大**。==

Another problem is the size of the mapping table, which can become quite large.
==另一个问题是映射表的大小，它可能会变得非常庞大。==

Using a **hybrid mapping** or just **caching** hot pieces of the FTL are possible remedies.
==使用**混合映射**或仅对 FTL 的热点部分进行**缓存**是可能的补救措施。==

One last problem is **wear leveling**; the FTL must occasionally migrate data from blocks that are mostly read in order to ensure said blocks also receive their share of the erase/program load.
==最后一个问题是**磨损均衡**；FTL 必须偶尔将数据从主要进行读取操作的块中迁移出来，以确保这些块也能分担擦除/编程负载。==

Data Integrity and Protection
==数据完整性和保护==

Specifically, how should a file system or storage system ensure that data is safe, given the unreliable nature of modern storage devices?
==具体来说，考虑到现代存储设备的不稳定性，文件系统或存储系统应该如何确保数据的安全？==

This general area is referred to as **data integrity** or **data protection**.
==这一通用领域被称为**数据完整性**或**数据保护**。==

CRUX: HOW TO ENSURE DATA INTEGRITY
==核心问题：如何确保数据完整性==

How should systems ensure that the data written to storage is protected?
==系统应该如何确保写入存储的数据得到保护？==

What techniques are required?
==需要哪些技术？==

How can such techniques be made efficient, with both low space and time overheads?
==如何使这些技术在低空间和时间开销下保持高效？==

Disk Failure Modes
==磁盘故障模式==

Modern disks will occasionally seem to be mostly working but have trouble successfully accessing one or more blocks.
==现代磁盘偶尔会表现为大部分工作正常，但在成功访问一个或多个块时遇到困难。==

Specifically, two types of single-block failures are common and worthy of consideration: **latent sector errors (LSEs)** and **block corruption**.
==具体而言，有两种类型的单块故障很常见且值得考虑：**潜在扇区错误 (LSE)** 和**块损坏**。==

LSEs arise when a disk sector (or group of sectors) has been damaged in some way.
==当磁盘扇区（或扇区组）以某种方式损坏时，就会产生 LSE。==

In-disk **error correcting codes (ECC)** are used by the drive to determine whether the on-disk bits in a block are good.
==驱动器使用磁盘内的**纠错码 (ECC)** 来确定块中的磁盘位是否完好。==

There are also cases where a disk block becomes **corrupt** in a way not detectable by the disk itself.
==还有一些情况，磁盘块变得**损坏**，且无法被磁盘本身检测到。==

These types of faults are particularly insidious because they are **silent faults**.
==这些类型的故障特别阴险，因为它们是**静默故障**。==

Prabhakaran et al. describes this more modern view of disk failure as the **fail-partial** disk failure model.
==Prabhakaran 等人将这种更现代的磁盘故障观点描述为**部分失效**磁盘故障模型。==

Detecting Corruption: The Checksum
==检测损坏：校验和==

The primary mechanism used by modern storage systems to preserve data integrity is called the **checksum**.
==现代存储系统用于保持数据完整性的主要机制称为**校验和**。==

A checksum is simply the result of a function that takes a chunk of data (say a 4KB block) as input and computes a function over said data, producing a small summary.
==校验和简单来说就是一个函数的结果，该函数将一块数据（例如一个 4KB 的块）作为输入，并对该数据计算一个函数，产生一个小的摘要。==

Common Checksum Functions
==常用校验和函数==

One simple checksum function that some use is based on **exclusive or (XOR)**.
==一种被一些人使用的简单校验和函数是基于**异或 (XOR)** 的。==

Another basic checksum function is addition.
==另一个基础的校验和函数是加法。==

A slightly more complex algorithm is known as the **Fletcher checksum**.
==一种稍微复杂一点的算法被称为 **Fletcher 校验和**。==

Specifically, assume a block $D$ consists of bytes $d_1 ... d_n$.
==具体而言，假设一个块 $D$ 由字节 $d_1 ... d_n$ 组成。==

$s1$ is defined as follows: $s1 = (s1 + d_i) \mod 255$ (computed over all $d_i$).
==$s1$ 的定义如下：$s1 = (s1 + d_i) \mod 255$（对所有 $d_i$ 进行计算）。==

$s2$ in turn is: $s2 = (s2 + s1) \mod 255$ (again over all $d_i$).
==$s2$ 依次为：$s2 = (s2 + s1) \mod 255$（再次对所有 $d_i$ 进行计算）。==

One final commonly-used checksum is known as a **cyclic redundancy check (CRC)**.
==最后一种常用的校验和被称为**循环冗余校验 (CRC)**。==

A New Problem: Misdirected Writes
==一个新问题：误导写入==

The first failure mode of interest is called a **misdirected write**.
==第一个值得关注的故障模式被称为**误导写入**。==

This arises in disk and RAID controllers which write the data to disk correctly, except in the wrong location.
==这发生在磁盘和 RAID 控制器中，它们将数据正确地写入磁盘，只是位置写错了。==

The answer, not surprisingly, is simple: add a little more information to each checksum.
==不出所料，答案很简单：给每个校验和添加一点额外信息。==

In this case, adding a **physical identifier (physical ID)** is quite helpful.
==在这种情况下，添加一个**物理标识符 (physical ID)** 非常有帮助。==

One Last Problem: Lost Writes
==最后一个问题：丢失写入==

Specifically, some modern storage devices also have an issue known as a **lost write**.
==具体来说，一些现代存储设备还存在一种被称为**丢失写入**的问题。==

This occurs when the device informs the upper layer that a write has completed but in fact it never is persisted.
==当设备告知上层写入已完成，但实际上该写入从未被持久化时，就会发生这种情况。==

Some systems add a checksum elsewhere in the system to detect lost writes.
==一些系统在系统的其他位置添加校验和来检测丢失写入。==

For example, Sun’s **Zettabyte File System (ZFS)** includes a checksum in each file system inode and indirect block.
==例如，Sun 的 **Zettabyte 文件系统 (ZFS)** 在每个文件系统索引节点 (inode) 和间接块中都包含一个校验和。==

Scrubbing
==清理（Scrubbing）==

To remedy this problem, many systems utilize **disk scrubbing** of various forms.
==为了补救这个问题，许多系统利用各种形式的**磁盘清理**。==

By periodically reading through *every* block of the system, and checking whether checksums are still valid, the disk system can reduce the chances that all copies of a certain data item become corrupted.
==通过定期读取系统的*每一个*块并检查校验和是否仍然有效，磁盘系统可以降低某个数据项的所有副本都损坏的概率。==

Overheads Of Checksumming
==校验和的开销==

There are two distinct kinds of overheads: space and time.
==存在两种截然不同的开销：空间和时间。==

Space overheads come in two forms: on the disk itself and in the memory of the system.
==空间开销有两种形式：在磁盘本身和在系统的内存中。==

The time overheads induced by checksumming can be quite noticeable.
==由校验和引起的时间开销可能相当明显。==

Minimally, the CPU must compute the checksum over each block, both when the data is stored and when it is accessed.
==至少，CPU 必须在数据存储和访问时对每个块计算校验和。==




**A Dialogue on Distribution**
==**关于分布式的对话**==

**Professor:** And thus we reach our final little piece in the world of operating systems: distributed systems.
==**教授：** 这样我们就来到了操作系统世界的最后一块拼图：分布式系统。==

Since we can’t cover much here, we’ll sneak in a little intro here in the section on persistence, and focus mostly on distributed file systems.
==**教授：** 既然我们无法在此涵盖太多内容，我们就在持久化章节中悄悄加入一点介绍，并主要关注分布式文件系统。==

Hope that is OK!
==**教授：** 希望这没问题！==

**Student:** Sounds OK.
==**学生：** 听起来不错。==

But what is a distributed system exactly, oh glorious and all-knowing professor?
==**学生：** 但是，光荣且无所不知的教授，分布式系统到底是什么呢？==

**Professor:** Well, I bet you know how this is going to go...
==**教授：** 嗯，我敢打赌你知道接下来的路数……==

**Student:** There’s a peach?
==**学生：** 又是关于桃子的比喻？==

**Professor:** Exactly!
==**教授：** 没错！==

But this time, it’s far away from you, and may take some time to get the peach.
==**教授：** 但这一次，桃子离你很远，可能需要一些时间才能拿到它。==

And there are a lot of them!
==**教授：** 而且桃子的数量有很多！==

Even worse, sometimes a peach becomes rotten.
==**教授：** 更糟糕的是，有时桃子会变质。==

But you want to make sure that when anybody bites into a peach, they will get a mouthful of deliciousness.
==**教授：** 但你要确保当任何人咬下一口桃子时，他们都能尝到满口的美味。==

**Student:** This peach analogy is working less and less for me.
==**学生：** 这个桃子的类比对我来说越来越不管用了。==

**Professor:** Come on!
==**教授：** 别这样！==

It’s the last one, just go with it.
==**教授：** 这是最后一个了，就随它去吧。==

**Student:** Fine.
==**学生：** 行吧。==

**Professor:** So anyhow, forget about the peaches.
==**教授：** 那么不管怎样，忘掉桃子吧。==

Building distributed systems is hard, because things fail all the time.
==**教授：** 构建分布式系统很困难，因为故障无处不在。==

Messages get lost, machines go down, disks corrupt data.
==**教授：** 消息会丢失，机器会宕机，磁盘会损坏数据。==

It’s like the whole world is working against you!
==**教授：** 就像整个世界都在与你作对！==

**Student:** But I use distributed systems all the time, right?
==**学生：** 但我一直在使用分布式系统，对吧？==

**Professor:** Yes! You do. And... ?
==**教授：** 是的！你确实在用。然后呢……？==

**Student:** Well, it seems like they mostly work.
==**学生：** 嗯，看起来它们大部分时间都能正常工作。==

After all, when I send a search request to Google, it usually comes back in a snap, with some great results!
==**学生：** 毕竟，当我向 Google 发送搜索请求时，它通常很快就会返回一些很棒的结果！==

Same thing when I use Facebook, Amazon, and so forth.
==**学生：** 当我使用 Facebook、Amazon 等也是一样。==

**Professor:** Yes, it is amazing.
==**教授：** 是的，这确实很神奇。==

And that’s despite all of those failures taking place!
==**教授：** 而且这是在所有这些故障都在发生的情况下实现的！==

Those companies build a huge amount of machinery into their systems so as to ensure that even though some machines have failed, the entire system stays up and running.
==**教授：** 这些公司在系统中构建了大量的机制，以确保即使某些机器发生故障，整个系统仍能保持运行。==

They use a lot of techniques to do this: replication, retry, and various other tricks people have developed over time to detect and recover from failures.
==**教授：** 他们使用了很多技术来实现这一点：复制、重试以及人们随时间推移开发的各种用于检测故障并从中恢复的其他技巧。==

**Student:** Sounds interesting. Time to learn something for real?
==**学生：** 听起来很有趣。是时候学点真本事了吗？==

**Professor:** It does seem so. Let’s get to work!
==**教授：** 看起来确实如此。让我们开始干活吧！==

But first things first ... (bites into peach he has been holding, which unfortunately is rotten)
==**教授：** 但首先……（咬了一口他一直拿着的桃子，不幸的是，它是烂的）==

**Distributed Systems**
==**分布式系统**==

Distributed systems have changed the face of the world.
==**分布式系统已经改变了世界的面貌。**==

When your web browser connects to a web server somewhere else on the planet, it is participating in what seems to be a simple form of a **client/server** distributed system.
==**当你的浏览器连接到地球上其他地方的 Web 服务器时，它正在参与一种看似简单的“客户端/服务器” (client/server) 形式的分布式系统。**==

When you contact a modern web service such as Google or Facebook, you are not just interacting with a single machine, however; behind the scenes, these complex services are built from a large collection (i.e., thousands) of machines, each of which cooperate to provide the particular service of the site.
==**然而，当你接触 Google 或 Facebook 等现代 Web 服务时，你并不仅仅是在与单台机器交互；在幕后，这些复杂的服务是由大量（即数以千计）机器组成的集群构建的，每台机器都协同工作以提供该站点的特定服务。**==

Thus, it should be clear what makes studying distributed systems interesting.
==**因此，研究分布式系统的趣味所在应该是显而易见的。**==

Indeed, it is worthy of an entire class; here, we just introduce a few of the major topics.
==**事实上，它值得专门开设一门课程；在这里，我们只介绍几个主要的主题。**==

A number of new challenges arise when building a distributed system.
==**构建分布式系统时会出现许多新的挑战。**==

The major one we focus on is **failure**; machines, disks, networks, and software all fail from time to time, as we do not (and likely, will never) know how to build “perfect” components and systems.
==**我们关注的主要挑战是“故障” (failure)；机器、磁盘、网络和软件都会不时发生故障，因为我们不知道（而且可能永远也不会知道）如何构建“完美的”组件和系统。**==

However, when we build a modern web service, we’d like it to appear to clients as if it never fails; how can we accomplish this task?
==**然而，当我们构建现代 Web 服务时，我们希望它在客户端看来好像从未发生故障；我们该如何完成这项任务？**==

**THE CRUX: HOW TO BUILD SYSTEMS THAT WORK WHEN COMPONENTS FAIL**
==**核心问题：如何构建在组件故障时仍能正常工作的系统**==

How can we build a working system out of parts that don’t work correctly all the time?
==**我们如何利用那些并非始终能正确工作的部件构建出一个可运行的系统？**==

The basic question should remind you of some of the topics we discussed in RAID storage arrays; however, the problems here tend to be more complex, as are the solutions.
==**这个基本问题应该会让你想起我们在 RAID 存储阵列中讨论过的一些话题；然而，这里的问题往往更复杂，解决方案也是如此。**==

Interestingly, while failure is a central challenge in constructing distributed systems, it also represents an opportunity.
==**有趣的是，虽然故障是构建分布式系统的核心挑战，但它也代表着一种机遇。**==

Yes, machines fail; but the mere fact that a machine fails does not imply the entire system must fail.
==**是的，机器会故障；但单台机器故障并不意味着整个系统必须崩溃。**==

By collecting together a set of machines, we can build a system that appears to rarely fail, despite the fact that its components fail regularly.
==**通过将一组机器聚集在一起，我们可以构建一个看似极少发生故障的系统，尽管其组件经常发生故障。**==

This reality is the central beauty and value of distributed systems, and why they underlie virtually every modern web service you use, including Google, Facebook, etc.
==**这一现实是分布式系统的核心美学和价值所在，也是为什么它们成为了你所使用的几乎每一个现代 Web 服务（包括 Google、Facebook 等）的基础。**==

**TIP: COMMUNICATION IS INHERENTLY UNRELIABLE**
==**提示：通信本质上是不可靠的**==

In virtually all circumstances, it is good to view communication as a fundamentally unreliable activity.
==**在几乎所有情况下，将通信视为一种本质上不可靠的行为是很有益处的。**==

Bit corruption, down or non-working links and machines, and lack of buffer space for incoming packets all lead to the same result: packets sometimes do not reach their destination.
==**位损坏、链路或机器宕机或无法工作，以及由于接收数据包的缓冲空间不足，都会导致相同的结果：数据包有时无法到达目的地。**==

To build reliable services atop such unreliable networks, we must consider techniques that can cope with packet loss.
==**为了在如此不可靠的网络之上构建可靠的服务，我们必须考虑能够应对数据包丢失的技术。**==

Other important issues exist as well.
==**此外还存在其他重要问题。**==

System **performance** is often critical; with a network connecting our distributed system together, system designers must often think carefully about how to accomplish their given tasks, trying to reduce the number of messages sent and further make communication as efficient (low latency, high bandwidth) as possible.
==**系统“性能” (performance) 通常至关重要；在将分布式系统连接在一起的网络中，系统设计者必须经常仔细思考如何完成既定任务，设法减少发送的消息数量，并进一步使通信尽可能高效（低延迟、高带宽）。**==

Finally, **security** is also a necessary consideration.
==**最后，“安全性” (security) 也是必须考虑的因素。**==

When connecting to a remote site, having some assurance that the remote party is who they say they are becomes a central problem.
==**当连接到远程站点时，确保对方的身份真实可靠成为了一个核心问题。**==

Further, ensuring that third parties cannot monitor or alter an on-going communication between two others is also a challenge.
==**此外，确保第三方无法监控或篡改两者之间正在进行的通信也是一项挑战。**==

In this introduction, we’ll cover the most basic aspect that is new in a distributed system: **communication**.
==**在此介绍中，我们将涵盖分布式系统中最新颖、最基础的方面：“通信” (communication)。**==

Namely, how should machines within a distributed system communicate with one another?
==**换句话说，分布式系统中的机器应该如何相互通信？**==

We’ll start with the most basic primitives available, messages, and build a few higher-level primitives on top of them.
==**我们将从最基础的原语“消息” (messages) 开始，并在其之上构建一些高级原语。**==

As we said above, failure will be a central focus: how should communication layers handle failures?
==**正如我们上面所说的，故障将是核心关注点：通信层应该如何处理故障？**==

**48.1 Communication Basics**
==**48.1 通信基础**==

The central tenet of modern networking is that communication is fundamentally unreliable.
==**现代网络的中心原则是通信本质上是不可靠的。**==

Whether in the wide-area Internet, or a local-area high-speed network such as Infiniband, packets are regularly lost, corrupted, or otherwise do not reach their destination.
==**无论是在广域互联网，还是在诸如 Infiniband 之类的局域高速网络中，数据包都会经常丢失、损坏或由于其他原因无法到达目的地。**==

There are a multitude of causes for packet loss or corruption.
==**导致数据包丢失或损坏的原因有很多。**==

Sometimes, during transmission, some bits get flipped due to electrical or other similar problems.
==**有时，在传输过程中，由于电气或其他类似问题，某些位会发生翻转。**==

Sometimes, an element in the system, such as a network link or packet router or even the remote host, are somehow damaged or otherwise not working correctly; network cables do accidentally get severed, at least sometimes.
==**有时，系统中的某个元件（如网络链路、数据包路由器甚至远程主机）由于某种原因损坏或无法正常工作；网线确实会发生意外断裂，至少有时会这样。**==

More fundamental however is packet loss due to lack of buffering within a network switch, router, or endpoint.
==**然而，更根本的原因是由于网络交换机、路由器或端点内部缺乏缓冲空间导致的数据包丢失。**==

Specifically, even if we could guarantee that all links worked correctly, and that all the components in the system (switches, routers, end hosts) were up and running as expected, loss is still possible, for the following reason.
==**具体来说，即使我们可以保证所有链路都能正确工作，并且系统中的所有组件（交换机、路由器、终端主机）都按预期运行，丢失仍然是可能的，原因如下。**==

Imagine a packet arrives at a router; for the packet to be processed, it must be placed in memory somewhere within the router.
==**想象一个数据包到达路由器；为了处理该数据包，必须将其放置在路由器内的某个内存位置。**==

If many such packets arrive at once, it is possible that the memory within the router cannot accommodate all of the packets.
==**如果许多此类数据包同时到达，路由器的内存可能无法容纳所有数据包。**==

The only choice the router has at that point is to **drop** one or more of the packets.
==**此时路由器唯一的选择就是“丢弃” (drop) 一个或多个数据包。**==

This same behavior occurs at end hosts as well; when you send a large number of messages to a single machine, the machine’s resources can easily become overwhelmed, and thus packet loss again arises.
==**这种行为在终端主机上也会发生；当你向单台机器发送大量消息时，该机器的资源很容易变得过载，从而再次导致数据包丢失。**==

Thus, packet loss is fundamental in networking.
==**因此，数据包丢失是网络中根本性的问题。**==

The question thus becomes: how should we deal with it?
==**于是问题变成了：我们该如何处理它？**==

**48.2 Unreliable Communication Layers**
==**48.2 不可靠通信层**==

One simple way is this: we don’t deal with it.
==**一种简单的方法是：我们不处理它。**==

Because some applications know how to deal with packet loss, it is sometimes useful to let them communicate with a basic unreliable messaging layer, an example of the **end-to-end argument** one often hears about (see the Aside at end of chapter).
==**因为某些应用程序知道如何处理数据包丢失，所以有时让它们通过基础的不可靠消息层进行通信是有用的，这是人们经常听到的“端到端论点” (end-to-end argument) 的一个例子（见本章末尾的侧边栏）。**==

One excellent example of such an unreliable layer is found in the **UDP/IP** networking stack available today on virtually all modern systems.
==**这种不可靠层的一个极好例子是当今几乎所有现代系统上都可用的 UDP/IP 网络协议栈。**==

To use UDP, a process uses the **sockets** API in order to create a communication endpoint; processes on other machines (or on the same machine) send UDP **datagrams** to the original process (a datagram is a fixed-sized message up to some max size).
==**为了使用 UDP，进程使用套接字 (sockets) API 来创建一个通信端点；其他机器上（或同一台机器上）的进程向原始进程发送 UDP“数据报” (datagrams)（数据报是具有一定最大尺寸限制的固定大小的消息）。**==

UDP is a great example of an unreliable communication layer.
==**UDP 是不可靠通信层的一个典型例子。**==

If you use it, you will encounter situations where packets get lost (dropped) and thus do not reach their destination; the sender is never thus informed of the loss.
==**如果你使用它，你会遇到数据包丢失（被丢弃）从而无法到达目的地的情况；发送方永远不会被告知这种丢失。**==

However, that does not mean that UDP does not guard against any failures at all.
==**然而，这并不意味着 UDP 完全不防范任何故障。**==

For example, UDP includes a **checksum** to detect some forms of packet corruption.
==**例如，UDP 包含一个“校验和” (checksum) 以检测某些形式的数据包损坏。**==

**TIP: USE CHECKSUMS FOR INTEGRITY**
==**提示：使用校验和保证完整性**==

Checksums are a commonly-used method to detect corruption quickly and effectively in modern systems.
==**校验和是现代系统中快速有效地检测损坏的常用方法。**==

A simple checksum is addition: just sum up the bytes of a chunk of data; of course, many other more sophisticated checksums have been created, including basic cyclic redundancy codes (CRCs), the Fletcher checksum, and many others [MK09].
==**一种简单的校验和是加法：只需将一块数据的字节相加；当然，人们已经开发出许多其他更复杂的校验和，包括循环冗余校验 (CRC)、Fletcher 校验和等 [MK09]。**==

In networking, checksums are used as follows.
==**在网络中，校验和的使用方式如下。**==

Before sending a message from one machine to another, compute a checksum over the bytes of the message.
==**在将消息从一台机器发送到另一台之前，计算该消息字节的校验和。**==

Then send both the message and the checksum to the destination.
==**然后将消息和校验和同时发送到目的地。**==

At the destination, the receiver computes a checksum over the incoming message as well; if this computed checksum matches the sent checksum, the receiver can feel some assurance that the data likely did not get corrupted during transmission.
==**在目的地，接收者同样对接收到的消息计算校验和；如果计算出的校验和与发送的校验和匹配，接收者就可以在一定程度上确信数据在传输过程中很可能没有损坏。**==

However, because many applications simply want to send data to a destination and not worry about packet loss, we need more.
==**然而，由于许多应用程序只是想向目的地发送数据而不必担心数据包丢失，我们需要更多的机制。**==

Specifically, we need reliable communication on top of an unreliable network.
==**具体来说，我们需要在不可靠的网络之上建立可靠的通信。**==

**48.3 Reliable Communication Layers**
==**48.3 可靠通信层**==

To build a reliable communication layer, we need some new mechanisms and techniques to handle packet loss.
==**为了构建可靠的通信层，我们需要一些新的机制和技术来处理数据包丢失。**==

The technique that we will use is known as an **acknowledgment**, or **ack** for short.
==**我们将使用的技术被称为“确认” (acknowledgment)，简称为 ack。**==

The idea is simple: the sender sends a message to the receiver; the receiver then sends a short message back to acknowledge its receipt.
==**这个想法很简单：发送方给接收方发送一条消息；接收方随后发回一条简短的消息以确认已收到。**==

When the sender receives an acknowledgment of the message, it can then rest assured that the receiver did indeed receive the original message.
==**当发送方收到消息的确认时，它就可以放心，接收方确实收到了原始消息。**==

However, what should the sender do if it does not receive an acknowledgment?
==**然而，如果发送方没有收到确认，它该怎么办？**==

To handle this case, we need an additional mechanism, known as a **timeout**.
==**为了处理这种情况，我们需要一个额外的机制，称为“超时” (timeout)。**==

When the sender sends a message, the sender now sets a timer to go off after some period of time.
==**当发送方发送消息时，它会设置一个定时器，在一段时间后触发。**==

If, in that time, no acknowledgment has been received, the sender concludes that the message has been lost.
==**如果在该时间内没有收到确认，发送方就会判定消息已丢失。**==

The sender then simply performs a **retry** of the send, sending the same message again with hopes that this time, it will get through.
==**随后，发送方只需进行“重试” (retry) 发送，再次发送相同的消息，并希望这次能够成功通过。**==

For this approach to work, the sender must keep a copy of the message around, in case it needs to send it again.
==**为了使这种方法奏效，发送方必须保留消息的副本，以备需要再次发送时使用。**==

The combination of the timeout and the retry have led some to call the approach **timeout/retry**.
==**超时和重试的结合使得有些人将这种方法称为“超时/重试” (timeout/retry)。**==

Unfortunately, timeout/retry in this form is not quite enough.
==**不幸的是，这种形式的超时/重试还不够完善。**==

Figure 48.5 shows an example of packet loss which could lead to trouble.
==**图 48.5 展示了一个可能导致麻烦的数据包丢失示例。**==

In this example, it is not the original message that gets lost, but the acknowledgment.
==**在这个例子中，丢失的不是原始消息，而是确认信息 (ack)。**==

From the perspective of the sender, the situation seems the same: no ack was received, and thus a timeout and retry are in order.
==**从发送方的角度来看，情况似乎是一样的：没有收到 ack，因此需要进行超时和重试。**==

But from the perspective of the receiver, it is quite different: now the same message has been received twice!
==**但从接收方的角度来看，情况大不相同：现在同一条消息被接收了两次！**==

Thus, when we are aiming for a reliable message layer, we also usually want to guarantee that each message is received **exactly once** by the receiver.
==**因此，当我们的目标是构建可靠的消息层时，通常还希望保证每条消息被接收方“精确接收一次” (exactly once)。**==

To enable the receiver to detect duplicate message transmission, the sender has to identify each message in some unique way, and the receiver needs some way to track whether it has already seen each message before.
==**为了让接收方能够检测到重复的消息传输，发送方必须以某种唯一的方式标识每条消息，而接收方需要某种方法来追踪之前是否已经见过该消息。**==

A simpler approach, requiring little memory, solves this problem, and the mechanism is known as a **sequence counter**.
==**一种需要极少内存的更简单方法可以解决这个问题，该机制被称为“序列计数器” (sequence counter)。**==

With a sequence counter, the sender and receiver agree upon a start value (e.g., 1) for a counter that each side will maintain.
==**通过序列计数器，发送方和接收方约定一个初始值（例如 1），双方各自维护一个计数器。**==

Whenever a message is sent, the current value of the counter is sent along with the message; this counter value ($N$) serves as an ID for the message.
==**每当发送消息时，计数器的当前值会随消息一起发送；该计数器值 ($N$) 充当消息的 ID。**==

After the message is sent, the sender then increments the value (to $N + 1$).
==**消息发送后，发送方随后递增该值（变为 $N + 1$）。**==

The receiver uses its counter value as the expected value for the ID of the incoming message from that sender.
==**接收方使用其自身的计数器值作为预期从该发送方收到的下一条消息的 ID。**==

If the ID of a received message ($N$) matches the receiver’s counter (also $N$), it acks the message and passes it up to the application; in this case, the receiver concludes this is the first time this message has been received.
==**如果接收到的消息 ID ($N$) 与接收方的计数器（也是 $N$）匹配，它会确认该消息并将其传递给应用程序；在这种情况下，接收方判定这是第一次收到该消息。**==

The receiver then increments its counter (to $N + 1$), and waits for the next message.
==**接收方随后递增其计数器（变为 $N + 1$），并等待下一条消息。**==

If the ack is lost, the sender will timeout and re-send message $N$.
==**如果 ack 丢失，发送方将超时并重新发送消息 $N$。**==

This time, the receiver’s counter is higher ($N + 1$), and thus the receiver knows it has already received this message.
==**这一次，接收方的计数器更高（$N + 1$），因此接收方知道它已经收到过这条消息。**==

Thus it acks the message but does **not** pass it up to the application.
==**因此，它会确认该消息，但“不会”将其传递给应用程序。**==

The most commonly used reliable communication layer is known as **TCP/IP**, or just **TCP** for short.
==**最常用的可靠通信层被称为 TCP/IP，简称为 TCP。**==

**TIP: BE CAREFUL SETTING THE TIMEOUT VALUE**
==**提示：小心设置超时值**==

As you can probably guess from the discussion, setting the timeout value correctly is an important aspect of using timeouts to retry message sends.
==**正如你可能从讨论中猜到的那样，正确设置超时值是使用超时重试消息发送的一个重要方面。**==

If the timeout is too small, the sender will re-send messages needlessly, thus wasting CPU time on the sender and network resources.
==**如果超时值太小，发送方会不必要地重发消息，从而浪费发送方的 CPU 时间和网络资源。**==

If the timeout is too large, the sender waits too long to re-send and thus perceived performance at the sender is reduced.
==**如果超时值太大，发送方等待重发的时间过长，从而降低了发送方感知的性能。**==

In a scenario with many clients sending to a single server, packet loss at the server may be an indicator that the server is overloaded.
==**在许多客户端向单个服务器发送请求的场景中，服务器端的数据包丢失可能表明服务器已过载。**==

If true, clients might retry in a different adaptive manner; for example, after the first timeout, a client might increase its timeout value to a higher amount, perhaps twice as high as the original value.
==**如果是这样，客户端可能会以不同的自适应方式进行重试；例如，在第一次超时后，客户端可能会将超时值增加到更高的数值，或许是原始值的两倍。**==

Such an **exponential back-off** scheme avoids situations where resources are being overloaded by an excess of re-sends.
==**这种“指数退避” (exponential back-off) 方案避免了因过度重发而导致资源过载的情况。**==

**48.4 Communication Abstractions**
==**48.4 通信抽象**==

Given a basic messaging layer, we now approach the next question in this chapter: what abstraction of communication should we use when building a distributed system?
==**有了基础的消息层后，我们现在探讨本章的下一个问题：在构建分布式系统时，我们应该使用什么样的通信抽象？**==

One body of work took OS abstractions and extended them to operate in a distributed environment.
==**有一类研究采用了操作系统的抽象，并将其扩展到分布式环境中运行。**==

For example, **distributed shared memory (DSM)** systems enable processes on different machines to share a large, virtual address space [LH89].
==**例如，“分布式共享内存” (DSM) 系统使不同机器上的进程能够共享一个大型虚拟地址空间 [LH89]。**==

This approach is not widely in use today for a number of reasons.
==**由于种种原因，这种方法在今天并未被广泛使用。**==

The largest problem for DSM is how it handles failure.
==**DSM 面临的最大问题是它如何处理故障。**==

Imagine, for example, if a machine fails; what happens to the pages on that machine?
==**想象一下，例如，如果一台机器发生故障，该机器上的页面会发生什么？**==

Dealing with failure when parts of your address space go missing is hard; imagine a linked list where a “next” pointer points into a portion of the address space that is gone. Yikes!
==**当地址空间的一部分消失时，处理故障是非常困难的；想象一个链表，其中的“下一个”指针指向了已经消失的那部分地址空间。哎呀！**==

**48.5 Remote Procedure Call (RPC)**
==**48.5 远程过程调用 (RPC)**==

The most dominant abstraction is based on the idea of a **remote procedure call**, or **RPC** for short [BN84].
==**最主流的抽象是基于“远程过程调用” (remote procedure call) 的理念，简称 RPC [BN84]。**==

Remote procedure call packages all have a simple goal: to make the process of executing code on a remote machine as simple and straightforward as calling a local function.
==**远程过程调用软件包都有一个简单的目标：使在远程机器上执行代码的过程就像调用本地函数一样简单直接。**==

The RPC system generally has two pieces: a **stub generator** (sometimes called a **protocol compiler**), and the **run-time library**.
==**RPC 系统通常包含两个部分：一个“存根生成器” (stub generator)（有时称为协议编译器）和“运行时库” (run-time library)。**==

**Stub Generator**
==**存根生成器**==

The stub generator’s job is simple: to remove some of the pain of packing function arguments and results into messages by automating it.
==**存根生成器的任务很简单：通过自动化来减轻将函数参数和结果打包进消息的痛苦。**==

For the client, a **client stub** is generated, which contains each of the functions specified in the interface.
==**对于客户端，会生成一个“客户端存根” (client stub)，其中包含接口中指定的每个函数。**==

Internally, the code in the client stub does this:
==**在内部，客户端存根中的代码执行以下操作：**==

*   **Create a message buffer.**
==    **创建消息缓冲区。**==
*   **Pack the needed information into the message buffer.** This process is sometimes referred to as the **marshaling** of arguments or the **serialization** of the message.
==    **将所需信息打包进消息缓冲区。** 该过程有时被称为参数的“编组” (marshaling) 或消息的“序列化” (serialization)。==
*   **Send the message to the destination RPC server.**
==    **将消息发送到目标 RPC 服务器。**==
*   **Wait for the reply.** Because function calls are usually **synchronous**, the call will wait for its completion.
==    **等待回复。** 因为函数调用通常是“同步” (synchronous) 的，所以调用将等待其完成。==
*   **Unpack return code and other arguments.** This step is also known as **unmarshaling** or **deserialization**.
==    **解包返回码和其他参数。** 此步骤也称为“解组” (unmarshaling) 或“反序列化” (deserialization)。==
*   **Return to the caller.**
==    **返回给调用者。**==

**Run-Time Library**
==**运行时库**==

The run-time library handles much of the heavy lifting in an RPC system; most performance and reliability issues are handled herein.
==**运行时库负责 RPC 系统中大部分繁重的工作；大多数性能和可靠性问题都在此处处理。**==

One of the first challenges we must overcome is how to locate a remote service. This problem, of **naming**, is a common one in distributed systems.
==**我们必须克服的首要挑战之一是如何定位远程服务。这个“命名” (naming) 问题在分布式系统中很常见。**==

Once a client knows which server it should talk to, the next question is which transport-level protocol should RPC be built upon.
==**一旦客户端知道它应该与哪台服务器通信，接下来的问题是 RPC 应该构建在哪个传输层协议之上。**==

Many RPC packages are built on top of unreliable communication layers, such as UDP.
==**许多 RPC 软件包构建在不可靠的通信层（如 UDP）之上。**==

Doing so enables a more efficient RPC layer, but does add the responsibility of providing reliability to the RPC system.
==**这样做可以实现更高效的 RPC 层，但确实增加了为 RPC 系统提供可靠性的责任。**==

**Aside: THE END-TO-END ARGUMENT**
==**侧边栏：端到端论点**==

The **end-to-end argument** makes the case that the highest level in a system, i.e., usually the application at “the end”, is ultimately the only locale within a layered system where certain functionality can truly be implemented.
==**“端到端论点” (end-to-end argument) 认为，系统中的最高层（即通常位于“端点”的应用程序）最终是分层系统中唯一可以真正实现某些功能的场所。**==

**48.6 Summary**
==**48.6 总结**==

We have seen the introduction of a new topic, distributed systems, and its major issue: how to handle failure which is now a commonplace event.
==**我们已经介绍了分布式系统这一新课题及其核心问题：如何处理现在已成为家常便饭的故障。**==

The key to any distributed system is how you deal with that failure.
==**任何分布式系统的关键都在于你如何应对这种故障。**==

Communication forms the heart of any distributed system.
==**通信构成了任何分布式系统的核心。**==

A common abstraction of that communication is found in remote procedure call (RPC), which enables clients to make remote calls on servers.
==**这种通信的一种常见抽象是远程过程调用 (RPC)，它使客户端能够对服务器进行远程调用。**==




49 Sun’s Network File System (NFS)
==49 Sun 的网络文件系统 (NFS)==

One of the first uses of distributed client/server computing was in the realm of distributed file systems.
==分布式客户端/服务器计算最早的应用之一是在分布式文件系统领域。==

In such an environment, there are a number of client machines and one server (or a few); the server stores the data on its disks, and clients request data through well-formed protocol messages.
==在这种环境中，存在若干客户端机器和一个（或少数几个）服务器；服务器将数据存储在其磁盘上，客户端通过格式良好的协议消息请求数据。==

Figure 49.1 depicts the basic setup.
==图 49.1 描述了这种基本设置。==

As you can see from the picture, the server has the disks, and clients send messages across a network to access their directories and files on those disks.
==正如你从图中看到的，服务器拥有磁盘，客户端通过网络发送消息来访问这些磁盘上的目录和文件。==

Why do we bother with this arrangement? (i.e., why don’t we just let clients use their local disks?)
==我们为什么要费心采用这种安排？（即，为什么我们不直接让客户端使用它们的本地磁盘呢？）==

Well, primarily this setup allows for easy sharing of data across clients.
==嗯，这种设置主要是为了方便客户端之间的数据共享。==

Thus, if you access a file on one machine (Client 0) and then later use another (Client 2), you will have the same view of the file system.
==因此，如果你在其中一台机器（客户端 0）上访问一个文件，稍后使用另一台（客户端 2），你将拥有相同的文件系统视图。==

Your data is naturally shared across these different machines.
==你的数据在这些不同的机器之间自然地共享。==

A secondary benefit is centralized administration; for example, backing up files can be done from the few server machines instead of from the multitude of clients.
==次要的好处是集中管理；例如，备份文件可以从少数几台服务器机器上完成，而不是从众多的客户端上完成。==

Another advantage could be security; having all servers in a locked machine room prevents certain types of problems from arising.
==另一个优点可能是安全性；将所有服务器放在锁定的机房中可以防止某些类型问题的发生。==

CRUX: HOW TO BUILD A DISTRIBUTED FILE SYSTEM
==核心问题：如何构建分布式文件系统==

How do you build a distributed file system?
==你如何构建一个分布式文件系统？==

What are the key aspects to think about?
==需要考虑的关键方面有哪些？==

What is easy to get wrong?
==哪些地方容易出错？==

What can we learn from existing systems?
==我们可以从现有系统中学习到什么？==

49.1 A Basic Distributed File System
==49.1 基础分布式文件系统==

We now will study the architecture of a simplified distributed file system.
==我们现在将研究一个简化的分布式文件系统的架构。==

A simple client/server distributed file system has more components than the file systems we have studied so far.
==一个简单的客户端/服务器分布式文件系统比我们目前研究过的文件系统拥有更多的组件。==

On the client side, there are client applications which access files and directories through the client-side file system.
==在客户端，有通过客户端文件系统访问文件和目录的客户端应用程序。==

A client application issues system calls to the client-side file system (such as `open()`, `read()`, `write()`, `close()`, `mkdir()`, etc.) in order to access files which are stored on the server.
==客户端应用程序向客户端文件系统发出系统调用（如 `open()`、`read()`、`write()`、`close()`、`mkdir()` 等），以便访问存储在服务器上的文件。==

Thus, to client applications, the file system does not appear to be any different than a local (disk-based) file system, except perhaps for performance; in this way, distributed file systems provide transparent access to files, an obvious goal; after all, who would want to use a file system that required a different set of APIs or otherwise was a pain to use?
==因此，对于客户端应用程序来说，除了性能之外，该文件系统看起来与本地（基于磁盘的）文件系统没有任何区别；通过这种方式，分布式文件系统提供了对文件的透明访问，这是一个显而易见的目标；毕竟，谁会想使用一个需要不同 API 集或者使用起来很痛苦的文件系统呢？==

The role of the client-side file system is to execute the actions needed to service those system calls.
==客户端文件系统的作用是执行服务这些系统调用所需的操作。==

For example, if the client issues a `read()` request, the client-side file system may send a message to the server-side file system (or, as it is commonly called, the file server) to read a particular block; the file server will then read the block from disk (or its own in-memory cache), and send a message back to the client with the requested data.
==例如，如果客户端发出 `read()` 请求，客户端文件系统可能会向服务器端文件系统（或者通常称为文件服务器）发送消息以读取特定数据块；文件服务器随后将从磁盘（或其自身的内存缓存）中读取该块，并将包含请求数据的消息发送回客户端。==

The client-side file system will then copy the data into the user buffer supplied to the `read()` system call and thus the request will complete.
==客户端文件系统随后将数据复制到提供给 `read()` 系统调用的用户缓冲区中，从而完成请求。==

Note that a subsequent `read()` of the same block on the client may be cached in client memory or on the client’s disk even; in the best such case, no network traffic need be generated.
==请注意，随后在客户端上对同一块进行的 `read()` 可能会被缓存在客户端内存甚至客户端磁盘中；在最好的情况下，不需要产生任何网络流量。==

Figure 49.2: Distributed File System Architecture
==图 49.2：分布式文件系统架构==

From this simple overview, you should get a sense that there are two important pieces of software in a client/server distributed file system: the client-side file system and the file server.
==通过这个简单的概述，你应该能感觉到客户端/服务器分布式文件系统中有两个重要的软件部分：客户端文件系统和文件服务器。==

Together their behavior determines the behavior of the distributed file system.
==它们的行为共同决定了分布式文件系统的行为。==

Now it’s time to study one particular system: Sun’s Network File System (NFS).
==现在是时候研究一个特定的系统了：Sun 的网络文件系统 (NFS)。==

ASIDE: WHY SERVERS CRASH
==旁注：服务器为什么会崩溃==

Before getting into the details of the NFSv2 protocol, you might be wondering: why do servers crash?
==在深入探讨 NFSv2 协议的细节之前，你可能会想：服务器为什么会崩溃？==

Well, as you might guess, there are plenty of reasons.
==嗯，正如你所料，原因有很多。==

Servers may simply suffer from a power outage (temporarily); only when power is restored can the machines be restarted.
==服务器可能只是遭受了（暂时的）停电；只有当电力恢复后，机器才能重新启动。==

Servers are often comprised of hundreds of thousands or even millions of lines of code; thus, they have bugs (even good software has a few bugs per hundred or thousand lines of code), and thus they eventually will trigger a bug that will cause them to crash.
==服务器通常由数十万甚至数百万行代码组成；因此，它们存在漏洞（即使是好的软件，每百行或千行代码中也会有一些漏洞），因此它们最终会触发一个导致崩溃的漏洞。==

They also have memory leaks; even a small memory leak will cause a system to run out of memory and crash.
==它们还存在内存泄漏；即使是一个很小的内存泄漏也会导致系统耗尽内存并崩溃。==

And, finally, in distributed systems, there is a network between the client and the server; if the network acts strangely (for example, if it becomes partitioned and clients and servers are working but cannot communicate), it may appear as if a remote machine has crashed, but in reality it is just not currently reachable through the network.
==最后，在分布式系统中，客户端和服务器之间存在网络；如果网络表现异常（例如，如果它发生了分区，客户端和服务器都在运行但无法通信），看起来就像远程机器崩溃了，但实际上它只是目前无法通过网络到达。==

49.2 On To NFS
==49.2 转向 NFS==

One of the earliest and quite successful distributed systems was developed by Sun Microsystems, and is known as the Sun Network File System (or NFS) [S86].
==最早且相当成功的分布式系统之一是由 Sun Microsystems 开发的，被称为 Sun 网络文件系统（或 NFS）[S86]。==

In defining NFS, Sun took an unusual approach: instead of building a proprietary and closed system, Sun instead developed an **open protocol** which simply specified the exact message formats that clients and servers would use to communicate.
==在定义 NFS 时，Sun 采取了一种不同寻常的方法：Sun 没有构建专有且封闭的系统，而是开发了一种**开放协议**，该协议只是指定了客户端和服务器用于通信的确切消息格式。==

Different groups could develop their own NFS servers and thus compete in an NFS marketplace while preserving interoperability.
==不同的团体可以开发他们自己的 NFS 服务器，从而在保持互操作性的同时在 NFS 市场中竞争。==

It worked: today there are many companies that sell NFS servers (including Oracle/Sun, NetApp [HLM94], EMC, IBM, and others), and the widespread success of NFS is likely attributed to this “open market” approach.
==它奏效了：今天有许多公司销售 NFS 服务器（包括 Oracle/Sun、NetApp [HLM94]、EMC、IBM 等），NFS 的广泛成功可能归功于这种“开放市场”的方法。==

49.3 Focus: Simple And Fast Server Crash Recovery
==49.3 焦点：简单快速的服务器崩溃恢复==

In this chapter, we will discuss the classic NFS protocol (version 2, a.k.a. NFSv2), which was the standard for many years; small changes were made in moving to NFSv3, and larger-scale protocol changes were made in moving to NFSv4.
==在本章中，我们将讨论经典的 NFS 协议（第 2 版，又名 NFSv2），它曾是多年的标准；在转向 NFSv3 时做了微小的改动，在转向 NFSv4 时进行了更大规模的协议更改。==

However, NFSv2 is both wonderful and frustrating and thus serves as our focus.
==然而，NFSv2 既美妙又令人沮丧，因此它是我们的重点。==

In NFSv2, the main goal in the design of the protocol was **simple and fast server crash recovery**.
==在 NFSv2 中，协议设计的主要目标是**简单快速的服务器崩溃恢复**。==

In a multiple-client, single-server environment, this goal makes a great deal of sense; any minute that the server is down (or unavailable) makes all the client machines (and their users) unhappy and unproductive.
==在多客户端、单服务器的环境中，这个目标非常有意义；服务器宕机（或不可用）的每一分钟都会让所有客户端机器（及其用户）感到不悦且生产力下降。==

Thus, as the server goes, so goes the entire system.
==因此，服务器一旦出故障，整个系统也就瘫痪了。==

49.4 Key To Fast Crash Recovery: Statelessness
==49.4 快速崩溃恢复的关键：无状态性==

This simple goal is realized in NFSv2 by designing what we refer to as a **stateless** protocol.
==在 NFSv2 中，通过设计我们所谓的**无状态**协议来实现这一简单目标。==

The server, by design, does not keep track of anything about what is happening at each client.
==根据设计，服务器不记录每个客户端正在发生的任何事情。==

For example, the server does not know which clients are caching which blocks, or which files are currently open at each client, or the current file pointer position for a file, etc.
==例如，服务器不知道哪些客户端正在缓存哪些数据块，或者每个客户端当前打开了哪些文件，或者文件的当前文件指针位置等。==

Simply put, the server does not track anything about what clients are doing; rather, the protocol is designed to deliver in each protocol request **all the information** that is needed in order to complete the request.
==简单来说，服务器不跟踪客户端正在做的任何事情；相反，协议被设计为在每个协议请求中传递完成该请求所需的**所有信息**。==

If it doesn’t now, this stateless approach will make more sense as we discuss the protocol in more detail below.
==如果现在还不明白，随着我们在下面更详细地讨论该协议，这种无状态方法将变得更有意义。==

For an example of a **stateful** (not stateless) protocol, consider the `open()` system call.
==作为一个**有状态**（非无状态）协议的例子，考虑 `open()` 系统调用。==

Given a pathname, `open()` returns a file descriptor (an integer).
==给定一个路径名，`open()` 返回一个文件描述符（一个整数）。==

This descriptor is used on subsequent `read()` or `write()` requests to access various file blocks, as in this application code:
==该描述符用于随后的 `read()` 或 `write()` 请求以访问各种文件块，如以下应用程序代码所示：==

```c
char buffer[MAX];
int fd = open("foo", O_RDONLY); // get descriptor "fd"
read(fd, buffer, MAX); // read MAX from foo via "fd"
read(fd, buffer, MAX); // read MAX again
...
read(fd, buffer, MAX); // read MAX again
close(fd); // close file
```
Figure 49.3: Client Code: Reading From A File
==图 49.3：客户端代码：从文件中读取==

Now imagine that the client-side file system opens the file by sending a protocol message to the server saying “open the file ’foo’ and give me back a descriptor”.
==现在想象一下，客户端文件系统通过向服务器发送协议消息来打开文件，消息内容为“打开文件 'foo' 并返回给我一个描述符”。==

The file server then opens the file locally on its side and sends the descriptor back to the client.
==文件服务器随后在其本地打开文件，并将描述符发送回客户端。==

On subsequent reads, the client application uses that descriptor to call the `read()` system call; the client-side file system then passes the descriptor in a message to the file server, saying “read some bytes from the file that is referred to by the descriptor I am passing you here”.
==在随后的读取中，客户端应用程序使用该描述符来调用 `read()` 系统调用；客户端文件系统随后在发给文件服务器的消息中传递该描述符，说“从我这里传递给你的描述符所引用的文件中读取一些字节”。==

In this example, the file descriptor is a piece of **shared state** between the client and the server.
==在这个例子中，文件描述符是客户端和服务器之间的一块**共享状态**。==

Shared state, as we hinted above, complicates crash recovery.
==正如我们上面暗示的，共享状态使崩溃恢复变得复杂。==

Imagine the server crashes after the first read completes, but before the client has issued the second one.
==假设服务器在第一次读取完成后、客户端发出第二次读取之前崩溃。==

After the server is up and running again, the client then issues the second read.
==服务器重新启动并运行后，客户端随后发出第二次读取。==

Unfortunately, the server has no idea to which file `fd` is referring; that information was ephemeral (i.e., in memory) and thus lost when the server crashed.
==不幸的是，服务器不知道 `fd` 指的是哪个文件；该信息是瞬态的（即在内存中），因此在服务器崩溃时丢失了。==

To handle this situation, the client and server would have to engage in some kind of **recovery protocol**, where the client would make sure to keep enough information around in its memory to be able to tell the server what it needs to know (in this case, that file descriptor `fd` refers to file `foo`).
==为了处理这种情况，客户端和服务器必须参与某种**恢复协议**，在这种协议中，客户端将确保在其内存中保留足够的信息，以便能够告诉服务器它需要知道的信息（在这种情况下，文件描述符 `fd` 指向文件 `foo`）。==

It gets even worse when you consider the fact that a stateful server has to deal with client crashes.
==当你考虑到有状态服务器必须处理客户端崩溃这一事实时，情况会变得更糟。==

Imagine, for example, a client that opens a file and then crashes.
==例如，想象一个打开文件然后崩溃的客户端。==

The `open()` uses up a file descriptor on the server; how can the server know it is OK to close a given file?
==`open()` 消耗了服务器上的一个文件描述符；服务器如何知道何时可以关闭给定的文件？==

In normal operation, a client would eventually call `close()` and thus inform the server that the file should be closed.
==在正常操作中，客户端最终会调用 `close()`，从而通知服务器应该关闭该文件。==

However, when a client crashes, the server never receives a `close()`, and thus has to notice the client has crashed in order to close the file.
==然而，当客户端崩溃时，服务器永远不会收到 `close()`，因此必须察觉到客户端已崩溃以便关闭文件。==

For these reasons, the designers of NFS decided to pursue a stateless approach: each client operation contains all the information needed to complete the request.
==由于这些原因，NFS 的设计者决定追求一种无状态的方法：每个客户端操作都包含完成请求所需的所有信息。==

No fancy crash recovery is needed; the server just starts running again, and a client, at worst, might have to retry a request.
==不需要复杂的崩溃恢复；服务器只需重新开始运行，而客户端在最坏的情况下可能只需重试请求。==

49.5 The NFSv2 Protocol
==49.5 NFSv2 协议==

We thus arrive at the NFSv2 protocol definition.
==我们因此得出了 NFSv2 协议的定义。==

THE CRUX: HOW TO DEFINE A STATELESS FILE PROTOCOL
==核心问题：如何定义无状态文件协议==

How can we define the network protocol to enable stateless operation?
==我们如何定义网络协议以实现无状态操作？==

Clearly, stateful calls like `open()` can’t be a part of the discussion (as it would require the server to track open files); however, the client application will want to call `open()`, `read()`, `write()`, `close()` and other standard API calls to access files and directories.
==显然，像 `open()` 这样的有状态调用不能成为讨论的一部分（因为它需要服务器跟踪打开的文件）；然而，客户端应用程序将希望调用 `open()`、`read()`、`write()`、`close()` 和其他标准 API 调用来访问文件和目录。==

Thus, as a refined question, how do we define the protocol to both be stateless and support the POSIX file system API?
==因此，作为一个更具体的问题，我们如何定义既是无状态的又能支持 POSIX 文件系统 API 的协议？==

One key to understanding the design of the NFS protocol is understanding the **file handle**.
==理解 NFS 协议设计的关键之一是理解**文件句柄**。==

File handles are used to uniquely describe the file or directory a particular operation is going to operate upon; thus, many of the protocol requests include a file handle.
==文件句柄用于唯一描述特定操作将要操作的文件或目录；因此，许多协议请求都包含一个文件句柄。==

You can think of a file handle as having three important components: a **volume identifier**, an **inode number**, and a **generation number**; together, these three items comprise a unique identifier for a file or directory that a client wishes to access.
==你可以认为文件句柄包含三个重要组成部分：**卷标识符**、**inode 编号**和**生成号**；这三项共同构成了客户端希望访问的文件或目录的唯一标识符。==

The volume identifier informs the server which file system the request refers to (an NFS server can export more than one file system); the inode number tells the server which file within that partition the request is accessing.
==卷标识符通知服务器请求引用的是哪个文件系统（一个 NFS 服务器可以导出多个文件系统）；inode 编号告诉服务器该请求正在访问该分区中的哪个文件。==

Finally, the generation number is needed when reusing an inode number; by incrementing it whenever an inode number is reused, the server ensures that a client with an old file handle can’t accidentally access the newly-allocated file.
==最后，在重用 inode 编号时需要生成号；通过在每次重用 inode 编号时递增它，服务器可以确保持有旧文件句柄的客户端不会意外访问新分配的文件。==

Here is a summary of some of the important pieces of the protocol:
==以下是该协议的一些重要部分的摘要：==

`NFSPROC_GETATTR` file handle
==`NFSPROC_GETATTR` 文件句柄==
returns: attributes
==返回：属性==

`NFSPROC_SETATTR` file handle, attributes
==`NFSPROC_SETATTR` 文件句柄，属性==
returns: attributes
==返回：属性==

`NFSPROC_LOOKUP` directory file handle, name of file/dir to look up
==`NFSPROC_LOOKUP` 目录文件句柄，要查找的文件/目录名称==
returns: file handle, attributes
==返回：文件句柄，属性==

`NFSPROC_READ` file handle, offset, count
==`NFSPROC_READ` 文件句柄，偏移量，计数==
returns: data, attributes
==返回：数据，属性==

`NFSPROC_WRITE` file handle, offset, count, data
==`NFSPROC_WRITE` 文件句柄，偏移量，计数，数据==
returns: attributes
==返回：属性==

`NFSPROC_CREATE` directory file handle, name of file, attributes
==`NFSPROC_CREATE` 目录文件句柄，文件名，属性==
returns: file handle, attributes
==返回：文件句柄，属性==

`NFSPROC_REMOVE` directory file handle, name of file to be removed
==`NFSPROC_REMOVE` 目录文件句柄，要删除的文件名==
returns: –
==返回：–==

`NFSPROC_MKDIR` directory file handle, name of directory, attributes
==`NFSPROC_MKDIR` 目录文件句柄，目录名，属性==
returns: file handle, attributes
==返回：文件句柄，属性==

`NFSPROC_RMDIR` directory file handle, name of directory to be removed
==`NFSPROC_RMDIR` 目录文件句柄，要删除的目录名==
returns: –
==返回：–==

`NFSPROC_READDIR` directory handle, count of bytes to read, cookie
==`NFSPROC_READDIR` 目录句柄，要读取的字节数，cookie==
returns: directory entries, cookie (to get more entries)
==返回：目录条目，cookie（用于获取更多条目）==

Figure 49.4: The NFS Protocol: Examples
==图 49.4：NFS 协议：示例==

We briefly highlight the important components of the protocol.
==我们简要强调该协议的重要组成部分。==

First, the `LOOKUP` protocol message is used to obtain a file handle, which is then subsequently used to access file data.
==首先，`LOOKUP` 协议消息用于获取文件句柄，该句柄随后用于访问文件数据。==

The client passes a directory file handle and name of a file to look up, and the handle to that file (or directory) plus its attributes are passed back to the client from the server.
==客户端传递一个目录文件句柄和要查找的文件名，服务器将该文件（或目录）的句柄及其属性传回给客户端。==

For example, assume the client already has a directory file handle for the root directory of a file system (/) (indeed, this would be obtained through the NFS mount protocol).
==例如，假设客户端已经拥有文件系统根目录 (/) 的目录文件句柄（实际上，这是通过 NFS 挂载协议获取的）。==

If an application running on the client opens the file `/foo.txt`, the client-side file system sends a lookup request to the server, passing it the root file handle and the name `foo.txt`; if successful, the file handle (and attributes) for `foo.txt` will be returned.
==如果运行在客户端上的应用程序打开文件 `/foo.txt`，客户端文件系统会向服务器发送查找请求，并向其传递根文件句柄和文件名 `foo.txt`；如果成功，将返回 `foo.txt` 的文件句柄（和属性）。==

In case you are wondering, attributes are just the metadata that the file system tracks about each file, including fields such as file creation time, last modification time, size, ownership and permissions information, and so forth.
==如果你想知道，属性就是文件系统跟踪的关于每个文件的元数据，包括文件创建时间、最后修改时间、大小、所有权和权限信息等字段。==

Once a file handle is available, the client can issue `READ` and `WRITE` protocol messages on a file to read or write the file, respectively.
==一旦文件句柄可用，客户端就可以对文件发出 `READ` 和 `WRITE` 协议消息，分别用于读取或写入文件。==

The `READ` protocol message requires the protocol to pass along the file handle of the file along with the offset within the file and number of bytes to read.
==`READ` 协议消息要求协议传递文件的文件句柄以及文件内的偏移量和要读取的字节数。==

The server then will be able to issue the read (after all, the handle tells the server which volume and which inode to read from, and the offset and count tells it which bytes of the file to read) and return the data (and up-to-date attributes) to the client.
==服务器随后将能够发出读取指令（毕竟，句柄告诉服务器从哪个卷和哪个 inode 读取，偏移量和计数告诉它读取文件的哪些字节），并将数据（和最新的属性）返回给客户端。==

`WRITE` is handled similarly, except the data is passed from the client to the server, and just a success code (and up-to-date attributes) is returned.
==`WRITE` 的处理方式类似，不同之处在于数据是从客户端传递到服务器的，并且仅返回成功代码（和最新的属性）。==

One last interesting protocol message is the `GETATTR` request; given a file handle, it simply fetches the attributes for that file, including the last modified time of the file.
==最后一个有趣的协议消息是 `GETATTR` 请求；给定一个文件句柄，它只是获取该文件的属性，包括文件的最后修改时间。==

49.6 From Protocol To Distributed File System
==49.6 从协议到分布式文件系统==

Hopefully you are now getting some sense of how this protocol is turned into a file system across the client-side file system and the file server.
==希望你现在已经对如何通过客户端文件系统和文件服务器将此协议转换为文件系统有了一些感觉。==

The client-side file system tracks open files, and generally translates application requests into the relevant set of protocol messages.
==客户端文件系统跟踪打开的文件，并通常将应用程序请求转换为相关的协议消息集。==

The server simply responds to protocol messages, each of which contains all of the information needed to complete the request.
==服务器只是响应协议消息，每条消息都包含完成请求所需的所有信息。==

In the diagram (Figure 49.5), we show what system calls the application makes, and what the client-side file system and file server do in responding to such calls.
==在图表（图 49.5）中，我们展示了应用程序发出的系统调用，以及客户端文件系统和文件服务器在响应此类调用时所做的工作。==

First, notice how the client tracks all relevant **state** for the file access, including the mapping of the integer file descriptor to an NFS file handle as well as the current file pointer.
==首先，注意客户端如何跟踪文件访问的所有相关**状态**，包括整数文件描述符到 NFS 文件句柄的映射以及当前文件指针。==

This enables the client to turn each read request into a properly-formatted read protocol message which tells the server exactly which bytes from the file to read.
==这使得客户端能够将每个读取请求转换为格式正确的读取协议消息，该消息准确地告诉服务器要从文件中读取哪些字节。==

Upon a successful read, the client updates the current file position; subsequent reads are issued with the same file handle but a different offset.
==读取成功后，客户端会更新当前文件位置；随后的读取将使用相同的文件句柄但不同的偏移量发出。==

Second, you may notice where server interactions occur.
==其次，你可能会注意到服务器交互发生在哪里。==

When the file is opened for the first time, the client-side file system sends a `LOOKUP` request message.
==第一次打开文件时，客户端文件系统会发送一条 `LOOKUP` 请求消息。==

Indeed, if a long pathname must be traversed (e.g., `/home/remzi/foo.txt`), the client would send three `LOOKUP`s: one to look up `home` in the directory `/`, one to look up `remzi` in `home`, and finally one to look up `foo.txt` in `remzi`.
==事实上，如果必须遍历一个长路径名（例如 `/home/remzi/foo.txt`），客户端将发送三个 `LOOKUP`：一个在目录 `/` 中查找 `home`，一个在 `home` 中查找 `remzi`，最后在 `remzi` 中查找 `foo.txt`。==

Third, you may notice how each server request has all the information needed to complete the request in its entirety.
==第三，你可能会注意到每个服务器请求都拥有完整完成该请求所需的所有信息。==

This design point is critical to be able to gracefully recover from server failure; it ensures that the server does not need state to be able to respond to the request.
==这个设计点对于能够从服务器故障中优雅地恢复至关重要；它确保服务器不需要状态就能响应请求。==

Figure 49.5: Reading A File: Client-side And File Server Actions
==图 49.5：读取文件：客户端和文件服务器的操作==

TIP: IDEMPOTENCY IS POWERFUL
==提示：幂等性是强大的==

Idempotency is a useful property when building reliable systems.
==幂等性是构建可靠系统时的一个有用属性。==

When an operation can be issued more than once, it is much easier to handle failure of the operation; you can just retry it.
==当一个操作可以发出多次时，处理操作失败就会容易得多；你只需重试即可。==

If an operation is **not** idempotent, life becomes more difficult.
==如果一个操作**不**是幂等的，生活就会变得更加困难。==

49.7 Handling Server Failure With Idempotent Operations
==49.7 使用幂等操作处理服务器故障==

When a client sends a message to the server, it sometimes does not receive a reply.
==当客户端向服务器发送消息时，有时收不到回复。==

There are many possible reasons for this failure to respond.
==这种响应失败可能有许多原因。==

In some cases, the message may be dropped by the network.
==在某些情况下，消息可能会被网络丢弃。==

It is also possible that the server has crashed, and thus is not currently responding to messages.
==服务器也有可能已经崩溃，因此目前无法响应消息。==

In NFSv2, a client handles all of these failures in a single, uniform, and elegant way: it simply **retries** the request.
==在 NFSv2 中，客户端以单一、统一且优雅的方式处理所有这些故障：它只是**重试**请求。==

Specifically, after sending the request, the client sets a timer to go off after a specified time period.
==具体来说，在发送请求后，客户端会设置一个定时器，在指定的时间段后触发。==

If the timer goes off before any reply is received, the client assumes the request has not been processed and resends it.
==如果定时器在收到任何回复之前触发，客户端就会认为请求尚未处理并重新发送。==

The ability of the client to simply retry the request is due to an important property of most NFS requests: they are **idempotent**.
==客户端能够简单地重试请求归功于大多数 NFS 请求的一个重要属性：它们是**幂等**的。==

An operation is called idempotent when the effect of performing the operation multiple times is equivalent to the effect of performing the operation a single time.
==当执行多次操作的效果等同于执行一次操作的效果时，该操作被称为幂等操作。==

For example, “store value to memory” is an idempotent operation.
==例如，“将值存储到内存”是一个幂等操作。==

If, however, you increment a counter three times, it results in a different amount than doing so just once; thus, “increment counter” is not idempotent.
==然而，如果你将计数器增加三次，其结果与仅增加一次不同；因此，“增加计数器”不是幂等的。==

LOOKUP and READ requests are trivially idempotent, as they only read information from the file server and do not update it.
==LOOKUP 和 READ 请求显然是幂等的，因为它们只从文件服务器读取信息而不更新它。==

More interestingly, WRITE requests are also idempotent.
==更有趣的是，WRITE 请求也是幂等的。==

The WRITE message contains the data, the count, and (importantly) the exact offset to write the data to.
==WRITE 消息包含数据、计数以及（重要的）要写入数据的确切偏移量。==

Thus, it can be repeated with the knowledge that the outcome of multiple writes is the same as the outcome of a single one.
==因此，它可以重复进行，因为知道多次写入的结果与单次写入的结果相同。==

Figure 49.6: The Three Types Of Loss
==图 49.6：三种类型的丢失==

Case 1: Request Lost
==案例 1：请求丢失==

Case 2: Server Down
==案例 2：服务器宕机==

Case 3: Reply lost on way back from Server
==案例 3：回复在从服务器返回的途中丢失==

In this way, the client can handle all timeouts in a unified way.
==通过这种方式，客户端可以统一处理所有超时。==

A small aside: some operations are hard to make idempotent.
==一个小旁注：某些操作很难做到幂等。==

For example, when you try to make a directory that already exists, you are informed that the `mkdir` request has failed.
==例如，当你尝试创建一个已经存在的目录时，你会收到 `mkdir` 请求失败的通知。==

Thus, in NFS, if the file server receives a `MKDIR` protocol message and executes it successfully but the reply is lost, the client may repeat it and encounter that failure when in fact the operation at first succeeded.
==因此，在 NFS 中，如果文件服务器收到 `MKDIR` 协议消息并成功执行但回复丢失了，客户端可能会重复该消息并遇到失败，而实际上该操作最初是成功的。==

TIP: PERFECT IS THE ENEMY OF THE GOOD (VOLTAIRE’S LAW)
==提示：完美是优秀的敌人（伏尔泰法则）==

Even when you design a beautiful system, sometimes all the corner cases don’t work out exactly as you might like.
==即使当你设计了一个精美的系统时，有时并非所有的边角案例都能完全如你所愿地解决。==

Take the `mkdir` example above; one could redesign `mkdir` to have different semantics, thus making it idempotent.
==以上面的 `mkdir` 为例；人们可以重新设计 `mkdir` 以具有不同的语义，从而使其具有幂等性。==

The NFS design philosophy covers most of the important cases, and overall makes the system design clean and simple with regards to failure.
==NFS 的设计哲学涵盖了大多数重要案例，并且总体上使系统在处理故障方面保持简洁。==

49.8 Improving Performance: Client-side Caching
==49.8 提高性能：客户端缓存==

Distributed file systems are good for a number of reasons, but sending all read and write requests across the network can lead to a big performance problem.
==分布式文件系统由于许多原因而表现良好，但通过网络发送所有读写请求可能会导致严重的性能问题。==

The answer is **client-side caching**.
==答案是**客户端缓存**。==

The NFS client-side file system caches file data (and metadata) that it has read from the server in client memory.
==NFS 客户端文件系统将从服务器读取的文件数据（和元数据）缓存在客户端内存中。==

The cache also serves as a temporary buffer for writes.
==缓存还充当写入的临时缓冲区。==

Such **write buffering** is useful because it decouples application `write()` latency from actual write performance.
==这种**写缓冲**很有用，因为它将应用程序 `write()` 的延迟与实际的写入性能解耦。==

Adding caching into any sort of system with multiple client caches introduces a big and interesting challenge which we will refer to as the **cache consistency problem**.
==在任何具有多个客户端缓存的系统中添加缓存都会引入一个巨大且有趣的挑战，我们将其称为**缓存一致性问题**。==

49.9 The Cache Consistency Problem
==49.9 缓存一致性问题==

The cache consistency problem is best illustrated with three clients and a single server.
==缓存一致性问题最好通过三个客户端和一个服务器来阐述。==

Figure 49.7: The Cache Consistency Problem
==图 49.7：缓存一致性问题==

There are two subproblems.
==有两个子问题。==

The first subproblem is **update visibility**; when do updates from one client become visible at other clients?
==第一个子问题是**更新可见性**；一个客户端的更新何时对其他客户端可见？==

The second subproblem of cache consistency is a **stale cache**; in this case, C1 still has an old version of a file in its cache.
==缓存一致性的第二个子问题是**陈旧缓存**；在这种情况下，C1 的缓存中仍保留文件的旧版本。==

NFSv2 implementations solve these cache consistency problems in two ways.
==NFSv2 的实现通过两种方式解决这些缓存一致性问题。==

First, to address update visibility, clients implement what is sometimes called **flush-on-close** (a.k.a., **close-to-open**) consistency semantics.
==首先，为了解决更新可见性，客户端实现了有时被称为**关闭时刷新**（又称**从关闭到打开**）的一致性语义。==

Specifically, when a file is written to and subsequently closed by a client application, the client flushes all updates to the server.
==具体来说，当文件被写入并随后由客户端应用程序关闭时，客户端会将所有更新刷新到服务器。==

Second, to address the stale-cache problem, NFSv2 clients first check to see whether a file has changed before using its cached contents.
==其次，为了解决陈旧缓存问题，NFSv2 客户端在使用其缓存内容之前，首先检查文件是否已更改。==

Specifically, before using a cached block, the client-side file system will issue a `GETATTR` request to the server to fetch the file’s attributes.
==具体来说，在应用缓存块之前，客户端文件系统将向服务器发出 `GETATTR` 请求以获取文件的属性。==

If the time-of-modification is more recent than the time that the file was fetched into the client cache, the client **invalidates** the file, thus removing it from the client cache.
==如果修改时间晚于文件被获取到客户端缓存的时间，客户端将**使该文件失效**，从而将其从客户端缓存中移除。==

When the original team at Sun implemented this solution, they realized a new problem; suddenly, the NFS server was flooded with `GETATTR` requests.
==当 Sun 的原团队实现这个解决方案时，他们意识到了一个新问题；突然之间，NFS 服务器充斥着大量的 `GETATTR` 请求。==

To remedy this situation, an **attribute cache** was added to each client.
==为了补救这种情况，每个客户端都添加了一个**属性缓存**。==

The attributes for a particular file were placed in the cache when the file was first accessed, and then would timeout after a certain amount of time (say 3 seconds).
==特定文件的属性在文件首次被访问时放入缓存，然后在一段时间（例如 3 秒）后超时。==

49.11 Implications On Server-Side Write Buffering
==49.11 对服务器端写缓冲的影响==

An NFS server absolutely may **not** return success on a `WRITE` protocol request until the write has been forced to stable storage.
==在写入被强制保存到稳定存储之前，NFS 服务器绝对**不能**对 `WRITE` 协议请求返回成功。==

Yikes! Because the server told the client that the second write was successful before committing it to disk, an old chunk is left in the file, which might be catastrophic.
==哎呀！因为服务器在将第二次写入提交到磁盘之前就告诉客户端写入成功，导致文件中留下了一个旧块，这可能是灾难性的。==

To avoid this problem, NFS servers must commit each write to stable storage before informing the client of success.
==为了避免这个问题，NFS 服务器必须在通知客户端成功之前将每次写入提交到稳定存储。==

ASIDE: INNOVATION BREEDS INNOVATION
==旁注：创新孕育创新==

Probably the most lasting innovation is the **Virtual File System (VFS) / Virtual Node (vnode)** interface.
==也许最持久的创新是**虚拟文件系统 (VFS) / 虚拟节点 (vnode)** 接口。==

The VFS layer includes operations that are done to an entire file system, such as mounting and unmounting.
==VFS 层包括对整个文件系统执行的操作，例如挂载和卸载。==

The vnode layer consists of all operations one can perform on a file, such as `open`, `close`, `read`, `write`.
==vnode 层由可以在文件上执行的所有操作组成，例如 `open`、`close`、`read`、`write`。==

49.12 Summary
==49.12 总结==

NFS is centered around the idea of simple and fast recovery in the face of server failure.
==NFS 的核心思想是在面对服务器故障时实现简单快速的恢复。==

ASIDE: KEY NFS TERMS
==旁注：NFS 关键术语==

• The key to realizing fast and simple crash recovery in NFS is in the design of a **stateless** protocol.
==• 在 NFS 中实现快速简单崩溃恢复的关键在于**无状态**协议的设计。==

• Making requests **idempotent** is a central aspect of the NFS protocol.
==• 使请求具有**幂等性**是 NFS 协议的一个核心方面。==

• Performance concerns dictate the need for client-side **caching** and **write buffering**, but introduces a **cache consistency problem**.
==• 性能考量决定了对客户端**缓存**和**写缓冲**的需求，但这引入了**缓存一致性问题**。==

• NFS implementations provide an engineering solution to cache consistency through a **flush-on-close** approach and an **attribute cache**.
==• NFS 实现通过**关闭时刷新**方法和**属性缓存**为缓存一致性提供了工程解决方案。==

• NFS servers must commit writes to persistent media before returning success.
==• NFS 服务器必须在返回成功之前将写入提交到持久介质。==

• Sun introduced the **VFS/Vnode** interface, enabling multiple file system implementations to coexist.
==• Sun 引入了 **VFS/Vnode** 接口，使多个文件系统实现能够并存。==

50 The Andrew File System (AFS)
==50 Andrew 文件系统 (AFS)==

The Andrew File System was introduced at Carnegie-Mellon University (CMU) in the 1980’s [H+88].
==Andrew 文件系统于 20 世纪 80 年代在卡内基梅隆大学 (CMU) 推出 [H+88]。==

The main goal of this project was simple: **scale**.
==该项目的主要目标很简单：**可扩展性**。==

In NFS, the protocol forces clients to check with the server periodically; frequent checks like this will limit the number of clients a server can respond to.
==在 NFS 中，协议强制客户端定期向服务器检查；像这样频繁的检查会限制服务器能够响应的客户端数量。==

AFS also differs from NFS in that cache consistency is simple and readily understood: when the file is opened, a client will generally receive the latest consistent copy from the server.
==AFS 与 NFS 的不同之处还在于，其缓存一致性简单且易于理解：当文件打开时，客户端通常会从服务器接收最新的、一致的副本。==

50.1 AFS Version 1
==50.1 AFS 第 1 版==

One of the basic tenets of all versions of AFS is **whole-file caching** on the **local disk** of the client machine.
==所有 AFS 版本的基本原则之一是在客户端机器的**本地磁盘**上进行**全文件缓存**。==

When you `open()` a file, the entire file is fetched from the server and stored in a file on your local disk.
==当你 `open()` 一个文件时，整个文件会从服务器获取并存储在你本地磁盘的一个文件中。==

Subsequent application `read()` and `write()` operations are redirected to the local file system; thus, these operations require no network communication and are fast.
==随后的应用程序 `read()` 和 `write()` 操作将被重定向到本地文件系统；因此，这些操作不需要网络通信，速度很快。==

Finally, upon `close()`, the file (if it has been modified) is flushed back to the server.
==最后，在 `close()` 时，文件（如果已被修改）将被刷新回服务器。==

When a client application first calls `open()`, the AFS client-side code (which the AFS designers call **Venus**) would send a **Fetch** protocol message to the server.
==当客户端应用程序首次调用 `open()` 时，AFS 客户端代码（AFS 设计者称之为 **Venus**）会向服务器发送一条 **Fetch** 协议消息。==

The file server (the group of which they called **Vice**) would find the desired file, and ship the entire file back to the client.
==文件服务器（他们称该群体为 **Vice**）会找到所需的文件，并将整个文件运回客户端。==

When finished, the AFS client checks if the file has been modified; if so, it flushes the new version back to the server with a **Store** protocol message.
==完成后，AFS 客户端会检查文件是否已被修改；如果是，它将通过 **Store** 协议消息将新版本刷新回服务器。==




**THE ANDREW FILE SYSTEM (AFS)**
==**Andrew 文件系统 (AFS)**==

**TIP: MEASURE THEN BUILD (PATTERSON’S LAW)**
==**提示：先测量再构建（帕特森定律）**==

One of our advisors, David Patterson (of RISC and RAID fame), used to always encourage us to measure a system and demonstrate a problem before building a new system to fix said problem.
==我们的一位顾问，David Patterson（以 RISC 和 RAID 闻名），过去总是鼓励我们在构建新系统来解决问题之前，先对系统进行测量并证明问题的存在。==

By using experimental evidence, rather than gut instinct, you can turn the process of system building into a more scientific endeavor.
==通过使用实验证据而非直觉，你可以将系统构建的过程转变为一项更具科学性的工作。==

Doing so also has the fringe benefit of making you think about how exactly to measure the system before your improved version is developed.
==这样做还有一个额外的好处，那就是让你在开发改进版本之前，思考究竟该如何测量系统。==

When you do finally get around to building the new system, two things are better as a result: first, you have evidence that shows you are solving a real problem; second, you now have a way to measure your new system in place, to show that it actually improves upon the state of the art.
==当你最终着手构建新系统时，结果会有两方面的提升：首先，你有证据表明你正在解决一个真实存在的问题；其次，你现在拥有一套现成的测量方法来评估新系统，以证明它确实改进了现有技术。==

And thus we call this **Patterson’s Law**.
==因此，我们称之为**帕特森定律**。==

**50.2 Problems with Version 1**
==**50.2 版本 1 存在的问题**==

A few key problems with this first version of AFS motivated the designers to rethink their file system.
==AFS 第一个版本中存在的一些关键问题促使设计者重新思考他们的文件系统。==

To study the problems in detail, the designers of AFS spent a great deal of time measuring their existing prototype to find what was wrong.
==为了详细研究这些问题，AFS 的设计者花费了大量时间测量他们现有的原型，以找出症结所在。==

Such experimentation is a good thing, because **measurement** is the key to understanding how systems work and how to improve them; obtaining concrete, good data is thus a necessary part of systems construction.
==这种实验是一件好事，因为**测量**是理解系统如何工作以及如何改进系统的关键；因此，获取具体、有效的数据是系统构建中必不可少的一部分。==

In their study, the authors found two main problems with AFSv1:
==在研究中，作者发现了 AFSv1 的两个主要问题：==

*   **Path-traversal costs are too high**: When performing a Fetch or Store protocol request, the client passes the entire pathname (e.g., `/home/remzi/notes.txt`) to the server.
==*   **路径遍历开销过高**：在执行 Fetch（获取）或 Store（存储）协议请求时，客户端会将整个路径名（例如 `/home/remzi/notes.txt`）传递给服务器。==

The server, in order to access the file, must perform a full pathname traversal, first looking in the root directory to find `home`, then in `home` to find `remzi`, and so forth, all the way down the path until finally the desired file is located.
==服务器为了访问该文件，必须执行完整的路径名遍历，首先在根目录中查找 `home`，然后在 `home` 中查找 `remzi`，以此类推，沿着路径一直向下，直到最终找到目标文件。==

With many clients accessing the server at once, the designers of AFS found that the server was spending much of its CPU time simply walking down directory paths.
==由于有许多客户端同时访问服务器，AFS 的设计者发现服务器的大部分 CPU 时间都花在遍历目录路径上。==

*   **The client issues too many TestAuth protocol messages**: Much like NFS and its overabundance of GETATTR protocol messages, AFSv1 generated a large amount of traffic to check whether a local file (or its stat information) was valid with the TestAuth protocol message.
==*   **客户端发送了过多的 TestAuth 协议消息**：非常像 NFS 及其过量的 GETATTR 协议消息，AFSv1 产生了大量的通信流量，通过 TestAuth 协议消息来检查本地文件（或其状态信息）是否有效。==

Thus, servers spent much of their time telling clients whether it was OK to use their cached copies of a file.
==因此，服务器花费了大量时间告诉客户端是否可以使用其缓存的文件副本。==

Most of the time, the answer was that the file had not changed.
==大多数情况下，答案是文件并未发生更改。==

There were actually two other problems with AFSv1: load was not balanced across servers, and the server used a single distinct process per client thus inducing context switching and other overheads.
==实际上 AFSv1 还存在另外两个问题：服务器之间的负载不均衡，且服务器为每个客户端使用一个独立的进程，从而导致了上下文切换和其他开销。==

The load imbalance problem was solved by introducing **volumes**, which an administrator could move across servers to balance load; the context-switch problem was solved in AFSv2 by building the server with threads instead of processes.
==负载不均衡问题通过引入**卷 (volumes)** 得到了解决，管理员可以跨服务器移动卷以平衡负载；上下文切换问题在 AFSv2 中通过使用线程而非进程构建服务器得到了解决。==

However, for the sake of space, we focus here on the main two protocol problems above that limited the scale of the system.
==然而，由于篇幅限制，我们在这里重点讨论上述限制系统规模的两个主要协议问题。==

**50.3 Improving the Protocol**
==**50.3 改进协议**==

The two problems above limited the scalability of AFS; the server CPU became the bottleneck of the system, and each server could only service 20 clients without becoming overloaded.
==上述两个问题限制了 AFS 的可扩展性；服务器 CPU 成为了系统的瓶块，每台服务器在不超载的情况下只能为 20 个客户端提供服务。==

Servers were receiving too many TestAuth messages, and when they received Fetch or Store messages, were spending too much time traversing the directory hierarchy.
==服务器接收到了太多的 TestAuth 消息，而在接收到 Fetch 或 Store 消息时，又花费了太多时间遍历目录层级。==

Thus, the AFS designers were faced with a problem:
==因此，AFS 的设计者面临着一个问题：==

**THE CRUX: HOW TO DESIGN A SCALABLE FILE PROTOCOL**
==**症结所在：如何设计可扩展的文件协议**==

How should one redesign the protocol to minimize the number of server interactions, i.e., how could they reduce the number of TestAuth messages?
==应该如何重新设计协议以尽量减少服务器交互次数，即如何减少 TestAuth 消息的数量？==

Further, how could they design the protocol to make these server interactions efficient?
==此外，他们如何设计协议使这些服务器交互变得高效？==

By attacking both of these issues, a new protocol would result in a much more scalable version AFS.
==通过解决这两个问题，新协议将产生一个更具扩展性的 AFS 版本。==

**50.4 AFS Version 2**
==**50.4 AFS 版本 2**==

AFSv2 introduced the notion of a **callback** to reduce the number of client/server interactions.
==AFSv2 引入了**回调 (callback)** 的概念，以减少客户端/服务器之间的交互次数。==

A callback is simply a promise from the server to the client that the server will inform the client when a file that the client is caching has been modified.
==回调简单来说就是服务器对客户端的一个承诺，即当客户端正在缓存的文件被修改时，服务器会通知客户端。==

By adding this **state** to the system, the client no longer needs to contact the server to find out if a cached file is still valid.
==通过向系统添加这种**状态**，客户端不再需要联系服务器来了解缓存文件是否仍然有效。==

Rather, it assumes that the file is valid until the server tells it otherwise; notice the analogy to **polling** versus **interrupts**.
==相反，它假设文件是有效的，直到服务器告知其并非如此；请注意这与**轮询 (polling)** 与**中断 (interrupts)** 之间的类比。==

AFSv2 also introduced the notion of a **file identifier (FID)** (similar to the NFS file handle) instead of pathnames to specify which file a client was interested in.
==AFSv2 还引入了**文件标识符 (FID)** 的概念（类似于 NFS 的文件句柄），而不是使用路径名来指定客户端感兴趣的文件。==

An FID in AFS consists of a volume identifier, a file identifier, and a “uniquifier” (to enable reuse of the volume and file IDs when a file is deleted).
==AFS 中的 FID 由卷标识符、文件标识符和一个“唯一化标识 (uniquifier)”组成（以便在文件删除时能够重用卷和文件 ID）。==

Thus, instead of sending whole pathnames to the server and letting the server walk the pathname to find the desired file, the client would walk the pathname, one piece at a time, caching the results and thus hopefully reducing the load on the server.
==因此，客户端不再将整个路径名发送给服务器并让服务器遍历路径名来查找所需文件，而是亲自遍历路径名，一次处理一段，并缓存结果，从而有望减轻服务器的负载。==

For example, if a client accessed the file `/home/remzi/notes.txt`, and `home` was the AFS directory mounted onto `/` (i.e., `/` was the local root directory, but `home` and its children were in AFS), the client would first Fetch the directory contents of `home`, put them in the local-disk cache, and set up a callback on `home`.
==例如，如果客户端访问文件 `/home/remzi/notes.txt`，且 `home` 是挂载到 `/` 上的 AFS 目录（即 `/` 是本地根目录，但 `home` 及其子目录在 AFS 中），客户端会首先 Fetch（获取）`home` 的目录内容，将其放入本地磁盘缓存，并在 `home` 上设置回调。==

Then, the client would Fetch the directory contents of `remzi`, put it in the local-disk cache, and set up a callback on `remzi`.
==然后，客户端会 Fetch `remzi` 的目录内容，将其放入本地磁盘缓存，并在 `remzi` 上设置回调。==

Finally, the client would Fetch `notes.txt`, cache this regular file in the local disk, set up a callback, and finally return a file descriptor to the calling application.
==最后，客户端会 Fetch `notes.txt`，将此普通文件缓存在本地磁盘中，设置回调，并最终向调用程序返回文件句柄。==

See Figure 50.2 for a summary.
==摘要请参见图 50.2。==

The key difference, however, from NFS, is that with each fetch of a directory or file, the AFS client would establish a callback with the server, thus ensuring that the server would notify the client of a change in its cached state.
==然而，与 NFS 的关键区别在于，每当获取目录或文件时，AFS 客户端都会与服务器建立回调，从而确保服务器会在其缓存状态发生变化时通知客户端。==

The benefit is obvious: although the first access to `/home/remzi/notes.txt` generates many client-server messages (as described above), it also establishes callbacks for all the directories as well as the file `notes.txt`, and thus subsequent accesses are entirely local and require no server interaction at all.
==这样做的好处是显而易见的：虽然第一次访问 `/home/remzi/notes.txt` 会产生许多客户端-服务器消息（如上所述），但它也为所有目录以及文件 `notes.txt` 建立了回调，因此后续访问完全是本地的，根本不需要服务器交互。==

Thus, in the common case where a file is cached at the client, AFS behaves nearly identically to a local disk-based file system.
==因此，在文件缓存于客户端的常见情况下，AFS 的表现几乎与本地基于磁盘的文件系统完全一致。==

If one accesses a file more than once, the second access should be just as fast as accessing a file locally.
==如果多次访问同一个文件，第二次访问的速度应该与在本地访问文件一样快。==

**50.5 Cache Consistency**
==**50.5 缓存一致性**==

When we discussed NFS, there were two aspects of cache consistency we considered: **update visibility** and **cache staleness**.
==当我们讨论 NFS 时，我们考虑了缓存一致性的两个方面：**更新可见性**和**缓存陈旧性**。==

With update visibility, the question is: when will the server be updated with a new version of a file?
==对于更新可见性，问题在于：服务器何时会更新文件的新版本？==

With cache staleness, the question is: once the server has a new version, how long before clients see the new version instead of an older cached copy?
==对于缓存陈旧性，问题在于：一旦服务器有了新版本，客户端需要多长时间才能看到新版本而不是旧的缓存副本？==

Because of callbacks and whole-file caching, the cache consistency provided by AFS is easy to describe and understand.
==由于使用了回调和全文件缓存，AFS 提供的缓存一致性很容易描述和理解。==

There are two important cases to consider: consistency between processes on different machines, and consistency between processes on the same machine.
==有两个重要情况需要考虑：不同机器上的进程之间的一致性，以及同一台机器上的进程之间的一致性。==

Between different machines, AFS makes updates visible at the server and invalidates cached copies at the exact same time, which is when the updated file is closed.
==在不同机器之间，AFS 在更新后的文件关闭时，会同时使更新在服务器上可见并使缓存副本失效。==

A client opens a file, and then writes to it (perhaps repeatedly).
==客户端打开一个文件，然后向其中写入内容（可能会重复写入）。==

When it is finally closed, the new file is flushed to the server (and thus visible).
==当文件最终被关闭时，新文件会被刷新到服务器（从而变得可见）。==

At this point, the server then “breaks” callbacks for any clients with cached copies; the break is accomplished by contacting each client and informing it that the callback it has on the file is no longer valid.
==此时，服务器会“打破 (break)”任何拥有缓存副本的客户端的回调；这种打破是通过联系每个客户端并告知其对该文件的回调不再有效来完成的。==

This step ensures that clients will no longer read stale copies of the file; subsequent opens on those clients will require a re-fetch of the new version of the file from the server (and will also serve to reestablish a callback on the new version of the file).
==这一步确保了客户端将不再读取文件的陈旧副本；这些客户端随后进行的打开操作将需要从服务器重新获取文件的新版本（这同时也会在新版本文件上重新建立回调）。==

AFS makes an exception to this simple model between processes on the same machine.
==对于同一台机器上的进程，AFS 对这种简单的模型做了一个例外处理。==

In this case, writes to a file are immediately visible to other local processes (i.e., a process does not have to wait until a file is closed to see its latest updates).
==在这种情况下，对文件的写入对其他本地进程是立即可见的（即进程不必等到文件关闭就能看到其最新的更新）。==

This makes using a single machine behave exactly as you would expect, as this behavior is based upon typical UNIX semantics.
==这使得在单台机器上的使用表现完全符合预期，因为这种行为是基于典型的 UNIX 语义的。==

Only when switching to a different machine would you be able to detect the more general AFS consistency mechanism.
==只有在切换到不同机器时，你才能察觉到更通用的 AFS 一致性机制。==

There is one interesting cross-machine case that is worthy of further discussion.
==有一个有趣的跨机器案例值得进一步讨论。==

Specifically, in the rare case that processes on different machines are modifying a file at the same time, AFS naturally employs what is known as a **last writer wins** approach (which perhaps should be called **last closer wins**).
==具体来说，在极少数情况下，如果不同机器上的进程同时修改同一个文件，AFS 自然会采用所谓的**最后写入者胜 (last writer wins)** 方法（这也许应该被称为**最后关闭者胜 (last closer wins)**）。==

Specifically, whichever client calls `close()` last will update the entire file on the server last and thus will be the “winning” file, i.e., the file that remains on the server for others to see.
==具体而言，无论哪个客户端最后调用 `close()`，它都会最后更新服务器上的整个文件，从而成为“胜出”的文件，即留在服务器上供他人查看的文件。==

The result is a file that was generated in its entirety either by one client or the other.
==结果是产生了一个要么完全由一个客户端生成，要么完全由另一个客户端生成的文件。==

Note the difference from a block-based protocol like NFS: in NFS, writes of individual blocks may be flushed out to the server as each client is updating the file, and thus the final file on the server could end up as a mix of updates from both clients.
==注意这与像 NFS 这样的基于块的协议的区别：在 NFS 中，当每个客户端更新文件时，单个块的写入可能会被刷新到服务器，因此服务器上的最终文件可能会变成两个客户端更新内容的混合体。==

**50.6 Crash Recovery**
==**50.6 崩溃恢复**==

From the description above, you might sense that crash recovery is more involved than with NFS.
==从上面的描述中，你可能会感觉到崩溃恢复比 NFS 更加复杂。==

You would be right.
==你是对的。==

For example, imagine there is a short period of time where a server (S) is not able to contact a client (C1), for example, while the client C1 is rebooting.
==例如，假设有一小段时间服务器 (S) 无法联系到客户端 (C1)，例如当客户端 C1 正在重启时。==

While C1 is not available, S may have tried to send it one or more callback recall messages.
==当 C1 不可用时，S 可能已经尝试向其发送一个或多个回调撤回消息。==

Because C1 may miss those critical messages when it is rebooting, upon rejoining the system, C1 should treat all of its cache contents as suspect.
==由于 C1 在重启时可能会错过这些关键消息，因此在重新加入系统后，C1 应将其所有缓存内容视为可疑。==

Thus, upon the next access to file F, C1 should first ask the server (with a TestAuth protocol message) whether its cached copy of file F is still valid.
==因此，在下一次访问文件 F 时，C1 应首先向服务器询问（通过 TestAuth 协议消息）其缓存的文件 F 副本是否仍然有效。==

Server recovery after a crash is also more complicated.
==服务器在崩溃后的恢复也更加复杂。==

The problem that arises is that callbacks are kept in memory; thus, when a server reboots, it has no idea which client machine has which files.
==出现的问题是回调保存在内存中；因此，当服务器重启时，它不知道哪台客户端机器拥有哪些文件。==

Thus, upon server restart, each client of the server must realize that the server has crashed and treat all of their cache contents as suspect, and (as above) reestablish the validity of a file before using it.
==因此，在服务器重启时，服务器的每个客户端必须意识到服务器已经崩溃，并将其所有缓存内容视为可疑，并且（如上所述）在利用文件之前重新确立其有效性。==

**50.7 Scale And Performance Of AFSv2**
==**50.7 AFSv2 的规模与性能**==

With the new protocol in place, AFSv2 was measured and found to be much more scalable than the original version.
==随着新协议的实施，经测量发现 AFSv2 比原始版本具有更强的扩展性。==

Indeed, each server could support about 50 clients (instead of just 20).
==事实上，每台服务器可以支持大约 50 个客户端（而不仅仅是 20 个）。==

Let us also gain some perspective on AFS performance by comparing common file-system access scenarios with NFS.
==让我们通过将常见的文件系统访问场景与 NFS 进行比较，来进一步了解 AFS 的性能。==

Figure 50.4 (page 9) shows the results of our qualitative comparison.
==图 50.4（第 9 页）展示了我们定性比较的结果。==

We assume, for the sake of analysis, that an access across the network to the remote server for a file block takes $L_{net}$ time units.
==为了便于分析，我们假设跨网络访问远程服务器获取一个文件块需要 $L_{net}$ 个时间单位。==

Access to local memory takes $L_{mem}$, and access to local disk takes $L_{disk}$.
==访问本地内存需要 $L_{mem}$，访问本地磁盘需要 $L_{disk}$。==

The general assumption is that $L_{net} > L_{disk} > L_{mem}$.
==一般假设是 $L_{net} > L_{disk} > L_{mem}$。==

Second, an interesting difference arises during a large-file sequential re-read (Workload 6).
==其次，在大型文件顺序重新读取（工作负载 6）期间会出现有趣的差异。==

Because AFS has a large local disk cache, it will access the file from there when the file is accessed again.
==由于 AFS 拥有巨大的本地磁盘缓存，当再次访问该文件时，它将从那里访问该文件。==

NFS, in contrast, only can cache blocks in client memory; as a result, if a large file (i.e., a file bigger than local memory) is re-read, the NFS client will have to re-fetch the entire file from the remote server.
==相比之下，NFS 只能在客户端内存中缓存数据块；结果是，如果重新读取一个大文件（即大于本地内存的文件），NFS 客户端将不得不从远程服务器重新获取整个文件。==

Thus, AFS is faster than NFS in this case by a factor of $L_{net} / L_{disk}$, assuming that remote access is indeed slower than local disk.
==因此，在这种情况下，假设远程访问确实比本地磁盘慢，那么 AFS 比 NFS 快了 $L_{net} / L_{disk}$ 倍。==

**50.8 AFS: Other Improvements**
==**50.8 AFS：其他改进**==

AFS provides a true **global namespace** to clients, thus ensuring that all files were named the same way on all client machines.
==AFS 为客户端提供了一个真正的**全局命名空间**，从而确保所有文件在所有客户端机器上的命名方式都相同。==

NFS, in contrast, allows each client to mount NFS servers in any way that they please.
==相比之下，NFS 允许每个客户端以任何他们喜欢的方式挂载 NFS 服务器。==

AFS also takes security seriously, and incorporates mechanisms to authenticate users.
==AFS 还非常重视安全性，并加入了用户身份验证机制。==

AFS also includes facilities for flexible user-managed access control.
==AFS 还包括灵活的、用户管理的访问控制设施。==

**50.9 Summary**
==**50.9 总结**==

AFS shows us how distributed file systems can be built quite differently than what we saw with NFS.
==AFS 向我们展示了分布式文件系统的构建方式可以与我们在 NFS 中看到的截然不同。==

The protocol design of AFS is particularly important; by minimizing server interactions (through whole-file caching and callbacks), each server can support many clients.
==AFS 的协议设计尤为重要；通过（利用全文件缓存和回调）尽量减少服务器交互，每台服务器可以支持许多客户端。==

Perhaps unfortunately, AFS is likely on the decline.
==或许令人遗憾的是，AFS 可能正在走向衰落。==

Because NFS became an open standard, many different vendors supported it.
==因为 NFS 成为了开放标准，许多不同的供应商都支持它。==

**52 A Dialogue on Security**
==**52 关于安全的对话**==

**Professor**: Hello again, student!
==**教授**：你好，同学！==

**Student**: I thought we were done with all this. Will I never be done with this class?
==**学生**：我以为我们已经学完这些了。我永远也上不完这门课了吗？==

**Professor**: That depends on who I am. Some professors want to talk about security and some don’t. Unfortunately for you, given that you’re here, I’m one of those who want to.
==**教授**：这取决于我是谁。有些教授想谈谈安全，有些则不想。对你来说不幸的是，既然你在这儿，我就是那种想谈安全的人。==

**Student**: OK, I suppose we’d better just get on with it.
==**学生**：好吧，我想我们最好直接开始吧。==

**Professor**: That’s the spirit! Let’s say you have a **peach**...
==**教授**：这就对了！假设你有一个**桃子**……==

**Student**: You told me we were at least done with peaches!
==**学生**：你跟我说过我们至少已经告别桃子了！==

**Professor**: When one is discussing security, lies will always be a part of the discussion.
==**教授**：在讨论安全问题时，谎言总是讨论的一部分。==

**Professor**: Anyway, you’ve got a peach. You certainly wouldn’t want to turn around and find someone had stolen your peach, would you?
==**教授**：总之，你有个桃子。你肯定不想一转身发现有人偷了你的桃子，对吧？==

**Student**: Well, I suppose not.
==**学生**：嗯，我想是不想。==

**Professor**: And you probably wouldn’t be any happier if you turned around and discovered someone had swapped out your peach for a **turnip**, either, would you?
==**教授**：如果你一转身发现有人把你的桃子换成了**萝卜**，你大概也不会更高兴，对吧？==

**Student**: I guess not.
==**学生**：我想也是。==

**Professor**: And you also wouldn’t want somebody slapping your hand away every time you reached for your peach, right?
==**教授**：你也不希望每次你去拿桃子时都有人扇开你的手，对吧？==

**Student**: No, that would be pretty rude.
==**学生**：对，那太粗鲁了。==

**Professor**: You wouldn’t want that happening to any of the resources your computer controls, either.
==**教授**：你也不希望这种事发生在计算机控制的任何资源上。==

**Professor**: How can you ensure that secrets remain **confidential**?
==**教授**：你如何确保秘密保持**机密**？==

**Professor**: How can you guarantee the **integrity** of your important data?
==**教授**：你如何保证重要数据的**完整性**？==

**Professor**: How can you ensure that you can use your computer resources when you want to? (**availability**)
==**教授**：你如何确保在你想使用计算机资源时就能使用？（**可用性**）==

**Student**: All this sounds a little like reliability stuff we talked about before...
==**学生**：这听起来有点像我们之前讨论过的可靠性方面的东西……==

**Professor**: Yes and no. Reliability is about accidents. But we’re going a step further. **SOMEBODY WANTS YOUR PEACH!!!!**
==**教授**：是也不是。可靠性是关于意外的。但我们要更进一步。**有人想要你的桃子！！！！**==

**Professor**: When we talk about security, we’re talking about genuine **adversaries**, human adversaries who are trying to make things go wrong for you.
==**教授**：当我们谈论安全时，我们谈论的是真正的**对手**，即试图让你出事的各路人类对手。==

**Professor**: They’re likely to be clever, malevolent, persistent, flexible, and sneaky.
==**教授**：他们很可能聪明、恶毒、固执、灵活且阴险。==

**Student**: This sounds challenging.
==**学生**：这听起来很有挑战性。==

**Professor**: You have no idea... But you will! **YOU WILL!!** (maniacal laughter)
==**教授**：你根本想象不到……但你会明白的！**你会明白的！！**（狂笑）==

**53 Introduction to Operating System Security**
==**53 操作系统安全简介**==

**53.1 Introduction**
==**53.1 引言**==

Security of computing systems is a vital topic whose importance only keeps increasing.
==计算系统的安全是一个至关重要的课题，其重要性在不断增加。==

Operating systems are particularly important from a security perspective. Why?
==从安全角度来看，操作系统尤为重要。为什么？==

To begin with, pretty much everything runs on top of an operating system.
==首先，几乎所有东西都运行在操作系统之上。==

If the software you are running on top of is insecure, what’s above it is going to also be insecure. It’s like building a house on sand.
==如果你运行在其上的软件是不安全的，那么它上面的东西也将是不安全的。这就像在沙地上盖房子。==

Another reason that operating system security is so important is that ultimately all of our software relies on proper behavior of the underlying hardware.
==操作系统安全如此重要的另一个原因是，最终我们所有的软件都依赖于底层硬件的正确行为。==

What has ultimate control of those hardware resources? The operating system.
==谁拥有这些硬件资源的最终控制权？操作系统。==

**CRUX: HOW TO SECURE OS RESOURCES**
==**症结所在：如何保护操作系统资源**==

In the face of multiple possibly concurrent and interacting processes running on the same machine, how can we ensure that the resources each process is permitted to access are exactly those it should access, in exactly the ways we desire?
==面对在同一台机器上运行的多个可能并发且相互交互的进程，我们如何确保每个进程获准访问的资源恰好是它应该访问的，且访问方式完全符合我们的意愿？==

**53.2 What Are We Protecting?**
==**53.2 我们在保护什么？**==

A typical commodity operating system has complete control of all (or almost all) hardware on the machine.
==一个典型的商品操作系统对机器上的所有（或几乎所有）硬件拥有完全的控制权。==

As a result, among the things the OS can do are:
==因此，操作系统可以做的事情包括：==

*   examine or alter any process’s memory
==*   检查或修改任何进程的内存==
*   read, write, delete or corrupt any file
==*   读取、写入、删除或破坏任何文件==
*   change the scheduling or even halt execution of any process
==*   更改调度甚至停止任何进程的执行==

**ASIDE: SECURITY ENCLAVES**
==**旁注：安全飞地**==

Starting in the 1990s, hardware developers began to see a need to keep some hardware isolated, to a degree, from the operating system.
==从 20 世纪 90 年代开始，硬件开发商开始意识到有必要在某种程度上将某些硬件与操作系统隔离。==

**TPM**, or **Trusted Platform Module**, provided assurance that you were booting the version of the operating system you intended to.
==**TPM**（即**受信任平台模块**）提供了保证，确保你正在引导的是你预期的操作系统版本。==

Such hardware elements are called **security enclaves**, since they are meant to allow only safe use of this data, even by the most powerful, trusted code in the system – the operating system itself.
==此类硬件元素被称为**安全飞地**，因为它们旨在只允许安全地使用这些数据，即使是系统中功能最强大、最受信任的代码——操作系统本身也是如此。==

In essence, processes are at the mercy of the operating system.
==本质上，进程受操作系统的摆布。==

Security flaws in your operating system can completely compromise everything about the machine the system runs on.
==操作系统中的安全缺陷可能会完全损害该系统运行机器的一切。==




### 53.3 Security Goals and Policies
==### 53.3 安全目标与策略==

What do we mean when we say we want an operating system, or any system, to be secure?
==当我们说希望一个操作系统，或者任何系统，是“安全”的时，我们到底是什么意思？==

That’s a rather vague statement.
==这其实是一个相当模糊的说法。==

What we really mean is that there are things we would like to happen in the system and things we don’t want to happen, and we’d like a high degree of assurance that we get what we want.
==我们的真实意图是，系统中有些事情是我们希望发生的，有些是不希望发生的，并且我们希望有高度的确定性来保证我们能如愿以偿。==

As in most other aspects of life, we usually end up paying for what we get, so it’s worthwhile to think about exactly what security properties and effects we actually need and then pay only for those, not for other things we don’t need.
==正如生活中的大多数其他方面一样，我们通常需要为所获得的东西付出代价，因此值得去思考我们到底需要哪些安全属性和效果，然后只为这些买单，而不是为不需要的东西付费。==

What this boils down to is that we want to specify the goals we have for the security-relevant behavior of our system and choose defense approaches likely to achieve those goals at a reasonable cost.
==归根结底，我们希望明确系统安全相关行为的目标，并选择能够以合理成本实现这些目标的防御方法。==

Researchers in security have thought about this issue in broad terms for a long time.
==安全领域的研究人员长期以来一直在宏观层面思考这一问题。==

At a high conceptual level, they have defined three big security-related goals that are common to many systems, including operating systems.
==在高级概念层面，他们定义了三个通用的重大安全相关目标，这些目标适用于包括操作系统在内的许多系统。==

They are:
==它们分别是：==

* **Confidentiality** – If some piece of information is supposed to be hidden from others, don’t allow them to find it out.
==* **机密性 (Confidentiality)** —— 如果某条信息本应对他人隐藏，就不要让他们发现它。==

For example, you don’t want someone to learn what your credit card number is – you want that number kept confidential.
==例如，你不希望别人知道你的信用卡号——你希望该号码保持机密。==

* **Integrity** – If some piece of information or component of a system is supposed to be in a particular state, don’t allow an adversary to change it.
==* **完整性 (Integrity)** —— 如果系统的某个信息或组件应该处于特定状态，就不要允许对手更改它。==

For example, if you’ve placed an online order for delivery of one pepperoni pizza, you don’t want a malicious prankster to change your order to 1000 anchovy pizzas.
==例如，如果你在线订购了一份意大利腊肠披萨，你不希望某个恶作剧者将你的订单改为 1000 份鳀鱼披萨。==

One important aspect of integrity is authenticity.
==完整性的一个重要方面是真实性。==

It’s often important to be sure not only that information has not changed, but that it was created by a particular party and not by an adversary.
==通常，我们不仅要确保信息没有被更改，还要确保它是由特定的当事方创建的，而不是由对手创建的。==

* **Availability** – If some information or service is supposed to be available for your own or others’ use, make sure an attacker cannot prevent its use.
==* **可用性 (Availability)** —— 如果某些信息或服务应该供你自己或他人使用，请确保攻击者无法阻止其使用。==

For example, if your business is having a big sale, you don’t want your competitors to be able to block off the streets around your store, preventing your customers from reaching you.
==例如，如果你的商店正在大减价，你不希望竞争对手封锁商店周围的街道，阻止顾客光顾。==

An important extra dimension of all three of these goals is that we want controlled sharing in our systems.
==这三个目标的一个重要额外维度是，我们希望在系统中实现受控共享。==

We share our secrets with some people and not with others.
==我们会与某些人分享秘密，而对其他人保密。==

We allow some people to change our enterprise’s databases, but not just anyone.
==我们允许某些人更改企业的数据库，但不是任何人都可以。==

Some systems need to be made available to a particular set of preferred users (such as those who have paid to play your on-line game) and not to others (who have not).
==某些系统需要对特定的首选用户群（例如那些付费玩在线游戏的人）开放，而对其他人（未付费者）关闭。==

Who’s doing the asking matters a lot, in computers as in everyday life.
==在计算机世界中，就像在日常生活中一样，“谁提出的请求”至关重要。==

Another important aspect of security for computer systems is we often want to be sure that when someone told us something, they cannot later deny that they did so.
==计算机系统安全的另一个重要方面是，我们通常希望确保当某人告诉我们某事时，他们事后无法否认。==

This aspect is often called **non-repudiation**.
==这一方面通常被称为**不可否认性 (non-repudiation)**。==

The harder and more expensive it is for someone to repudiate their actions, the easier it is to hold them to account for those actions, and thus the less likely people are to perform malicious actions.
==一个人抵赖其行为的难度和代价越大，追究其责任就越容易，因此人们实施恶意行为的可能性就越小。==

After all, they might well get caught and will have trouble denying they did it.
==毕竟，他们很可能会被抓住，并且很难否认自己做过。==

These are big, general goals.
==这些都是宏大且通用的目标。==

For a real system, you need to drill down to more detailed, specific goals.
==对于一个真实的系统，你需要深入到更详细、具体的目标。==

In a typical operating system, for example, we might have a confidentiality goal stating that a process’s memory space cannot be arbitrarily read by another process.
==例如，在一个典型的操作系统中，我们可能会有一个机密性目标，即一个进程的内存空间不能被另一个进程任意读取。==

We might have an integrity goal stating that if a user writes a record to a particular file, another user who should not be able to write that file can’t change the record.
==我们可能有一个完整性目标，即如果一个用户向特定文件写入记录，另一个不具备写入该文件权限的用户就不能更改该记录。==

We might have an availability goal stating that one process running on the system cannot hog the CPU and prevent other processes from getting their share of the CPU.
==我们可能有一个可用性目标，即系统中运行的一个进程不能霸占 CPU，从而阻止其他进程获取其应得的 CPU 份额。==

If you think back on what you’ve learned about the process abstraction, memory management, scheduling, file systems, IPC, and other topics from this class, you should be able to think of some other obvious confidentiality, integrity, and availability goals we are likely to want in our operating systems.
==如果你回想一下在本课程中学到的关于进程抽象、内存管理、调度、文件系统、进程间通信（IPC）以及其他主题的知识，你应该能想到我们在操作系统中可能需要的其他一些显而易见的机密性、完整性和可用性目标。==

For any particular system, even goals at this level are not sufficiently specific.
==对于任何特定系统，即使是这种程度的目标也还不够具体。==

The integrity goal alluded to above, where a user’s file should not be overwritten by another user not permitted to do so, gives you a hint about the extra specificity we need in our security goals for a particular system.
==上面提到的完整性目标（即用户的文件不应被未经许可的另一个用户覆盖）为你提示了我们在特定系统的安全目标中需要的额外具体性。==

Maybe there is some user who should be able to overwrite the file, as might be the case when two people are collaborating on writing a report.
==也许有些用户是应该能够覆盖该文件的，比如两个人在协作撰写一份报告。==

But that doesn’t mean an unrelated third user should be able to write that file, if he is not collaborating on the report stored there.
==但这并不意味着一个无关的第三个用户也应该能够写入该文件，如果他没有参与协作那份报告的话。==

We need to be able to specify such detail in our security goals.
==我们需要能够在安全目标中明确这类细节。==

Operating systems are written to be used by many different people with many different needs, and operating system security should reflect that generality.
==操作系统的设计初衷是供许多具有不同需求的人使用，操作系统的安全性也应体现这种通用性。==

What we want in security mechanisms for operating systems is flexibility in describing our detailed security goals.
==我们在操作系统安全机制中追求的是描述详细安全目标的灵活性。==

Ultimately, of course, the operating system software must do its best to enforce those flexible security goals, which implies we’ll need to encode those goals in forms that software can understand.
==当然，操作系统软件最终必须尽力执行这些灵活的安全目标，这意味着我们需要将这些目标编码成软件可以理解的形式。==

We typically must convert our vague understandings of our security goals into highly specific **security policies**.
==我们通常必须将对安全目标模糊的理解转化为高度具体的**安全策略 (security policies)**。==

For example, in the case of the file described above, we might want to specify a policy like ’users A and B may write to file X, but no other user can write it.’
==例如，在上述文件的案例中，我们可能希望指定一条类似“用户 A 和 B 可以写入文件 X，但其他任何用户都不能写入”的策略。==

With that degree of specificity, backed by carefully designed and implemented mechanisms, we can hope to achieve our security goals.
==有了这种程度的具体性，再辅以精心设计和实现的机制，我们就有望实现安全目标。==

Note an important implication for operating system security: in many cases, an operating system will have the mechanisms necessary to implement a desired security policy with a high degree of assurance in its proper application, but only if someone tells the operating system precisely what that policy is.
==注意操作系统安全的一个重要含义：在许多情况下，操作系统拥有实施所需安全策略并保证其正确应用所需的机制，但前提是必须有人准确地告诉操作系统该策略是什么。==

With some important exceptions (like maintaining a process’s address space private unless specifically directed otherwise), the operating system merely supplies general mechanisms that can implement many specific policies.
==除了一些重要的例外（如除非另有明确指示，否则保持进程地址空间的私密性），操作系统仅仅提供通用的机制，这些机制可以实现许多具体的策略。==

Without intelligent design of policies and careful application of the mechanisms, however, what the operating system *should* or *could* do may not be what your operating system *will* do.
==然而，如果没有明智的策略设计和对机制的细致应用，操作系统“应该”或“能够”做的，可能并不是你的操作系统“将会”做的。==

### 53.4 Designing Secure Systems
==### 53.4 设计安全系统==

Few of you will ever build your own operating system, nor even make serious changes to any existing operating system, but we expect many of you will build large software systems of some kind.
==你们中很少有人会去构建自己的操作系统，甚至很少有人会对现有的操作系统进行重大修改，但我们预期你们中的许多人会构建某种大型软件系统。==

Experience of many computer scientists with system design has shown that there are certain design principles that are helpful in building systems with security requirements.
==许多计算机科学家在系统设计方面的经验表明，某些设计原则对于构建具有安全需求的系统非常有帮助。==

These principles were originally laid out by Jerome Saltzer and Michael Schroeder in an influential paper [SS75], though some of them come from earlier observations by others.
==这些原则最初由 Jerome Saltzer 和 Michael Schroeder 在一篇具有影响力的论文 [SS75] 中提出，尽管其中一些源于他人的早期观察。==

While neither the original authors nor later commentators would claim that following them will guarantee that your system is secure, paying attention to them has proven to lead to more secure systems, while you ignore them at your own peril.
==虽然原作者和后来的评论者都不会声称遵循这些原则就能保证系统安全，但事实证明，重视这些原则可以使系统更安全，而忽视它们则需自担风险。==

We’ll discuss them briefly here.
==我们在这里简要讨论一下。==

1. **Economy of mechanism** – This basically means keep your system as small and simple as possible.
==1. **机制最简化 (Economy of mechanism)** —— 这基本上意味着让你的系统尽可能保持小巧和简单。==

Simple systems have fewer bugs and it’s easier to understand their behavior.
==简单的系统 Bug 更少，其行为也更容易理解。==

If you don’t understand your system’s behavior, you’re not likely to know if it achieves its security goals.
==如果你不了解系统的行为，你就很难知道它是否实现了安全目标。==

2. **Fail-safe defaults** – Default to security, not insecurity.
==2. **失效安全默认 (Fail-safe defaults)** —— 默认选择安全，而不是不安全。==

If policies can be set to determine the behavior of a system, have the default for those policies be more secure, not less.
==如果可以通过设置策略来决定系统的行为，请将这些策略的默认值设为更安全的状态。==

3. **Complete mediation** – This is a security term meaning that you should check if an action to be performed meets security policies every single time the action is taken.
==3. **完全中介 (Complete mediation)** —— 这是一个安全术语，意味着每当执行某个动作时，你都应该检查该动作是否符合安全策略。==

4. **Open design** – Assume your adversary knows every detail of your design.
==4. **开放设计 (Open design)** —— 假设你的对手了解你设计的每一个细节。==

If the system can achieve its security goals anyway, you’re in good shape.
==如果在这种情况下系统仍然能实现其安全目标，那么你的状况就很好。==

This principle does not necessarily mean that you actually tell everyone all the details, but base your security on the assumption that the attacker has learned everything.
==这一原则并不一定意味着你真的要把所有细节告诉所有人，而是要基于“攻击者已经掌握了一切”的假设来建立安全性。==

He often has, in practice.
==在实践中，攻击者往往确实做到了这一点。==

5. **Separation of privilege** – Require separate parties or credentials to perform critical actions.
==5. **权限分离 (Separation of privilege)** —— 执行关键操作需要不同的当事方或凭据。==

For example, two-factor authentication, where you use both a password and possession of a piece of hardware to determine identity, is more secure than using either one of those methods alone.
==例如，双因子认证（同时使用密码和持有硬件设备来确定身份）比单独使用其中任何一种方法都更安全。==

6. **Least privilege** – Give a user or a process the minimum privileges required to perform the actions you wish to allow.
==6. **最小权限 (Least privilege)** —— 给予用户或进程执行你希望允许的操作所需的最小权限。==

The more privileges you give to a party, the greater the danger that they will abuse those privileges.
==你赋予当事方的权限越多，他们滥用这些权限的危险就越大。==

Even if you are confident that the party is not malicious, if they make a mistake, an adversary can leverage their error to use their superfluous privileges in harmful ways.
==即使你确信该当事方没有恶意，如果他们犯了错，对手也可以利用其错误，以有害的方式利用那些多余的权限。==

7. **Least common mechanism** – For different users or processes, use separate data structures or mechanisms to handle them.
==7. **最少共享机制 (Least common mechanism)** —— 对于不同的用户或进程，使用独立的数据结构或机制来处理。==

For example, each process gets its own page table in a virtual memory system, ensuring that one process cannot access another’s pages.
==例如，在虚拟内存系统中，每个进程都有自己的页表，确保一个进程无法访问另一个进程的页面。==

8. **Acceptability** – A critical property not dear to the hearts of many programmers.
==8. **可接受性 (Acceptability)** —— 这是一个关键属性，但许多程序员并不在意。==

If your users won’t use it, your system is worthless.
==如果你的用户不愿使用它，你的系统就毫无价值。==

Far too many promising secure systems have been abandoned because they asked too much of their users.
==有太多大有前途的安全系统因为对用户要求过高而被遗弃。==

### 53.5 The Basics of OS Security
==### 53.5 操作系统安全基础==

In a typical operating system, then, we have some set of security goals, centered around various aspects of confidentiality, integrity, and availability.
==因此，在一个典型的操作系统中，我们有一组安全目标，围绕机密性、完整性和可用性的各个方面展开。==

Some of these goals tend to be built in to the operating system model, while others are controlled by the owners or users of the system.
==其中一些目标往往内置于操作系统模型中，而另一些则由系统的所有者或用户控制。==

The built-in goals are those that are extremely common, or must be ensured to make the more specific goals achievable.
==内置目标是那些极其通用的目标，或者是为了使更具体的目标得以实现而必须确保的目标。==

Most of these built-in goals relate to controlling process access to pieces of the hardware.
==这些内置目标大多与控制进程对硬件部分的访问有关。==

That’s because the hardware is shared by all the processes on a system, and unless the sharing is carefully controlled, one process can interfere with the security goals of another process.
==这是因为硬件是由系统上的所有进程共享的，除非这种共享得到严格控制，否则一个进程可能会干扰另一个进程的安全目标。==

Other built-in goals relate to services that the operating system offers, such as file systems, memory management, and interprocess communications.
==其他内置目标与操作系统提供的服务有关，如文件系统、内存管理和进程间通信。==

If these services are not carefully controlled, processes can subvert the system’s security goals.
==如果这些服务没有得到严密控制，进程就可能破坏系统的安全目标。==

Clearly, a lot of system security is going to be related to process handling.
==显然，大量的系统安全都与进程处理有关。==

If the operating system can maintain a clean separation of processes that can only be broken with the operating system’s help, then neither shared hardware nor operating system services can be used to subvert our security goals.
==如果操作系统能够保持进程之间的彻底隔离，且这种隔离只有在操作系统的帮助下才能被打破，那么共享硬件和操作系统服务都无法被用来破坏我们的安全目标。==

That requirement implies that the operating system needs to be careful about allowing use of hardware and of its services.
==这一要求意味着操作系统在允许使用硬件及其服务时需要格外小心。==

For example, the operating system controls virtual memory, which in turn completely controls which physical memory addresses each process can access.
==例如，操作系统控制虚拟内存，而虚拟内存又完全控制每个进程可以访问的物理内存地址。==

Hardware support prevents a process from even naming a physical memory address that is not mapped into its virtual memory space.
==硬件支持甚至能阻止进程说出一个未映射到其虚拟内存空间的物理内存地址。==

System calls offer the operating system another opportunity to provide protection.
==系统调用为操作系统提供了另一个提供保护的机会。==

In most operating systems, processes access system services by making an explicit system call.
==在大多数操作系统中，进程通过发起显式的系统调用来访问系统服务。==

As you have learned, system calls switch the execution mode from the processor’s user mode to its supervisor mode, invoking an appropriate piece of operating system code as they do so.
==正如你所学到的，系统调用将执行模式从处理器的用户模式切换到特权模式（主管模式），并在切换时调用相应的操作系统代码。==

That code can determine which process made the system call and what service the process requested.
==该代码可以确定是哪个进程发起了系统调用，以及该进程请求了什么服务。==

The same mechanism gives the operating system the opportunity to check if the requested service should be allowed under the system’s security policy.
==同样的机制给了操作系统一个机会，去检查请求的服务在系统安全策略下是否应被允许。==

When a process performs a system call, then, the operating system will use the process identifier in the process control block or similar structure to determine the identity of the process.
==因此，当进程执行系统调用时，操作系统将使用进程控制块（PCB）或类似结构中的进程标识符来确定进程的身份。==

The OS can then use **access control mechanisms** to decide if the identified process is **authorized** to perform the requested action.
==然后，操作系统可以使用**访问控制机制 (access control mechanisms)** 来决定识别出的进程是否被**授权 (authorized)** 执行所请求的操作。==

### 53.6 Summary
==### 53.6 总结==

The security of the operating system is vital for both its own and its applications’ sakes.
==操作系统的安全性对于其自身及其应用程序都至关重要。==

Security failures in this software allow essentially limitless bad consequences.
==此类软件中的安全故障基本上会导致无限的严重后果。==

Achieving security in operating systems depends on the security goals one has.
==实现操作系统的安全性取决于所设定的安全目标。==

These goals will typically include goals related to confidentiality, integrity, and availability.
==这些目标通常包括与机密性、完整性和可用性相关的目标。==

As in other areas of operating system design, we handle these varying needs by separating the specific **policies** used by any particular system from the general **mechanisms** used to implement the policies for all systems.
==与操作系统设计的其他领域一样，我们通过将特定系统使用的具体**策略 (policies)** 与用于所有系统实现策略的通用**机制 (mechanisms)** 分离，来处理这些不同的需求。==

---

### 54 Authentication
==### 54 身份认证==

### 54.1 Introduction
==### 54.1 引言==

Context will be everything in operating system decisions on whether to perform some service or to refuse to do so because it will compromise security goals.
==在操作系统决定是否执行某项服务，或因可能危及安全目标而拒绝执行时，上下文（Context）就是一切。==

Perhaps the most important element of that context is who’s doing the asking.
==该上下文中最核心的要素或许就是“谁在请求”。==

In computer security discussions, we often refer to the party asking for something as the **principal**.
==在计算机安全讨论中，我们通常将发起请求的一方称为**主体 (principal)**。==

**Principals** are security-meaningful entities that can request access to resources, such as human users, groups of users, or complex software systems.
==**主体 (Principals)** 是具有安全意义的实体，可以请求访问资源，例如人类用户、用户组或复杂的软件系统。==

The process or other active computing entity performing the request on behalf of a principal is often called its **agent**.
==代表主体执行请求的进程或其他活跃计算实体通常被称为其**代理 (agent)**。==

The request is for access to some particular resource, which we frequently refer to as the **object** of the access request.
==请求是为了访问某个特定资源，我们经常将其称为访问请求的**对象 (object)**。==

Any form of data created and managed by the operating system that keeps track of such access decisions for future reference is often called a **credential**.
==由操作系统创建和管理、用于记录此类访问决策以备将来参考的任何形式的数据，通常被称为**凭据 (credential)**。==

### 54.3 How To Authenticate Users?
==### 54.3 如何认证用户？==

Classically, authenticating the identity of human beings has worked in one of three ways:
==传统上，对人类身份的认证主要通过以下三种方式之一：==

* **Authentication based on what you know**
==* **基于你所知道的认证**==

* **Authentication based on what you have**
==* **基于你所拥有的认证**==

* **Authentication based on what you are**
==* **基于你是什么（生物特征）的认证**==

### 54.4 Authentication By What You Know
==### 54.4 基于你所知道的认证==

Authentication by what you know is most commonly performed by using **passwords**.
==基于“你所知道的”进行的认证最常通过使用**密码 (passwords)** 来完成。==

Interestingly enough, though, our system does not actually need to know the password.
==但有趣的是，我们的系统实际上并不需要知道密码。==

Store a **hash** of the password, not the password itself.
==存储密码的**哈希值 (hash)**，而不是密码本身。==

There is a special class of hashing algorithms called **cryptographic hashes** that make it infeasible to use the hash to figure out what the password is.
==存在一类特殊的哈希算法，称为**密码学哈希 (cryptographic hashes)**，它们使得利用哈希值推算出原密码变得不可行。==

At the time of this writing, **SHA-3** is the US standard for cryptographic hash algorithms, and is a good choice.
==在撰写本文时，**SHA-3** 是美国的密码学哈希算法标准，是一个不错的选择。==

This form of password guessing is called a **dictionary attack**, and it can be highly effective.
==这种形式的密码猜测被称为**字典攻击 (dictionary attack)**，它可能非常有效。==

There’s a simple fix: before hashing a new password and storing it in your password file, generate a big random number (say 32 or 64 bits) and concatenate it to the password.
==有一个简单的解决办法：在对新密码进行哈希处理并存入密码文件之前，生成一个大的随机数（比如 32 位或 64 位），并将其拼接到密码上。==

You typically store the random number (which is called a **salt**) in the password file right next to the hashed password.
==你通常将这个随机数（被称为**盐 (salt)**）存储在密码文件中，紧挨着哈希后的密码。==

Why does this help?
==为什么这样做会有帮助？==

The attacker can no longer create one translation of passwords in the dictionary to their hashes.
==攻击者无法再针对字典中的密码预先生成统一的哈希值映射表。==

If the salt is 32 bits, that’s $2^{32}$ different translations for each word in the dictionary, which makes the approach of pre-computing the translations infeasible.
==如果“盐”是 32 位，那么字典中的每个词就有 $2^{32}$ 种不同的哈希映射，这使得预先计算映射表的方法变得不可行。==

### 54.5 Authentication by What You Have
==### 54.5 基于你所拥有的认证==

Those are both examples of authentication based on what you have, an ID card or a ticket, in these cases.
==在这些案例中，身份证或门票都是基于“你所拥有的”进行认证的例子。==

Some security tokens (sometimes called **dongles**, an unfortunate choice of name) are designed to work that way.
==一些安全令牌（有时被称为**加密狗 (dongles)**，一个不太走运的起名）就是按这种方式设计的。==

### 54.6 Authentication by What You Are
==### 54.6 基于你是什么的认证==

If our operating system can only accurately measure these properties or characteristics, it can distinguish one person from another, solving our authentication problem.
==如果我们的操作系统能够准确测量这些属性或特征，它就能区分不同的人，从而解决我们的认证问题。==



Remember that we’re talking about a computer program (either the OS itself or some separate program it invokes for the purpose) measuring a human characteristic and determining if it belongs to a particular person.
==请记住，我们讨论的是一个计算机程序（操作系统本身或它为此目的调用的某个独立程序）在测量人类特征并确定其是否属于某个特定的人。==

Think about what that entails.
==思考一下这意味着什么。==

What if we plan to use facial recognition with the camera on a smart phone to authenticate the owner of the phone?
==如果我们打算利用智能手机上的摄像头进行人脸识别，以验证手机所有者的身份，该怎么办？==

If we decide it’s the right person, we allow whoever we took the picture of to use the phone.
==如果我们判定是本人，我们就允许被拍照的人使用手机。==

If not, we give them the raspberry (in the cyber sense) and keep them out.
==如果不是，我们就拒绝他们（在网络意义上），并将其拒之门外。==

You should have identified a few challenges here.
==你应该已经在这里发现了一些挑战。==

First, the camera is going to take a picture of someone who is, presumably, holding the phone.
==首先，摄像头将拍摄一张据推测正握着手机的人的照片。==

Maybe it’s the owner, maybe it isn’t.
==可能是所有者，也可能不是。==

That’s the point of taking the picture.
==这正是拍照的目的所在。==

If it isn’t, we should assume whoever it is would like to fool us into thinking that they are the actual owner.
==如果不是，我们应该假设无论对方是谁，都想欺骗我们，让我们认为他们就是真正的所有者。==

What if it’s someone who looks a lot like the right user, but isn’t?
==如果是一个看起来非常像真实用户但又不是本人的人呢？==

What if the person is wearing a mask?
==如果那个人戴着面具呢？==

What if the person holds up a photo of the right user, instead of their own face?
==如果那个人举着真实用户的照片，而不是展示自己的脸呢？==

What if the lighting is dim, or the person isn’t fully facing the camera?
==如果光线昏暗，或者人没有完全面对摄像头呢？==

Alternately, what if it is the right user and the person is not facing the camera, or the lighting is dim, or something else has changed about the person’s look? (e.g., hairstyle)
==或者，如果是真实用户，但此人没有面对摄像头，或者光线昏暗，或者此人的外貌发生了其他变化（例如发型）呢？==

Computer programs don’t recognize faces the way people do.
==计算机程序识别面部的方式与人类不同。==

They do what programs always do with data: they convert it to zeros and ones and process it using some algorithm.
==它们像对待所有数据一样对待照片：将其转换为零和一，并使用某种算法进行处理。==

So that “photo” you took is actually a collection of numbers, indicating shadow and light, shades of color, contrasts, and the like.
==所以你拍摄的那张“照片”实际上是一组数字，表示阴影和光线、色彩深度、对比度等信息。==

OK, now what?
==好，接下来呢？==

Time to decide if it’s the right person’s photo or not!
==是时候决定这是否是正确的人的照片了！==

How?
==如何决定？==

If it were a password, we could have stored the right password (or, better, a hash of the right password) and done a comparison of what got typed in (or its hash) to what we stored.
==如果它是密码，我们可以存储正确的密码（或者更好的是存储正确密码的哈希值），并将输入的内容（或其哈希值）与我们存储的内容进行比对。==

If it’s a perfect match, authenticate.
==如果是完美匹配，则通过身份验证。==

Otherwise, don’t.
==否则，不予通过。==

Can we do the same with this collection of zeros and ones that represent the picture we just took?
==我们能对代表刚才拍摄的照片的这组零和一做同样的事情吗？==

Can we have a picture of the right user stored permanently in some file (also in the form of zeros and ones) and compare the data from the camera to that file?
==我们能否将正确用户的照片永久存储在某个文件中（同样是以零和一的形式），然后将摄像头获取的数据与该文件进行比较？==

Probably not in the same way we compared the passwords.
==可能无法以比较密码的相同方式进行比较。==

Consider one of those factors we just mentioned above: lighting.
==考虑一下我们上面提到的一个因素：光线。==

If the picture we stored in the file was taken under bright lights and the picture coming out of the camera was taken under dim lights, the two sets of zeros and ones are most certainly not going to match.
==如果存储在文件中的照片是在强光下拍摄的，而摄像头输出的照片是在昏暗的光线下拍摄的，那么这两组零和一肯定无法匹配。==

In fact, it’s quite unlikely that two pictures of the same person, taken a second apart under identical conditions, would be represented by exactly the same set of bits.
==事实上，即使是同一个人在相同条件下间隔一秒拍摄的两张照片，也极不可能由完全相同的位集（bits）表示。==

So clearly we can’t do a comparison based on bit-for-bit equivalence.
==所以显然我们不能进行基于位对位等价（bit-for-bit equivalence）的比较。==

Instead, we need to compare based on a higher-level analysis of the two photos, the stored one of the right user and the just-taken one of the person who claims to be that user.
==相反，我们需要基于对两张照片的高级分析进行比较：一张是存储的正确用户的照片，另一张是声称是该用户的、刚刚拍摄的照片。==

Generally this will involve extracting higher-level features from the photos and comparing those.
==通常，这涉及从照片中提取高级特征并对这些特征进行比较。==

We might, for example, try to calculate the length of the nose, or determine the color of the eyes, or make some kind of model of the shape of the mouth.
==例如，我们可能会尝试计算鼻子的长度，或确定眼睛的颜色，或者为嘴巴的形状建立某种模型。==

Then we would compare the same feature set from the two photos.
==然后我们会比较两张照片中相同的特征集。==

Even here, though, an exact match is not too likely.
==不过即使如此，精确匹配的可能性也不大。==

The lighting, for example, might slightly alter the perceived eye color.
==例如，光线可能会稍微改变感知的眼睛颜色。==

So we’ll need to allow some sloppiness in our comparison.
==因此，我们需要在比较中允许一定的冗余度（sloppiness）。==

If the feature match is “close enough,” we authenticate.
==如果特征匹配“足够接近”，我们就通过身份验证。==

If not, we don’t.
==否则，我们不予通过。==

We will look for close matches, not perfect matches, which brings the nose of the camel of tolerances into our authentication tent.
==我们将寻找接近的匹配，而不是完美的匹配，这就在我们的身份验证体系中引入了容差的概念。==

If we are intolerant of all but the closest matches, on some days we will fail to match the real user’s picture to the stored version.
==如果我们除了最接近的匹配之外不容忍任何偏差，那么在某些日子里，我们将无法将真实用户的照片与存储版本相匹配。==

That’s called a **false negative**, since we incorrectly decided not to authenticate.
==这被称为**漏报**（false negative），因为我们错误地决定不通过身份验证。==

If we are too tolerant of differences in measured versus stored data, we will authenticate a user whom is not who they claim to be.
==如果我们对测量数据与存储数据之间的差异过于宽容，我们就会通过一个并非其声称身份的用户的验证。==

That’s a **false positive**, since we incorrectly decided to authenticate.
==这是一个**误报**（false positive），因为我们错误地决定通过身份验证。==

The nature of biometrics is that any implementation will have a characteristic false positive and false negative rate.
==生物识别的本质在于，任何实现都将具有特征性的误报率和漏报率。==

Both are bad, so you’d like both to be low.
==两者都是有害的，所以你希望两者都保持在较低水平。==

For any given implementation of some biometric authentication technique, you can typically tune it to achieve some false positive rate, or tune it to achieve some false negative rate.
==对于某种生物识别认证技术的任何特定实现，你通常可以对其进行调整以达到特定的误报率，或者调整它以达到特定的漏报率。==

But you usually can’t minimize both.
==但你通常无法同时使两者最小化。==

As the false positive rate goes down, the false negative rate goes up, and vice versa.
==随着误报率下降，漏报率就会上升，反之亦然。==

The **sensitivity** describes how close the match must be.
==**灵敏度**（sensitivity）描述了匹配必须达到多接近的程度。==

Figure 54.1 shows the typical relationship between these error rates.
==图 54.1 显示了这些错误率之间的典型关系。==

Note the circle at the point where the two curves cross.
==注意两条曲线相交处的圆圈。==

That point represents the **crossover error rate**, a common metric for describing the accuracy of a biometric.
==该点代表**交叉错误率**（crossover error rate），这是描述生物识别准确性的常用指标。==

It represents an equal tradeoff between the two kinds of errors.
==它代表了两种错误之间的对等权衡。==

It’s not always the case that one tunes a biometric system to hit the crossover error rate, since you might care more about one kind of error than the other.
==人们并不总是将生物识别系统调整到交叉错误率，因为你可能更看重其中一种错误。==

For example, a smart phone that frequently locks its legitimate user out because it doesn’t like today’s fingerprint reading is not going to be popular, while the chances of a thief who stole the phone having a similar fingerprint are low.
==例如，一款因为不喜欢今天的指纹读取而经常将合法用户拒之门外的智能手机是不会受欢迎的，而偷走手机的小偷拥有相似指纹的概率却很低。==

Perhaps low false negatives matter more here.
==在这种情况下，较低的漏报率可能更为重要。==

On the other hand, if you’re opening a bank vault with a retinal scan, requiring the bank manager to occasionally provide a second scan isn’t too bad, while allowing a robber to open the vault with a bogus fake eye would be a disaster.
==另一方面，如果你是用视网膜扫描开启银行金库，要求银行经理偶尔进行第二次扫描并无大碍，而允许强盗用伪造的假眼打开金库则会是一场灾难。==

Low false positives might be better here.
==在这种情况下，较低的误报率可能更好。==

Leaving aside the issues of reliability of authentication using biometrics, another big issue for using human characteristics to authenticate is that many of the techniques for measuring them require special hardware not likely to be present on most machines.
==撇开使用生物识别进行身份验证的可靠性问题不谈，使用人体特征进行身份验证的另一个大问题是，许多测量技术需要大多数机器上不太可能配备的专用硬件。==

Many computers (including smart phones, tablets, and laptops) are likely to have cameras, but embedded devices and server machines probably don’t.
==许多计算机（包括智能手机、平板电脑和笔记本电脑）很可能配有摄像头，但嵌入式设备和服务器机器可能没有。==

Relatively few machines have fingerprint readers, and even fewer are able to measure more exotic biometrics.
==相对较少的机器配有指纹读取器，能够测量更奇特的生物特征的机器就更少了。==

While a few biometric techniques (such as measuring typing patterns) require relatively common hardware that is likely to be present on many machines anyway, there aren’t many such techniques.
==虽然少数生物识别技术（如测量打字模式）需要相对通用的硬件，而这些硬件在许多机器上通常都已经存在，但这类技术的数量并不多。==

Even if a special hardware device is available, the convenience of using them for this purpose can be limiting.
==即使可以使用专用的硬件设备，为了这个目的而使用它们的便利性也可能受到限制。==

One further issue you want to think about when considering using biometric authentication is whether there is any physical gap between where the biometric quantity is measured and where it is checked.
==在考虑使用生物识别身份验证时，你还需要考虑的一个问题是，生物特征值的测量地点与核对地点之间是否存在物理间隙。==

In particular, checking biometric readings provided by an untrusted machine across the network is hazardous.
==特别是，通过网络核对由不受信任的机器提供的生物识别读数是危险的。==

What comes in across the network is simply a pattern of bits spread across one or more messages, whether it represents a piece of a web page, a phoneme in a VoIP conversation, or part of a scanned fingerprint.
==通过网络传输的仅仅是分布在一个或多个消息中的位模式（pattern of bits），无论它代表的是网页片段、VoIP 通话中的音素，还是扫描指纹的一部分。==

Bits are bits, and anyone can create any bit pattern they want.
==位（bits）就是位，任何人都可以创建他们想要的任何位模式。==

If a remote adversary knows what the bit pattern representing your fingerprint looks like, they may not need your finger, or even a fingerprint scanner, to create it and feed it to your machine.
==如果远程对手知道代表你指纹的位模式是什么样的，他们可能不需要你的手指，甚至不需要指纹扫描仪，就可以创建该模式并将其输入你的机器。==

When the hardware performing the scanning is physically attached to your machine, there is less opportunity to slip in a spurious bit pattern that didn’t come from the device.
==当执行扫描的硬件物理连接到你的机器时，插入不属于该设备的伪造位模式的机会就较少。==

When the hardware is on the other side of the world on a machine you have no control over, there is a lot more opportunity.
==当硬件位于世界另一端你无法控制的机器上时，机会就会多得多。==

The point here is to be careful with biometric authentication information provided to you remotely.
==这里的重点是对远程提供给你的生物识别身份验证信息保持警惕。==

In all, it sort of sounds like biometrics are pretty terrible for authentication, but that’s the wrong lesson.
==总而言之，这听起来似乎生物识别在身份验证方面非常糟糕，但这是错误的结论。==

For that matter, previous sections probably made it sound like all methods of authentication are terrible.
==就此而言，前面的章节可能让所有的身份验证方法听起来都很糟糕。==

Certainly none of them are perfect, but your task as a system designer is not to find the perfect authentication mechanism, but to use mechanisms that are well suited to your system and its environment.
==当然，没有哪种方法是完美的，但作为系统设计者，你的任务不是寻找完美的身份验证机制，而是使用非常适合你的系统及其环境的机制。==

A good fingerprint reader built in to a smart phone might do its job quite well.
==内置在智能手机中的优质指纹读取器可能会表现得相当出色。==

A long, unguessable password can provide a decent amount of security.
==长且不可猜测的密码可以提供相当程度的安全性。==

Well-designed smart cards can make it nearly impossible to authenticate yourself without having them in your hand.
==设计良好的智能卡可以让你在没有随身携带的情况下几乎无法通过身份验证。==

And where each type of mechanism fails, you can perhaps correct for that failure by using a second or third authentication mechanism that doesn’t fail in the same cases.
==在每种机制失效的情况下，你也许可以通过使用第二或第三种在相同情况下不会失效的身份验证机制来弥补这种缺陷。==

**54.7 Authenticating Non-Humans**
==**54.7 非人类身份验证**==

No, we’re not talking about aliens or extra-dimensional beings, or even your cat.
==不，我们讨论的不是外星人、异次元生物，甚至也不是你的猫。==

If you think broadly about how computers are used today, you’ll see that there are many circumstances in which no human user is associated with a process that’s running.
==如果你从更广泛的角度思考当今计算机的使用方式，你会发现在许多情况下，正在运行的进程并未与任何人类用户相关联。==

Consider a web server.
==以 Web 服务器为例。==

There really isn’t some human user logged in whose identity should be attached to the web server.
==实际上并没有某个已登录的人类用户需要将其身份附加到 Web 服务器上。==

Or think about embedded devices, such as a smart light bulb.
==或者想想嵌入式设备，比如智能灯泡。==

Nobody logs in to a light bulb, but there is certainly code running there, and quite likely it is process-oriented code.
==没有人会登录灯泡，但那里肯定有代码在运行，而且很可能是面向进程的代码。==

Mechanically, the operating system need not have a problem with the identities of such processes.
==从机制上讲，操作系统不应对此类进程的身份产生问题。==

Simply set up a user called **webserver** or **lightbulb** on the system in question and attach the identity of that “user” to the processes that are associated with running the web server or turning the light bulb on and off.
==只需在相关系统上设置一个名为 **webserver** 或 **lightbulb** 的用户，并将该“用户”的身份附加到与运行 Web 服务器或开关灯泡相关的进程中。==

But that does lead to the question of how you make sure that only real web server processes are tagged with that identity.
==但这也引出了一个问题：你如何确保只有真正的 Web 服务器进程被标记为该身份？==

We wouldn’t want some arbitrary user on the web server machine creating processes that appear to belong to the server, rather than to that user.
==我们不希望 Web 服务器机器上的任何任意用户创建看起来属于服务器、而不是属于该用户的进程。==

One approach is to use passwords for these non-human users, as well.
==一种方法是也为这些非人类用户使用密码。==

Simply assign a password to the web server user.
==只需为 Web 服务器用户分配一个密码。==

When does it get used?
==什么时候使用它？==

When it’s needed, which is when you want to create a process belonging to the web server, but you don’t already have one in existence.
==在需要的时候使用，也就是当你想要创建一个属于 Web 服务器的进程，但目前还没有这类进程时。==

The system administrator could log in as the web server user, creating a command shell and using it to generate the actual processes the server needs to do its business.
==系统管理员可以以 Web 服务器用户的身份登录，创建一个命令行 Shell，并使用它生成服务器业务所需的实际进程。==

As usual, the processes created by this shell process would inherit their parent’s identity, **webserver**, in this case.
==通常情况下，由此 Shell 进程创建的进程将继承其父进程的身份，在这种情况下即为 **webserver**。==

More commonly, we skip the go-between (here, the login) and provide some mechanism whereby the privileged user is permitted to create processes that belongs not to that user, but to some other user such as **webserver**.
==更常见的是，我们跳过中间步骤（这里指登录），并提供某种机制，允许特权用户创建不属于该用户、而是属于其他用户（如 **webserver**）的进程。==

Alternately, we can provide a mechanism that allows a process to change its ownership, so the web server processes would start off under some other user’s identity (such as the system administrator’s) and change their ownership to **webserver**.
==或者，我们可以提供一种允许进程更改其所有权的机制，这样 Web 服务器进程最初在其他用户身份（如系统管理员）下启动，然后将其所有权更改为 **webserver**。==

Yet another approach is to allow a temporary change of process identity, while still remembering the original identity.
==还有一种方法是允许临时更改进程身份，同时仍然记住原始身份。==

(We’ll say more about this last approach in a future chapter.)
==（我们将在以后的章节中详细讨论最后一种方法。）==

Obviously, any of these approaches require strong controls, since they allow one user to create processes belonging to another user.
==显然，这些方法中的任何一种都需要强大的控制，因为它们允许一个用户创建属于另一个用户的进程。==

As mentioned above, passwords are the most common authentication method used to determine if a process can be assigned to one of these non-human users.
==如上所述，密码是用于确定是否可以将进程分配给这些非人类用户的最常用的身份验证方法。==

Sometimes no authentication of the non-human user is required at all, though.
==不过，有时根本不需要对非人类用户进行身份验证。==

Instead, certain other users (like trusted system administrators) are given the right to assign new identities to the processes they create, without providing any further authentication information than their own.
==相反，某些其他用户（如受信任的系统管理员）被赋予将新身份分配给他们创建的进程的权利，除了他们自己的身份验证信息外，无需提供任何进一步的身份验证信息。==

In Linux and other Unix systems, the `sudo` command offers this capability.
==在 Linux 和其他 Unix 系统中，`sudo` 命令提供了这种功能。==

For example, if you type the following:
==例如，如果你输入以下内容：==

`sudo -u webserver apache2`
`sudo -u webserver apache2`

This would indicate that the `apache2` program should be started under the identity of `webserver`, rather than under the identity of whoever ran the `sudo` command.
==这将表明 `apache2` 程序应该在 `webserver` 的身份下启动，而不是在运行 `sudo` 命令的那个人的身份下启动。==

This command might require the user running it to provide their own authentication credentials (for extra certainty that it really is the privileged user asking for it, and not some random visitor accessing the computer during the privileged user’s coffee break), but would not require authentication information associated with `webserver`.
==此命令可能要求运行它的用户提供他们自己的身份验证凭据（以额外确保确实是特权用户在请求，而不是某个在特权用户喝咖啡休息时访问计算机的随机访客），但不需要与 `webserver` 相关的身份验证信息。==

Any sub-processes created by `apache2` would, of course, inherit the identity of `webserver`.
==当然，`apache2` 创建的任何子进程都将继承 `webserver` 的身份。==

We’ll say more about `sudo` in the chapter on access control.
==我们将在访问控制一章中进一步讨论 `sudo`。==

One final identity issue we alluded to earlier is that sometimes we wish to identify not just individual users, but groups of users who share common characteristics, usually security-related characteristics.
==我们之前提到的最后一个身份问题是，有时我们不仅希望识别单个用户，还希望识别共享共同特征（通常是与安全相关的特征）的用户组。==

For example, we might have four or five system administrators, any one of whom is allowed to start up the web server.
==例如，我们可能有四或五名系统管理员，其中任何一人都被允许启动 Web 服务器。==

Instead of associating the privilege with each one individually, it’s advantageous to create a system-meaningful group of users with that privilege.
==与其将特权分别与每个人关联，不如创建一个具有该特权的、对系统有意义的用户组，这样做更有利。==

We would then indicate that the four or five administrators are members of that group.
==然后我们将指明这四或五名管理员是该组的成员。==

This kind of group is another example of a security-relevant principal, since we will make our decisions on the basis of group membership, rather than individual identity.
==这种组是另一个与安全相关的客体（principal）示例，因为我们将根据组成员身份而不是个人身份做出决策。==

When one of the system administrators wished to do something requiring group membership, we would check that he or she was a member.
==当其中一名系统管理员希望执行需要组成员身份的操作时，我们将检查他或她是否是该组的成员。==

We can either associate a group membership with each process, or use the process’s individual identity information as an index into a list of groups that people belong to.
==我们既可以将组成员身份与每个进程关联，也可以使用进程的个人身份信息作为索引进入人们所属的组列表。==

The latter is more flexible, since it allows us to put each user into an arbitrary number of groups.
==后者更灵活，因为它允许我们将每个用户放入任意数量的组中。==

Most modern operating systems, including Linux and Windows, support these kinds of groups, since they provide ease and flexibility in dealing with application of security policies.
==包括 Linux 和 Windows 在内的大多数现代操作系统都支持这类组，因为它们在处理安全策略的应用时提供了便利和灵活性。==

They handle group membership and group privileges in manners largely analogous to those for individuals.
==它们处理组成员身份和组特权的方式在很大程度上类似于处理个人的方式。==

For example, a child process will usually have the same group-related privileges as its parent.
==例如，子进程通常会具有与其父进程相同的与组相关的特权。==

When working with such systems, it’s important to remember that group membership provides a second path by which a user can obtain access to a resource, which has its benefits and its dangers.
==在使用此类系统时，必须记住，组成员身份为用户提供了获取资源访问权限的第二条路径，这既有好处，也有危险。==

**54.8 Summary**
==**54.8 总结**==

If we want to apply security policies to actions taken by processes in our system, we need to know the identity of the processes, so we can make proper decisions.
==如果我们想对系统中进程采取的操作应用安全策略，我们需要知道进程的身份，以便做出正确的决策。==

We start the entire chain of processes by creating a process at boot time belonging to some system user whose purpose is to authenticate users.
==我们在启动时创建一个属于某个系统用户的进程，从而启动整个进程链，该系统用户的目的是对用户进行身份验证。==

They log in, providing authentication information in one or more forms to prove their identity.
==用户登录，以一种或多种形式提供身份验证信息以证明其身份。==

The system verifies their identity using this information and assigns their identity to a new process that allows the user to go about their business, which typically involves running other processes.
==系统利用这些信息验证他们的身份，并将其身份分配给一个允许用户处理业务的新进程，这通常涉及运行其他进程。==

Those other processes will inherit the user’s identity from their parent process.
==这些其他进程将从其父进程继承用户的身份。==

Special secure mechanisms can allow identities of processes to be changed or to be set to something other than the parent’s identity.
==特殊的安全机制可以允许更改进程的身份，或者将其设置为父进程身份以外的其他身份。==

The system can then be sure that processes belong to the proper user and can make security decisions accordingly.
==系统随后可以确信进程属于正确的用户，并据此做出安全决策。==

Historically and practically, the authentication information provided to the system is either something the authenticating user knows (like a password or PIN), something the user has (like a smart card or proof of possession of a smart phone), or something the user is (like the user’s fingerprint or voice scan).
==从历史和实践的角度来看，提供给系统的身份验证信息要么是验证用户知道的内容（如密码或 PIN），要么是用户拥有的内容（如智能卡或智能手机的持有证明），或者是用户本身具备的特征（如用户的指纹或语音扫描）。==

Each of these approaches has its strengths and weaknesses.
==每种方法都有其优缺点。==

A higher degree of security can be obtained by using multi-factor authentication, which requires a user to provide evidence of more than one form, such as requiring both a password and a one-time code that was texted to the user’s smart phone.
==通过使用多因素身份验证可以获得更高程度的安全性，这要求用户提供多种形式的证据，例如同时要求密码和发送到用户智能手机的一次性代码。==

**55 Access Control**
==**55 访问控制**==

**55.1 Introduction**
==**55.1 引言**==

So we know what our security goals are, we have at least a general sense of the security policies we’d like to enforce, and we have some evidence about who is requesting various system services that might (or might not) violate our policies.
==既然我们知道了我们的安全目标，至少对我们想要执行的安全策略有了大致的了解，并且我们掌握了一些关于谁在请求各种可能（或可能不）违反我们策略的系统服务的证据。==

Now we need to take that information and turn it into something actionable, something that a piece of software can perform for us.
==现在我们需要获取这些信息并将其转化为可执行的操作，即软件可以为我们执行的操作。==

There are two important steps here:
==这里有两个重要的步骤：==

1. Figure out if the request fits within our security policy.
==1. 确定该请求是否符合我们的安全策略。==

2. If it does, perform the operation. If not, make sure it isn’t done.
==2. 如果符合，则执行该操作。如果不符合，请确保该操作不被执行。==

The first step is generally referred to as **access control**.
==第一步通常被称为**访问控制**。==

We will determine which system resources or services can be accessed by which parties in which ways under which circumstances.
==我们将决定哪些系统资源或服务可以在什么样的情况下，被哪些方以何种方式访问。==

Basically, it boils down to another of those binary decisions that fit so well into our computing paradigms: yes or no.
==从根本上说，它归结为另一种非常适合我们计算范式的二元决策：是或否。==

But how to make that decision?
==但是如何做出那个决定呢？==

To make the problem more concrete, consider this case.
==为了使问题更加具体，请考虑这种情况。==

User X wishes to read and write file `/var/foo`.
==用户 X 希望读取和写入文件 `/var/foo`。==

Under the covers, this case probably implies that a process being run under the identity of User X issued a system call such as:
==在底层，这种情况可能意味着在用户 X 的身份下运行的进程发出了如下系统调用：==

`open("/var/foo", O_RDWR)`
`open("/var/foo", O_RDWR)`

Note here that we’re not talking about the Linux `open()` call, which is a specific implementation that handles access control a specific way.
==注意，这里我们讨论的不是 Linux 的 `open()` 调用，那是一个以特定方式处理访问控制的特定实现。==

We’re talking about the general idea of how you might be able to control access to a file open system call.
==我们讨论的是如何控制文件打开系统调用访问权限的通用理念。==

Hence the different font, to remind you.
==因此使用了不同的字体以提醒你。==

How should the system handle this request from the process, making sure that the file is not opened if the security policy to be enforced forbids it, but equally making sure that the file is opened if the policy allows it?
==系统应该如何处理来自进程的这个请求，既要确保在执行的安全策略禁止时文件不会被打开，又要同样确保在策略允许时文件会被打开？==

We know that the system call will trap to the operating system, giving it the opportunity to do something to make this decision.
==我们知道系统调用会陷（trap）入操作系统，使其有机会采取行动做出此决策。==

Mechanically, speaking, what should that “something” be?
==从机制上讲，那个“行动”应该是什么？==

**THE CRUX OF THE PROBLEM:**
==**问题的核心：**==

**HOW TO DETERMINE IF AN ACCESS REQUEST SHOULD BE GRANTED?**
==**如何确定访问请求是否应被批准？**==

How can the operating system decide if a particular request made by a particular process belonging to a particular user at some given moment should or should not be granted?
==操作系统如何决定由属于特定用户的特定进程在特定时刻发出的特定请求是否应该被批准？==

What information will be used to make this decision?
==将使用什么信息来做出这个决定？==

How can we set this information to encode the security policies we want to enforce for our system?
==我们如何设置这些信息来对我们想要为系统执行的安全策略进行编码？==

**55.2 Important Aspects Of The Access Control Problem**
==**55.2 访问控制问题的重要方面**==

As usual, the system will run some kind of algorithm to make this decision.
==通常情况下，系统将运行某种算法来做出此决定。==

It will take certain inputs and produce a binary output, a yes-or-no decision on granting access.
==它将获取某些输入并产生二元输出，即关于授予访问权限的“是”或“否”的决定。==

At the high level, access control is usually spoken of in terms of **subjects**, **objects**, and **access**.
==在高级别上，访问控制通常根据**主体**（subjects）、**客体**（objects）和**访问**（access）来讨论。==

A **subject** is the entity that wants to perform the access, perhaps a user or a process.
==**主体**是想要执行访问的实体，可能是一个用户或一个进程。==

An **object** is the thing the subject wants to access, perhaps a file or a device.
==**客体**是主体想要访问的东西，可能是一个文件或一个设备。==

**Access** is some particular mode of dealing with the object, such as reading it or writing it.
==**访问**是处理客体的某种特定模式，例如读取或写入。==

So an access control decision is about whether a particular subject is allowed to perform a particular mode of access on a particular object.
==因此，访问控制决策是关于是否允许特定主体对特定客体执行特定模式的访问。==

We sometimes refer to the process of determining if a particular subject is allowed to perform a particular form of access on a particular object as **authorization**.
==我们有时将确定是否允许特定主体对特定客体执行特定形式的访问的过程称为**授权**（authorization）。==

One relevant issue is when will access control decisions be made?
==一个相关的问题是，何时做出访问控制决策？==

The system must run whatever algorithm it uses every time it makes such a decision.
==系统每次做出此类决策时都必须运行其使用的任何算法。==

The code that implements this algorithm is called a **reference monitor**, and there is an obvious incentive to make sure it is implemented both correctly and efficiently.
==实现此算法的代码被称为**引用监视器**（reference monitor），显然有动机确保它的实现既正确又高效。==

If it’s not correct, you make the wrong access decisions – obviously bad.
==如果不正确，你就会做出错误的访问决策——显然这是有害的。==

Its efficiency is important because it will inject some overhead whenever it is used.
==它的效率很重要，因为无论何时使用它都会引入一些开销。==

Perhaps we wish to minimize these overheads by not checking access control on every possible opportunity.
==也许我们希望通过不针对每个可能的时机检查访问控制来最小化这些开销。==

On the other hand, remember that principle of complete mediation we introduced a couple of chapters back?
==另一方面，还记得我们在几章前介绍的全中介（complete mediation）原则吗？==

That principle said we should check security conditions every time someone asked for something.
==该原则指出，每当有人请求某样东西时，我们都应该检查安全状况。==

Clearly, we’ll need to balance costs against security benefits.
==显然，我们需要在成本和安全效益之间进行权衡。==

But if we can find some beneficial special cases where we can achieve low cost without compromising security, we can possibly manage to avoid trading off one for the other, at least in those cases.
==但如果我们能找到一些有益的特殊情况，在这些情况下我们可以在不损害安全性的情况下实现低成本，那么我们或许能够避免在这两者之间进行取舍，至少在这些情况下是这样。==

One way to do so is to give subjects objects that belong only to them.
==实现这一点的一种方法是给主体只属于它们自己的客体。==

If the object is inherently theirs, by its very nature and unchangeably so, the system can let the subject (a process, in the operating system case) access it freely.
==如果客体本质上属于它们，由于其性质且不可更改，系统就可以让主体（在操作系统的情况下为进程）自由地访问它。==

Virtualization allows us to create virtual objects of this kind.
==虚拟化允许我们创建这种类型的虚拟客体。==

Virtual memory is an excellent example.
==虚拟内存就是一个绝佳的例子。==

A process is allowed to access its virtual memory freely, with no special operating system access control check at the moment the process tries to use it.
==进程被允许自由访问其虚拟内存，在进程尝试使用它时，操作系统无需进行特殊的访问控制检查。==

A good thing, too, since otherwise we would need to run our access control algorithm on every process memory reference, which would lead to a ridiculously slow system.
==这也是件好事，否则我们就需要对每一次进程内存引用运行访问控制算法，这将导致系统速度极其缓慢。==

We can play similar virtualization tricks with peripheral devices.
==我们也可以对外部设备玩类似的虚拟化花招。==

If a process is given access to some virtual device, which is actually backed up by a real physical device controlled by the OS, and if no other process is allowed to use that device, the operating system need not check for access control every time the process wants to use it.
==如果一个进程被赋予了访问某个虚拟设备的权限，而该设备实际上是由操作系统控制的真实物理设备支撑的，并且如果不允许其他进程使用该设备，那么操作系统就不必在进程每次想要使用它时都进行访问控制检查。==

For example, a process might be granted control of a GPU based on an initial access control decision, after which the process can write to the GPU’s memory or issue instructions directly to it without further intervention by the OS.
==例如，一个进程可能会基于初始访问控制决策被授予 GPU 的控制权，之后该进程就可以写入 GPU 的内存或直接向其发出指令，而无需操作系统的进一步干预。==

Of course, as discussed earlier, virtualization is mostly an operating-system provided illusion.
==当然，如前所述，虚拟化主要是操作系统提供的一种幻觉。==

Processes share memory, devices, and other computing resources.
==进程共享内存、设备和其他计算资源。==

What appears to be theirs alone is actually shared, with the operating system running around behind the scenes to keep the illusion going, sometimes assisted by special hardware.
==那些看起来属于它们独有的东西实际上是共享的，操作系统在后台运行以维持这种幻觉，有时还辅以专门的硬件。==

That means the operating system, without the direct knowledge and participation of the applications using the virtualized resource, still has to make sure that only proper forms of access to it are allowed.
==这意味着操作系统在不让使用虚拟化资源的应用程序直接知晓和参与的情况下，仍然必须确保只允许对其进行正确的访问形式。==

So merely relying on virtualization to ensure proper access just pushes the problem down to protecting the virtualization functionality of the OS.
==因此，仅仅依靠虚拟化来确保正确的访问，只是将问题下移到了保护操作系统的虚拟化功能上。==

Even if we leave that issue aside, sooner or later we have to move past cheap special cases and deal with the general problem.
==即使撇开这个问题不谈，我们迟早也必须跨越廉价的特殊情况，去处理一般性问题。==

Subject X wants to read and write object `/tmp/foo`.
==主体 X 想要读取和写入客体 `/tmp/foo`。==

Maybe it’s allowable, maybe it isn’t.
==也许这是允许的，也许不是。==

Now what?
==现在怎么办？==

Computer scientists have come up with two basic approaches to solving this question, relying on different data structures and different methods of making the decision.
==计算机科学家已经提出了解决这个问题的两种基本方法，它们依赖于不同的数据结构和不同的决策方法。==

One is called **access control lists** and the other is called **capabilities**.
==一种被称为**访问控制列表**（access control lists），另一种被称为**权标/能力**（capabilities）。==

It’s actually a little inaccurate to claim that computer scientists came up with these approaches, since they’ve been in use in non-computer contexts for millennia.
==声称计算机科学家发明了这些方法实际上有点不准确，因为它们已经在非计算机语境中使用了数千年。==

Let’s look at them in a more general perspective before we consider operating system implementations.
==在考虑操作系统实现之前，让我们从更普遍的角度来看待它们。==

Let’s say we want to start an exclusive nightclub (called, perhaps, Chez Andrea) restricted to only the best operating system researchers and developers.
==假设我们想创办一家高级夜总会（也许叫 Chez Andrea），仅限最优秀的操作系统研究人员和开发人员进入。==

We don’t want to let any of those database or programming language people slip in, so we’ll need to make sure only our approved customers get through the door.
==我们不想让任何数据库或编程语言领域的人溜进来，所以我们需要确保只有经过我们批准的客户才能进门。==

How might we do that?
==我们该如何做到这一点？==

One way would be to hire a massive intimidating bouncer who has a list of all the approved members.
==一种方法是雇佣一名身材魁梧、令人生畏的保镖，他手里有一份所有获批会员的名单。==

When someone wants to enter the club, they would prove their identity to the bouncer, and the bouncer would see if they were on the list.
==当有人想要进入俱乐部时，他们会向保镖证明自己的身份，保镖会查看他们是否在名单上。==

If it was Linus Torvalds or Barbara Liskov, the bouncer would let them in, but would keep out the hoi polloi networking folks who had failed to distinguish themselves in operating systems.
==如果是 Linus Torvalds 或 Barbara Liskov，保镖会让他们进去，但会将那些在操作系统领域没能出人头地的普通网络技术人员拒之门外。==

Another approach would be to put a really great lock on the door of the club and hand out keys to that lock to all of our OS buddies.
==另一种方法是在俱乐部的门上装一把非常高级的锁，并向我们所有的操作系统伙伴发放该锁的钥匙。==

If Jerome Saltzer wanted to get in to Chez Andrea, he’d merely pull out his key and unlock the door.
==如果 Jerome Saltzer 想进入 Chez Andrea，他只需要掏出钥匙开门即可。==

If some computer architects with no OS chops wanted to get in, they wouldn’t have a key and thus would be stuck outside.
==如果一些没有操作系统功底的计算机架构师想进来，他们就没有钥匙，因此会被困在门外。==

Compared to the other approach, we’d save on the salary of the bouncer, though we would have to pay for the locks and keys.
==与另一种方法相比，我们可以节省保镖的薪水，尽管我们必须支付锁和钥匙的费用。==

As new luminaries in the OS field emerge who we want to admit, we’ll need new keys for them, and once in a while we may make a mistake and hand out a key to someone who doesn’t deserve it, or a member might lose a key, in which case we need to make sure that key no longer opens the club door.
==随着我们想要接纳的操作系统领域新泰斗的出现，我们需要为他们提供新钥匙，而且偶尔我们可能会犯错，把钥匙发给不该给的人，或者会员可能会丢失钥匙，在这种情况下，我们需要确保该钥匙不再能打开俱乐部的门。==

The same ideas can be used in computer systems.
==同样的理念可以应用于计算机系统。==

Early computer scientists decided to call the approach that’s kind of like locks and keys a **capability-based system**, while the approach based on the bouncer and the list of those to admit was called an **access control list system**.
==早期的计算机科学家决定将那种有点像锁和钥匙的方法称为**基于权标（能力）的系统**（capability-based system），而将基于保镖和准入名单的方法称为**访问控制列表系统**（access control list system）。==

Capabilities are thus like keys, or tickets to a movie, or tokens that let you ride a subway.
==因此，权标就像钥匙、电影票或让你乘坐地铁的代币。==

Access control lists are thus like, well, lists.
==访问控制列表就像，嗯，列表。==

How does this work in an operating system?
==这在操作系统中是如何运作的？==

If you’re using capabilities, when a process belonging to user X wants to read and write file `/tmp/foo`, it hands a capability specific to that file to the system.
==如果你使用的是权标，当属于用户 X 的进程想要读取和写入文件 `/tmp/foo` 时，它会向系统提交一个针对该文件的权标。==

(And precisely what, you may ask, is a capability in this context? Good question! We’ll get to that.)
==（你可能会问，在这种情况下权标究竟是什么？好问题！我们稍后会讨论。）==

If you’re using access control lists (**ACLs**, for short), the system looks up user X on an ACL associated with `/tmp/foo`, only allowing the access if the user is on the list.
==如果你使用的是访问控制列表（简称 **ACL**），系统会在与 `/tmp/foo` 关联的 ACL 中查找用户 X，只有当用户在列表中时才允许访问。==

In either case, the check can be made at the moment the access (an `open()` call, in our example) is requested.
==在任何一种情况下，都可以在请求访问（在我们的示例中是 `open()` 调用）的时刻进行检查。==

The check is made after trapping to the operating system, but before the access is actually permitted, with an early exit and error code returned if the access control check fails.
==检查是在陷（trap）入操作系统之后、但在实际允许访问之前进行的，如果访问控制检查失败，则会提前退出并返回错误代码。==

At a high level, these two options may not sound very different, but when you start thinking about the algorithm you’ll need to run and the data structures required to support that algorithm, you’ll quickly see that there are major differences.
==在高级别上，这两个选项听起来可能没有太大区别，但当你开始思考需要运行的算法以及支持该算法所需的数据结构时，你很快就会发现存在重大差异。==

Let’s walk through each in turn.
==让我们依次介绍每一个。==




==### 第一步：数据清洗 & 第二步：句子切分 & 第三步：输出格式==

**ASIDE: THE ANDROID ACCESS CONTROL MODEL**
==**侧记：Android 访问控制模型**==

The Android system is one of the leading software platforms for today’s mobile computing devices, especially smart phones.
==Android 系统是当今移动计算设备（尤其是智能手机）领先的软件平台之一。==

These devices pose different access control challenges than classic server computers, or even personal desktop computers or laptops.
==与传统的服务器计算机，甚至个人台式机或笔记本电脑相比，这些设备提出了不同的访问控制挑战。==

Their functionality is based on the use of many relatively small independent applications, commonly called apps, that are downloaded, installed, and run on a device belonging to only a single user.
==它们的功能基于许多相对较小的独立应用程序（通常称为 app）的使用，这些程序在仅属于单个用户的设备上下载、安装和运行。==

Thus, there is no issue of protecting multiple users on one machine from each other.
==因此，不存在保护一台机器上的多个用户免受彼此侵害的问题。==

If one used a standard access control model, these apps would run under that user’s identity.
==如果使用标准的访问控制模型，这些 app 将在该用户的身份下运行。==

But apps are developed by many entities, and some may be malicious.
==但是 app 是由许多实体开发的，其中一些可能是恶意的。==

Further, most apps have no legitimate need for most of the resources on the device.
==此外，大多数 app 对设备上的大多数资源并没有合法的需求。==

If they are granted too many privileges, a malicious app can access the phone owner’s contacts, make phone calls, or buy things over the network, among many other undesirable behaviors.
==如果它们被授予过多的权限，恶意 app 可能会访问手机所有者的联系人、拨打电话或通过网络购买物品，以及许多其他不良行为。==

The principle of least privilege implies that we should not give apps the full privileges belonging to owner, but they must have some privileges if they are to do anything interesting.
==最小权限原则意味着我们不应该给予 app 属于所有者的全部权限，但如果它们要执行任何有意义的操作，就必须拥有某些权限。==

Android runs on top of a version of Linux, and an application’s access limitations are achieved in part by generating a new user ID for each installed app.
==Android 运行在 Linux 的一个版本之上，应用程序的访问限制部分是通过为每个安装的 app 生成一个新的用户 ID（UID）来实现的。==

The app runs under that ID and its accesses can be controlled on that basis.
==该 app 在该 ID 下运行，其访问权限可以基于此进行控制。==

However, the Android middleware offers additional facilities for controlling access.
==然而，Android 中间件提供了额外的设施来控制访问。==

Application developers define accesses required by their app.
==应用程序开发人员定义其 app 所需的访问权限。==

When a user considers installing an app on their device, they are shown what permissions it requires.
==当用户考虑在他们的设备上安装 app 时，系统会向他们显示该 app 所需的权限。==

The user can either grant the app those permissions, not install the app, or limit its permissions, though the latter choice may also limit app utility.
==用户可以选择授予该 app 这些权限、不安装该 app 或限制其权限，尽管后一种选择也可能限制 app 的实用性。==

Also, the developer specifies ways in which other apps can communicate with the new app.
==此外，开发人员还会指定其他 app 与该新 app 通信的方式。==

The data structure used to encode this access information is called a **permission label**.
==用于编码此访问信息的数据结构称为**权限标签**。==

An app’s permission labels (both what it can access and what it provides to others) are set at app design time, and encoded into a particular Android system at the moment the app is installed on that machine.
==app 的权限标签（包括它可以访问的内容以及它为他人提供的内容）在 app 设计阶段设定，并在 app 安装到该机器的那一刻编码到特定的 Android 系统中。==

Permission labels are thus like capabilities, since possession of them by the app allows the app to do something, while lacking a label prevents the app from doing that thing.
==因此，权限标签类似于权能（capabilities），因为 app 拥有它们就可以执行某些操作，而缺少标签则会阻止 app 执行该操作。==

An app’s set of permission labels is set statically at install time.
==app 的权限标签集在安装时静态设定。==

The user can subsequently change those permissions, although limiting them may damage app functionality.
==用户随后可以更改这些权限，尽管限制它们可能会损害 app 的功能。==

Permission labels are a form of mandatory access control.
==权限标签是强制访问控制（MAC）的一种形式。==

The Android security model is discussed in detail by Enck et al. [E+09].
==Enck 等人 [E+09] 详细讨论了 Android 安全模型。==

The Android security approach is interesting, but not perfect.
==Android 的安全方法很有趣，但并不完美。==

In particular, users are not always aware of the implications of granting an application access to something, and, faced with the choice of granting the access or not being able to effectively use the app, they will often grant it.
==特别是，用户并不总是意识到授予应用程序访问权限的后果，面对“授予访问权限”或“无法有效使用 app”的选择时，他们通常会选择授予。==

This behavior can be problematic, if the app is malicious.
==如果该 app 是恶意的，这种行为可能会带来问题。==

If desired, the owner can alter that initial ACL, but experience shows that users rarely do.
==如果需要，所有者可以更改初始 ACL，但经验表明用户很少这样做。==

This tendency demonstrates the importance of properly chosen defaults.
==这种倾向证明了正确选择默认设置的重要性。==

Here, as in many other places in an operating system, a theoretically changeable or tunable setting will, in practice, be used unaltered by almost everyone almost always.
==在这里，正如操作系统中的许多其他地方一样，理论上可以更改或调整的设置，在实践中几乎总是被几乎所有人原封不动地使用。==

However, while many will never touch access controls on their resources, for an important set of users and systems these controls are of vital importance to achieve their security goals.
==然而，虽然许多人永远不会触动其资源的访问控制，但对于一组重要的用户和系统来说，这些控制对于实现其安全目标至关重要。==

Even if you mostly rely on defaults, many software installation packages use some degree of care in setting access controls on executables and configuration files they create.
==即使你主要依赖默认设置，许多软件安装包在为它们创建的可执行文件和配置文件设置访问控制时也会表现出一定程度的谨慎。==

Generally, you should exercise caution in fiddling around with access controls in your system.
==通常，你在摆弄系统中的访问控制时应保持谨慎。==

If you don’t know what you’re doing, you might expose sensitive information or allow attackers to alter critical system settings.
==如果你不知道自己在做什么，你可能会暴露敏感信息或允许攻击者更改关键的系统设置。==

If you tighten existing access controls, you might suddenly cause a bunch of daemon programs running in the background to stop working.
==如果你收紧现有的访问控制，你可能会突然导致一堆在后台运行的守护进程停止工作。==

One practical issue that many large institutions discovered when trying to use standard access control methods to implement their security policies is that people performing different roles within the organization require different privileges.
==许多大型机构在尝试使用标准访问控制方法实施其安全策略时发现的一个实际问题是，在组织内履行不同角色的人员需要不同的权限。==

For example, in a hospital, all doctors might have a set of privileges not given to all pharmacists, who themselves have privileges not given to the doctors.
==例如，在医院中，所有医生可能拥有一组不给予所有药剂师的权限，而药剂师本身也拥有不给予医生的权限。==

Organizing access control on the basis of such roles and then assigning particular users to the roles they are allowed to perform makes implementation of many security policies easier.
==基于此类角色组织访问控制，然后将特定用户分配给他们被允许履行的角色，可以使许多安全策略的实施变得更加容易。==

This approach is particularly valuable if certain users are permitted to switch roles depending on the task they are currently performing, since then one need not worry about setting or changing the individual’s access permissions on the fly, but simply switch their role from one to another.
==如果允许某些用户根据当前执行的任务切换角色，这种方法就特别有价值，因为这样就不必担心随时设置或更改个人的访问权限，而只需将他们的角色从一个切换到另一个即可。==

Usually they will hold the role’s permission only as long as they maintain that role.
==通常，他们只有在维持该角色期间才持有该角色的权限。==

Once they exit the particular role (perhaps to enter a different role with different privileges), they lose the privileges of the role they exit.
==一旦他们退出特定角色（也许是为了进入具有不同权限的其他角色），他们就会失去所退出角色的权限。==

This observation led to the development of **Role-Based Access Control**, or **RBAC**.
==这一观察结果导致了**基于角色的访问控制**（即 **RBAC**）的发展。==

The core ideas had been around for some time before they were more formally laid out in a research paper by Ferraiolo and Kuhn [FK92].
==核心理念已经存在了一段时间，直到 Ferraiolo 和 Kuhn [FK92] 的一篇研究论文更正式地阐述了它们。==

Now RBAC is in common use in many organizations, particularly large ones.
==现在 RBAC 在许多组织中得到了普遍应用，特别是大型组织。==

Large organizations face more serious management challenges than small ones, so approaches like RBAC that allow groups of users to be dealt with in one operation can significantly ease the management task.
==大型组织面临比小型组织更严重的管理挑战，因此像 RBAC 这样允许通过一次操作处理用户组的方法可以显著减轻管理任务。==

For example, if a company determines that all programmers should be granted access to a new library that has been developed, but accountants should not, RBAC would achieve this effect with a single operation that assigns the necessary privilege to the Programmer role.
==例如，如果一家公司决定所有程序员都应被授予访问新开发库的权限，而会计师则不应获得，RBAC 就可以通过将必要权限分配给“程序员”角色的单次操作来实现这一效果。==

If a programmer is promoted to a management position for which access to the library is unnecessary, the company can merely remove the Programmer role from the set of roles the manager could take on.
==如果一名程序员被提升到不需要访问该库的管理职位，公司只需从该经理可以担任的角色集中移除“程序员”角色即可。==

Such restrictions do not necessarily imply that you suspect your accountants of being dishonest and prone to selling your secret library code to competitors.
==此类限制并不一定意味着你怀疑你的会计师不诚实并倾向于将你的秘密库代码出售给竞争对手。==

Remember the principle of least privilege: when you give someone access to something, you are relying not just on their honesty, but on their caution.
==记住最小权限原则：当你给予某人访问某物的权限时，你不仅依赖于他们的诚实，还依赖于他们的谨慎。==

If accountants can’t access the library at all, then neither malice nor carelessness on their part can lead to an accountant’s privileges leaking your library code.
==如果会计师根本无法访问该库，那么他们的恶意或疏忽都不会导致会计师的权限泄露你的库代码。==

Least privilege is not just a theoretically good idea, but a vital part of building secure systems in the real world.
==最小权限不仅是一个理论上的好主意，而且是构建现实世界安全系统的重要组成部分。==

**56.1 Introduction**
==**56.1 引言**==

In previous chapters, we’ve discussed clarifying your security goals, determining your security policies, using authentication mechanisms to identify principals, and using access control mechanisms to enforce policies concerning which principals can access which computer resources in which ways.
==在之前的章节中，我们讨论了明确安全目标、确定安全策略、使用身份验证机制识别主体，以及使用访问控制机制执行有关哪些主体可以以何种方式访问哪些计算机资源的策略。==

While we identified a number of shortcomings and problems inherent in all of these elements of securing your system, if we regard those topics as covered, what’s left for the operating system to worry about, from a security perspective?
==虽然我们发现了保护系统安全的这些要素中固有的许多缺点和问题，但如果我们认为这些主题已经讲完了，从安全的角度来看，操作系统还有什么需要担心的呢？==

Why isn’t that everything?
==为什么那不是全部？==

There are a number of reasons why we need more.
==我们需要更多手段的原因有很多。==

Of particular importance: not everything is controlled by the operating system.
==特别重要的一点是：并非所有内容都受操作系统控制。==

But perhaps you respond, you told me the operating system is all-powerful!
==但也许你会回应说，你告诉过我操作系统是无所不能的！==

Not really.
==并不完全是这样。==

It has substantial control over a limited domain – the hardware on which it runs, using the interfaces of which it is given control.
==它对有限的领域拥有实质性的控制权——即它所运行的硬件，使用的是它被赋予控制权的接口。==

It has no real control over what happens on other machines, nor what happens if one of its pieces of hardware is accessed via some mechanism outside the operating system’s control.
==它无法真正控制其他机器上发生的事情，也无法控制如果其硬件组件之一通过操作系统控制之外的某种机制被访问时会发生什么。==

But how can we expect the operating system to protect something when the system does not itself control access to that resource?
==但是，当系统本身不控制对该资源的访问时，我们如何期望操作系统保护某些东西呢？==

The answer is to prepare the resource for trouble in advance.
==答案是提前为资源可能遇到的麻烦做好准备。==

In essence, we assume that we are going to lose the data, or that an opponent will try to alter it improperly.
==从本质上讲，我们假设我们会丢失数据，或者对手会尝试不当地更改数据。==

And we take steps to ensure that such actions don’t cause us problems.
==我们采取措施确保此类操作不会给我们带来问题。==

The key observation is that if an opponent cannot understand the data in the form it is obtained, our secrets are safe.
==关键的观察结果是，如果对手无法理解所获数据形式的含义，我们的秘密就是安全的。==

Further, if the attacker cannot understand it, it probably can’t be altered, at least not in a controllable way.
==此外，如果攻击者无法理解它，它可能就无法被更改，至少不能以可控的方式更改。==

If the attacker doesn’t know what the data means, how can it be changed into something the attacker prefers?
==如果攻击者不知道数据的含义，又怎么能将其更改为攻击者喜欢的样子呢？==

The core technology we’ll use is **cryptography**, a set of techniques to convert data from one form to another, in controlled ways with expected outcomes.
==我们将使用的核心技术是**密码学**，这是一组以可控方式将数据从一种形式转换为另一种形式并产生预期结果的技术。==

We will convert the data from its ordinary form into another form using cryptography.
==我们将使用密码学将数据从普通形式转换为另一种形式。==

If we do it right, the opponent will not be able to determine what the original data was by examining the protected form.
==如果我们做得正确，对手将无法通过检查受保护的形式来确定原始数据是什么。==

**56.2 Cryptography**
==**56.2 密码学**==

The basic idea behind cryptography is to take a piece of data and use an algorithm (often called a **cipher**), usually augmented with a second piece of information (which is called a **key**), to convert the data into a different form.
==密码学背后的基本思想是获取一段数据，并使用一种算法（通常称为**加密算法**或**置换**），通常辅以第二段信息（称为**密钥**），将数据转换为不同的形式。==

The new form should look nothing like the old one, but, typically, we want to be able to run another algorithm, again augmented with a second piece of information, to convert the data back to its original form.
==新形式看起来应该与旧形式完全不同，但通常我们希望能够运行另一种算法，同样辅以第二段信息，将数据转换回其原始形式。==

Let’s formalize that just a little bit.
==让我们将其稍加形式化。==

We start with data $P$ (which we usually call the **plaintext**), a key $K$, and an encryption algorithm $E()$.
==我们从数据 $P$（我们通常称之为**明文**）、密钥 $K$ 和加密算法 $E()$ 开始。==

We end up with $C$, the altered form of $P$, which we usually call the **ciphertext**:
==我们最终得到 $C$，即 $P$ 的改变形式，我们通常称之为**密文**：==

$C = E(P, K)$ (56.1)
$C = E(P, K)$ (56.1)

The reverse transformation takes $C$, which we just produced, a decryption algorithm $D()$, and the key $K$:
==反向转换采用我们刚刚生成的 $C$、解密算法 $D()$ 和密钥 $K$：==

$P = D(C, K)$ (56.2)
$P = D(C, K)$ (56.2)

It sounds like we’ve thrown away half our protection, since now the cryptography’s benefit relies entirely on the secrecy of the key.
==听起来我们好像丢掉了一半的保护，因为现在密码学的益处完全取决于密钥的保密性。==

Precisely.
==确实如此。==

Let’s say that again in all caps, since it’s so important that you really need to remember it: **THE CRYPTOGRAPHY’S BENEFIT RELIES ENTIRELY ON THE SECRECY OF THE KEY.**
==让我们用全大写再重复一遍，因为它是如此重要，你真的需要记住它：**密码学的益处完全取决于密钥的保密性。**==

**56.4 Cryptographic Hashes**
==**56.4 密码哈希**==

So to be particularly careful, we can use a **cryptographic hash** to ensure integrity.
==因此，为了特别小心，我们可以使用**密码哈希**来确保完整性。==

Cryptographic hashes are a special category of hash functions with several important properties:
==密码哈希是一类特殊的哈希函数，具有几个重要的属性：==

* It is computationally infeasible to find two inputs that will produce the same hash value.
==* 在计算上无法找到两个能产生相同哈希值的输入。==

* Any change to an input will result in an unpredictable change to the resulting hash value.
==* 对输入的任何更改都将导致生成的哈希值发生不可预测的更改。==

* It is computationally infeasible to infer any properties of the input based only on the hash value.
==* 仅根据哈希值在计算上无法推断出输入的任何属性。==

To formalize it a bit, to perform a cryptographic hash we take a plaintext $P$ and a hashing algorithm $H()$.
==为了将其形式化，执行密码哈希时，我们采用明文 $P$ 和哈希算法 $H()$。==

$S = H(P)$ (56.5)
$S = H(P)$ (56.5)

**56.7 At-Rest Data Encryption**
==**56.7 静态数据加密**==

One common general use of at-rest data encryption is called **full disk encryption**.
==静态数据加密的一个常见通用用途称为**全盘加密**。==

This usually means that the entire contents (or almost the entire contents) of the storage device are encrypted.
==这通常意味着存储设备的全部内容（或几乎全部内容）都被加密。==

Windows BitLocker and Apple’s FileVault are examples of software-based full disk encryption.
==Windows BitLocker 和 Apple 的 FileVault 是基于软件的全盘加密示例。==




The data remains decrypted as long as it is stored anywhere in the machine’s memory, including in shared buffers or user address space.
==只要数据存储在机器内存中的任何地方，包括共享缓冲区或用户地址空间中，它就会保持解密状态。==

When new data is to be sent to the device, it is first encrypted.
==当新数据要发送到设备时，会先对其进行加密。==

The data is never placed on the storage device in decrypted form.
==数据绝不会以解密形式放置在存储设备上。==

After the initial request to obtain the decryption key is performed, encryption and decryption are totally transparent to users and applications.
==在执行获取解密密钥的初始请求后，加密和解密对用户和应用程序来说是完全透明的。==

They never see the data in encrypted form and are not asked for the key again, until the machine reboots.
==直到机器重启之前，他们绝不会看到加密形式的数据，也不会被再次要求提供密钥。==

Cryptography is a computationally expensive operation, particularly if performed in software.
==密码学是一项计算开销巨大的操作，特别是在通过软件执行时。==

There will be overhead associated with performing software-based **full disk encryption**.
==执行基于软件的**全盘加密**会产生相关的开销。==

Reports of the amount of overhead vary, but a few percent extra latency for disk-heavy operations is common.
==关于开销大小的报告各不相同，但对于磁盘密集型操作，增加几个百分点的延迟是很常见的。==

For operations making less use of the disk, the overhead may be imperceptible.
==对于较少使用磁盘的操作，开销可能是察觉不到的。==

For hardware-based full disk encryption, the rated speed of the disk drive will be achieved, which may or may not be slower than a similar model not using full disk encryption.
==对于基于硬件的全盘加密，可以达到磁盘驱动器的额定速度，这可能比不使用全盘加密的类似型号慢，也可能不慢。==

**What does this form of encryption protect against?**
==**这种形式的加密能防范什么？**==

* It offers no extra protection against users trying to access data they should not be allowed to see.
==* 它对于试图访问其无权查看的数据的用户不提供额外保护。==

Either the standard access control mechanisms that the operating system provides work (and such users can’t get to the data because they lack access permissions) or they don’t (in which case such users will be given equal use of the decryption key as anyone else).
==要么操作系统提供的标准访问控制机制有效（此类用户因缺乏访问权限而无法获取数据），要么失效（在这种情况下，此类用户将获得与其他人同等的解密密钥使用权）。==

* It does not protect against flaws in applications that divulge data.
==* 它不能防范泄露数据的应用程序漏洞。==

Such flaws will permit attackers to pose as the user, so if the user can access the unencrypted data, so can the attacker.
==此类漏洞将允许攻击者冒充用户，因此如果用户可以访问未加密的数据，攻击者也可以。==

For example, it offers little protection against buffer overflows or SQL injections.
==例如，它对于缓冲区溢出或 SQL 注入几乎没有保护作用。==

* It does not protect against dishonest privileged users on the system, such as a system administrator.
==* 它不能防范系统中的不诚实特权用户，例如系统管理员。==

Administrator’s privileges may allow the admin to pose as the user who owns the data or to install system components that provide access to the user’s data; thus, the admin could access decrypted copies of the data on request.
==管理员的权限可能允许其冒充拥有数据的用户，或安装能够访问用户数据的系统组件；因此，管理员可以根据需要访问数据的解密副本。==

* It does not protect against security flaws in the OS itself.
==* 它不能防范操作系统本身的安全性漏洞。==

Once the key is provided, it is available (directly in memory, or indirectly by asking the hardware to use it) to the operating system, whether that OS is trustworthy and secure or compromised and insecure.
==一旦提供了密钥，操作系统就可以获取它（直接在内存中，或间接通过要求硬件使用它），无论该操作系统是可信安全的，还是已被攻破且不安全的。==

So what benefit does this form of encryption provide?
==那么这种形式的加密能提供什么好处呢？==

Consider this situation.
==考虑这种情况。==

If a hardware device storing data is physically moved from one machine to another, the OS on the other machine is not obligated to honor the access control information stored on the device.
==如果存储数据的硬件设备被物理地从一台机器移动到另一台机器，另一台机器上的操作系统没有义务遵守存储在设备上的访问控制信息。==

In fact, it need not even use the same file system to access that device.
==事实上，它甚至不需要使用相同的文件系统来访问该设备。==

For example, it can treat the device as merely a source of raw data blocks, rather than an organized file system.
==例如，它可以将该设备仅仅视为原始数据块的来源，而不是一个有组织的文件系统。==

So any access control information associated with files on the device might be ignored by the new operating system.
==因此，与设备上的文件相关的任何访问控制信息都可能被新的操作系统忽略。==

However, if the data on the device is encrypted via full disk encryption, the new machine will usually be unable to obtain the encryption key.
==然而，如果设备上的数据通过全盘加密进行了加密，新机器通常将无法获得加密密钥。==

It can access the raw blocks, but they are encrypted and cannot be decrypted without the key.
==它可以访问原始数据块，但它们是加密的，没有密钥就无法解密。==

This benefit would be useful if the hardware in question was stolen and moved to another machine, for example.
==例如，如果相关硬件被盗并转移到另一台机器，这种优势就会非常有用。==

This situation is a very real possibility for mobile devices, which are frequently lost or stolen.
==对于经常丢失或被盗的移动设备来说，这种情况极有可能发生。==

Disk drives are sometimes resold, and data belonging to the former owner (including quite sensitive data) has been found on them by the re-purchaser.
==磁盘驱动器有时会被转售，而重新购买者曾在其上发现属于前任所有者的数据（包括非常敏感的数据）。==

These are important cases where full disk encryption provides real benefits.
==在这些重要案例中，全盘加密提供了实实在在的好处。==

For other forms of encryption of data at rest, the system must still address the issues of how much is encrypted, how to obtain the key, and when to encrypt and decrypt the data, with different types of protection resulting depending on how these questions are addressed.
==对于其他形式的静态数据加密，系统仍必须解决加密多少内容、如何获取密钥以及何时加密和解密数据的问题，根据这些问题的处理方式，会产生不同类型的保护效果。==

Generally, such situations require that some software ensures that the unencrypted form of the data is no longer stored anywhere, including caches, and that the cryptographic key is not available to those who might try to illicitly access the data.
==通常，此类情况要求某些软件确保数据的未加密形式不再存储在任何地方（包括缓存中），并且加密密钥对于那些可能试图非法访问数据的人不可用。==

There are relatively few circumstances where such protection is of value, but there are a few common examples:
==此类保护具有价值的情况相对较少，但有几个常见的例子：==

* **Archiving data** that might need to be copied and must be preserved, but need not be used.
==* **归档数据**：这些数据可能需要复制且必须保存，但不需要使用。==

In this case, the data can be encrypted at the time of its creation, and perhaps never decrypted, or only decrypted under special circumstances under the control of the data’s owner.
==在这种情况下，数据可以在创建时进行加密，并且可能永远不解密，或者仅在数据所有者控制下的特殊情况下解密。==

If the machine was uncompromised when the data was first encrypted and the key is not permanently stored on the system, the encrypted data is fairly safe.
==如果在数据首次加密时机器未被攻破，且密钥没有永久存储在系统中，那么加密数据是相当安全的。==

Note, however, that if the key is lost, you will never be able to decrypt the archived data.
==但请注意，如果密钥丢失，你将永远无法解密归档数据。==

* **Storing sensitive data in a cloud computing facility**, a variant of the previous example.
==* **在云计算设施中存储敏感数据**：这是前一个例子的变体。==

If one does not completely trust the cloud computing provider (or one is uncertain of how careful that provider is – remember, when you trust another computing element, you’re trusting not only its honesty, but also its carefulness and correctness), encrypting the data before sending it to the cloud facility is wise.
==如果不完全信任云计算提供商（或者不确定该提供商有多细心——请记住，当你信任另一个计算元素时，你不仅是在信任它的诚实，还在信任它的细心和正确性），那么在将数据发送到云设施之前对其进行加密是明智的。==

Many cloud backup products include this capability.
==许多云备份产品都包含此功能。==

In this case, the cryptography and key use occur before moving the data to the untrusted system, or after it is recovered from that system.
==在这种情况下，密码操作和密钥使用发生在将数据移动到不可信系统之前，或者从该系统恢复数据之后。==

* **User-level encryption performed through an application.**
==* **通过应用程序执行的用户级加密。**==

For example, a user might choose to encrypt an email message, with any stored version of it being in encrypted form.
==例如，用户可能会选择加密一封电子邮件，其任何存储版本都将以加密形式存在。==

In this case, the cryptography will be performed by the application, and the user will do something to make a cryptographic key available to the application.
==在这种情况下，密码操作将由应用程序执行，用户将执行某些操作使加密密钥对应用程序可用。==

Ideally, that application will ensure that the unencrypted form of the data and the key used to encrypt it are no longer readily available after encryption is completed.
==理想情况下，该应用程序将确保在加密完成后，数据的未加密形式和用于加密它的密钥不再易于获取。==

Remember, however, that while the key exists, the operating system can obtain access to it without your application knowing.
==但请记住，只要密钥存在，操作系统就可以在你的应用程序不知情的情况下获取它的访问权限。==

One important special case for encrypting selected data at rest is a **password vault** (also known as a **key ring**), which we discussed in the authentication chapter.
==针对特定静态数据进行加密的一个重要特例是**密码保险箱**（也称为**钥匙环**），我们在身份验证章节中讨论过它。==

Typical users interact with many remote sites that require them to provide passwords (authentication based on “what you know”, remember?).
==典型用户会与许多远程站点交互，这些站点要求他们提供密码（还记得基于“你所知道的信息”的身份验证吗？）。==

The best security is achieved if one uses a different password for each site, but doing so places a burden on the human user, who generally has a hard time remembering many passwords.
==如果为每个站点使用不同的密码，可以实现最佳的安全性，但这样做会给人类用户带来负担，他们通常很难记住许多密码。==

A solution is to encrypt all the different passwords and store them on the machine, indexed by the site they are used for.
==一种解决方案是加密所有不同的密码并将它们存储在机器上，并按所使用的站点进行索引。==

When one of the passwords is required, it is decrypted and provided to the site that requires it.
==当需要其中一个密码时，会将其解密并提供给需要的站点。==

For password vaults and all such special cases, the system must have some way of obtaining the required key whenever data needs to be encrypted or decrypted.
==对于密码保险箱和所有此类特例，系统必须有某种方法在需要加密或解密数据时获取所需的密钥。==

If an attacker can obtain the key, the cryptography becomes useless, so safe storage of the key becomes critical.
==如果攻击者能够获得密钥，密码学就会变得毫无用处，因此密钥的安全存储变得至关重要。==

Typically, if the key is stored in unencrypted form anywhere on the computer in question, the encrypted data is at risk, so well designed encryption systems tend not to do so.
==通常，如果密钥以未加密的形式存储在相关计算机的任何位置，加密数据就会面临风险，因此设计良好的加密系统往往不会这样做。==

For example, in the case of password vaults, the key used to decrypt the passwords is not stored in the machine’s stable storage.
==例如，在密码保险箱的情况下，用于解密密码的密钥不会存储在机器的稳定存储器中。==

It is obtained by asking the user for it when required, or asking for a passphrase used to derive the key.
==它是通过在需要时向用户询问，或询问用于派生密钥的密码短语来获取的。==

The key is then used to decrypt the needed password.
==然后使用该密钥来解密所需的密码。==

Maximum security would suggest destroying the key as soon as this decryption was performed (remember the principle of **least privilege**?), but doing so would imply that the user would have to re-enter the key each time a password was needed (remember the principle of **acceptability**?).
==最大程度的安全性建议在执行解密后立即销毁密钥（还记得**最小特权**原则吗？），但这样做意味着每当需要密码时，用户都必须重新输入密钥（还记得**可接受性**原则吗？）。==

A compromise between usability and security is reached, in most cases, by remembering the key after first entry for a significant period of time, but only keeping it in RAM.
==在大多数情况下，通过在首次输入后将其记住一段相当长的时间，但仅保存在 RAM 中，可以在可用性和安全性之间达成折中。==

When the user logs out, or the system shuts down, or the application that handles the password vault (such as a web browser) exits, the key is “forgotten.”
==当用户注销、系统关闭或处理密码保险箱的应用程序（如网络浏览器）退出时，密钥就会被“遗忘”。==

This approach is reminiscent of single sign-on systems, where a user is asked for a password when the system is first accessed, but is not required to re-authenticate again until logging out.
==这种方法让人联想到单点登录系统，用户在首次访问系统时会被要求输入密码，但在注销之前不需要再次重新认证。==

It has the same disadvantages as those systems, such as permitting an unattended terminal to be used by unauthorized parties to use someone else’s access permissions.
==它具有与这些系统相同的缺点，例如允许无人看管的终端被未经授权的方利用，从而使用他人的访问权限。==

Both have the tremendous advantage that they don’t annoy their users so much that they are abandoned in favor of systems offering no security whatsoever.
==两者的巨大优势在于，它们不会让用户感到如此厌烦，以至于被弃用而转向完全不提供安全性的系统。==

### 56.8 Cryptographic Capabilities
==### 56.8 密码学能力（Capabilities）==

Remember from our chapter on access control that **capabilities** had the problem that we could not leave them in users’ hands, since then users could forge them and grant themselves access to anything they wanted.
==记得我们在访问控制章节中提到过，**能力（capabilities）**存在一个问题，即我们不能将它们留在用户手中，因为那时用户可以伪造它们并授予自己访问任何内容的权限。==

Cryptography can be used to create unforgeable capabilities.
==密码学可以用来创建不可伪造的能力。==

A trusted entity could use cryptography to create a sufficiently long and securely encrypted data structure that indicated that the possessor was allowed to have access to a particular resource.
==受信任的实体可以使用密码学创建一个足够长且安全加密的数据结构，该结构表明持有者被允许访问特定资源。==

This data structure could then be given to a user, who would present it to the owner of the matching resource to obtain access.
==然后可以将此数据结构交给用户，用户将其呈现给匹配资源的所有者以获得访问权限。==

The system that actually controlled the resource must be able to check the validity of the data structure before granting access, but would not need to maintain an access control list.
==实际控制资源的系统必须能够在授予访问权限之前检查数据结构的有效性，但不需要维护访问控制列表。==

Such cryptographic capabilities could be created either with symmetric or public key cryptography.
==此类密码学能力既可以使用对称加密创建，也可以使用公钥加密创建。==

With symmetric cryptography, both the creator of the capability and the system checking it would need to share the same key.
==使用对称加密时，能力的创建者和检查能力的系统都需要共享同一个密钥。==

This option is most feasible when both of those entities are the same system, since otherwise it requires moving keys around between the machines that need to use the keys, possibly at high speed and scale, depending on the use scenario.
==当这两个实体是同一个系统时，此选项最为可行，否则需要在需要使用密钥的机器之间移动密钥，根据使用场景的不同，可能需要高速且大规模地进行。==

One might wonder why the single machine would bother creating a cryptographic capability to allow access, rather than simply remembering that the user had passed an access check, but there are several possible reasons.
==人们可能会想，为什么单台机器要费力创建密码学能力来允许访问，而不是简单地记住用户已经通过了访问检查，但这有几个可能的原因。==

For example, if the machine controlling the resource worked with vast numbers of users, keeping track of the access status for each of them would be costly and complex, particularly in a distributed environment where the system needed to worry about failures and delays.
==例如，如果控制资源的机器处理大量用户，跟踪每个用户的访问状态将是昂贵且复杂的，特别是在系统需要担心故障和延迟的分布式环境中。==

Or if the system wished to give transferable rights to the access, as it might if the principal might move from machine to machine, it would be more feasible to allow the capability to move with the principal and be used from any location.
==或者，如果系统希望赋予可转移的访问权（例如当主体可能在机器之间移动时），那么允许能力随主体移动并在任何位置使用将更加可行。==

Symmetric cryptographic capabilities also make sense when all of the machines creating and checking them are inherently trusted and key distribution is not problematic.
==当所有创建和检查对称密码学能力的机器都是固有的受信任机器，且密钥分发不成问题时，这种能力也是有意义的。==

If public key cryptography is used to create the capabilities, then the creator and the resource controller need not be co-located and the trust relationships need not be as strong.
==如果使用公钥加密来创建这些能力，那么创建者和资源控制器不需要位于同一地点，信任关系也不需要那么强。==

The creator of the capability needs one key (typically the secret key) and the controller of the resource needs the other.
==能力的创建者需要一个密钥（通常是私钥），资源的控制器需要另一个密钥。==

If the content of the capability is not itself secret, then a true public key can be used, with no concern over who knows it.
==如果能力的内容本身不是秘密，那么可以使用真正的公钥，而无需担心谁知道它。==

If secrecy (or at least some degree of obscurity) is required, what would otherwise be a public key can be distributed only to the limited set of entities that would need to check the capabilities.
==如果需要保密（或至少是一定程度的模糊性），那么本应公开的密钥可以仅分发给需要检查这些能力的有限实体集。==

A resource manager could create a set of credentials (indicating which principal was allowed to use what resources, in what ways, for what period of time) and then encrypt them with a private key.
==资源管理器可以创建一组凭据（表明哪个主体被允许以何种方式、在什么时间段内使用什么资源），然后用私钥对其进行加密。==

Any one else can validate those credentials by decrypting them with the manager’s public key.
==任何其他人都可以通过使用管理器的公钥对其进行解密来验证这些凭据。==

As long as only the resource manager knows the private key, no one can forge capabilities.
==只要只有资源管理器知道私钥，就没有人能伪造能力。==

As suggested above, such cryptographic capabilities can hold a good deal of information, including expiration times, identity of the party who was given the capability, and much else.
==如上所述，此类密码学能力可以包含大量信息，包括到期时间、获得能力的方的身份等等。==

Since strong cryptography will ensure integrity of all such information, the capability can be relied upon.
==由于强大的密码学将确保所有此类信息的完整性，因此该能力是可以被信赖的。==

This feature allows the creator of the capability to prevent arbitrary copying and sharing of the capability, at least to a certain extent.
==此特性允许能力的创建者在一定程度上防止能力的随意复制和共享。==

For example, a cryptographic capability used in a network context can be tied to a particular IP address, and would only be regarded as valid if the message carrying it came from that address.
==例如，在网络环境中使用的密码学能力可以与特定的 IP 地址绑定，并且只有在携带它的消息来自该地址时才被视为有效。==

Many different encryption schemes can be used.
==可以使用许多不同的加密方案。==

The important point is that the encrypted capabilities must be long enough that it is computationally infeasible to find a valid capability by brute force enumeration or random guessing (e.g., the number of invalid bit patterns is $10^{15}$ times larger than the number of valid bit patterns).
==重要的一点是，加密的能力必须足够长，以至于通过穷举枚举或随机猜测来找到一个有效的能力在计算上是不可行的（例如，无效位模式的数量比有效位模式的数量大 $10^{15}$ 倍）。==

### 56.9 Summary
==### 56.9 总结==

Cryptography can offer certain forms of protection for data even when that data is no longer in a system’s custody.
==即使数据不再处于系统的监管之下，密码学也可以为数据提供某些形式的保护。==

These forms of protection include secrecy, integrity, and authentication.
==这些保护形式包括机密性、完整性和身份验证。==

Cryptography achieves such protection by converting the data’s original bit pattern into a different bit pattern, using an algorithm called a **cipher**.
==密码学通过使用一种称为**密码（cipher）**的算法，将数据的原始位模式转换为不同的位模式来实现此类保护。==

In most cases, the transformation can be reversed to obtain the original bit pattern.
==在大多数情况下，这种转换是可以逆转的，以获得原始位模式。==

**Symmetric ciphers** use a single secret key shared by all parties with rights to access the data.
==**对称密码**使用由所有有权访问数据的方共享的单个密钥。==

**Asymmetric ciphers** use one key to encrypt the data and a second key to decrypt the data, with one of the keys kept secret and the other commonly made public.
==**非对称密码**使用一个密钥加密数据，使用第二个密钥解密数据，其中一个密钥保密，另一个通常公开。==

**Cryptographic hashes**, on the other hand, do not allow reversal of the cryptography and do not require the use of keys.
==另一方面，**密码学哈希**不允许逆转加密过程，也不需要使用密钥。==

Strong ciphers make it computationally infeasible to obtain the original bit pattern without access to the required key.
==强大的密码使得在没有获取所需密钥的情况下，通过计算获取原始位模式是不可行的。==

For symmetric and asymmetric ciphers, this implies that only holders of the proper key can obtain the cipher’s benefits.
==对于对称和非对称密码，这意味着只有持有正确密钥的人才能获得密码带来的好处。==

Since cryptographic hashes have no key, this implies that no one should be able to obtain the original bit pattern from the hash.
==由于密码学哈希没有密钥，这意味着任何人都无法从哈希值中获取原始位模式。==

For operating systems, the obvious situations in which cryptography can be helpful are when data is sent to another machine, or when hardware used to store the data might be accessed without the intervention of the operating system.
==对于操作系统，密码学显然在以下情况中很有帮助：当数据被发送到另一台机器时，或者当用于存储数据的硬件可能在没有操作系统干预的情况下被访问时。==

In the latter case, data can be encrypted on the device (using either hardware or software), and decrypted as it is delivered to the operating system.
==在后一种情况下，数据可以在设备上加密（使用硬件或软件），并在交付给操作系统时解密。==

Ciphers are generally not secret, but rather are widely known and studied standards.
==密码通常不是秘密，而是广为人知且经过研究的标准。==

A cipher’s ability to protect data thus relies entirely on **key secrecy**.
==因此，密码保护数据的能力完全取决于**密钥的秘密性**。==

If attackers can learn, deduce, or guess the key, all protection is lost.
==如果攻击者能够获悉、推导或猜测出密钥，所有的保护都会丧失。==

Thus, extreme care in key selection and maintaining key secrecy is required if one relies on cryptography for protection.
==因此，如果依靠密码学进行保护，则需要极其谨慎地选择密钥并保持密钥的秘密性。==

A good principle is to store keys in as few places as possible, for as short a duration as possible, available to as few parties as possible.
==一个好的原则是将密钥存储在尽可能少的地方，持续时间尽可能短，并仅对尽可能少的方可用。==

### Chapter 57: Distributed System Security
==### 第 57 章：分布式系统安全==

### 57.1 Introduction
==### 57.1 简介==

An operating system can only control its own machine’s resources.
==一个操作系统只能控制它自己机器的资源。==

Thus, operating systems will have challenges in providing security in distributed systems, where more than one machine must cooperate.
==因此，在必须有多台机器协作的分布式系统中，操作系统在提供安全性方面将面临挑战。==

There are two large problems:
==存在两个大问题：==

* The other machines in the distributed system might not properly implement the security policies you want, or they might be adversaries impersonating trusted partners.
==* 分布式系统中的其他机器可能没有正确执行你想要的策略，或者它们可能是冒充受信任伙伴的敌手。==

We cannot control remote systems, but we still have to be able to trust validity of the credentials and capabilities they give us.
==我们无法控制远程系统，但我们仍必须能够信任它们提供给我们的凭据和能力的有效性。==

* Machines in a distributed system communicate across a network that none of them fully control and that, generally, cannot be trusted.
==* 分布式系统中的机器通过一个没有任何机器能完全控制且通常不可信的网络进行通信。==

Adversaries often have equal access to that network and can forge, copy, replay, alter, destroy, and delay our messages, and generally interfere with our attempts to use the network.
==敌手通常具有同等的网络访问权限，可以伪造、复制、重放、更改、销毁和延迟我们的消息，并通常会干扰我们使用网络的尝试。==

As suggested earlier, cryptography will be the major tool we use here, but we also said cryptography was hard to get right.
==如前所述，密码学将是我们在这里使用的主要工具，但我们也说过密码学很难做得正确。==

That makes it sound like the perfect place to use carefully designed standard tools, rather than to expect everyone to build their own.
==这听起来像是一个使用精心设计的标准工具的完美场所，而不是期望每个人都构建自己的工具。==

That’s precisely correct.
==这完全正确。==

**THE CRUX: HOW TO PROTECT DISTRIBUTED SYSTEM OPERATIONS**
==**核心问题：如何保护分布式系统操作**==

How can we secure a system spanning more than one machine?
==我们如何保护跨越多个机器的系统安全？==

What tools are available to help us protect such systems?
==有哪些工具可以帮助我们保护此类系统？==

How do we use them properly?
==我们如何正确使用它们？==

What are the areas in using the tools that require us to be careful and thoughtful?
==在使用这些工具时，哪些领域需要我们谨慎周到地考虑？==

### 57.2 The Role of Authentication
==### 57.2 身份验证的作用==

How can we handle our uncertainty about whether our partners in a distributed system are going to enforce our security policies?
==我们如何处理关于分布式系统中的伙伴是否会执行我们的安全策略的不确定性？==

In most cases, we can’t do much.
==在大多数情况下，我们无能为力。==

At best, we can try to arrange to agree on policies and hope everyone follows through on those agreements.
==充其量，我们可以尝试商定策略，并希望每个人都能履行这些协议。==

There are some special cases where we can get high-quality evidence that our partners have behaved properly, but that’s not easy, in general.
==在某些特殊情况下，我们可以获得伙伴行为得当的高质量证据，但总的来说这并不容易。==

For example, how can we know that they are using full disk encryption, or that they have carefully wiped an encryption key we are finished using, or that they have set access controls on the local copies of their files properly?
==例如，我们如何知道他们是否正在使用全盘加密，或者他们是否小心地擦除了我们使用完毕的加密密钥，或者他们是否正确地设置了其文件本地副本的访问控制？==

They can say they did, but how can we know?
==他们可以声称自己做了，但我们如何确定呢？==

Generally, we can’t.
==通常情况下，我们无法确定。==

But you’re used to that.
==但你已经习惯了。==

In the real world, your friends and relatives know some secrets about you, and they might have keys to get into your home, and if you loan them your car you’re fairly sure you’ll get it back.
==在现实世界中，你的朋友和亲戚知道你的一些秘密，他们可能有进入你家的钥匙，如果你把车借给他们，你相当确定能拿回来。==

That’s not so much because you have perfect mechanisms to prevent those trusted parties from behaving badly, but because you are pretty sure they won’t.
==这与其说是你有完美的机制来防止这些受信任的方行为不端，不如说是你非常确定他们不会。==

If you’re wrong, perhaps you can detect that they haven’t behaved well and take compensating actions (like changing your locks or calling the police to report your car stolen).
==如果你错了，也许你可以发现他们表现不好并采取补偿措施（比如换锁或报警报案车辆被盗）。==

We’ll need to rely on similar approaches in distributed computer systems.
==在分布式计算机系统中，我们需要依赖类似的方法。==

We will simply have to trust that some parties will behave well.
==我们只能相信某些方会表现良好。==

In some cases, we can detect when they don’t and adjust our trust in the parties accordingly, and maybe take other compensating actions.
==在某些情况下，我们可以检测到他们何时没有表现良好，并相应地调整我们对这些方的信任，或许还会采取其他补偿措施。==

Of course, in the cyber world, our actions are at a distance over a network, and all we see are bits going out and coming in on the network.
==当然，在网络世界中，我们的行为是通过网络远距离进行的，我们看到的只是网络上流出和流入的比特。==

For a trust-based solution to work, we have to be quite sure that the bits we send out can be verified by our buddies as truly coming from us, and we have to be sure that the bits coming in really were created by them.
==为了使基于信任的解决方案奏效，我们必须非常确定我们发送出去的比特可以被伙伴验证为真实来自我们，并且我们必须确定进入的比特确实是由他们创建的。==

That’s a job for **authentication**.
==这就是**身份验证（authentication）**的工作。==

As suggested in the earlier authentication chapter, when working over a network, we need to authenticate based on a bundle of bits.
==正如之前的身份验证章节所建议的，在通过网络工作时，我们需要基于一串比特来进行身份验证。==

Most commonly, we use a form of authentication based on **what you know**.
==最常见的是，我们使用一种基于“你所知道的信息”的身份验证形式。==

Now, think back to the earlier chapters.
==现在，回想一下之前的章节。==

What might someone running on a remote operating system know that no one else knows?
==在远程操作系统上运行的某人可能知道哪些别人不知道的事情？==

How about a password? How about a private key?
==密码怎么样？私钥怎么样？==

Most of our distributed system authentication will rely on one of these two elements.
==我们的大多数分布式系统身份验证将依赖于这两个元素之一。==

Either you require the remote machine to provide you with a password, or you require it to provide evidence using a private key stored only on that machine.
==要么你要求远程机器向你提供密码，要么你要求它使用仅存储在该机器上的私钥提供证据。==

In each case, you need to know something to check the authentication: either the password (or, better, a cryptographic hash of the password plus a salt) or the public key.
==在每种情况下，你都需要知道一些信息来检查身份验证：要么是密码（或者更好的是，密码加盐后的密码学哈希值），要么是公钥。==

When is each appropriate?
==每种方式在何时适用？==

Passwords tend to be useful if there are a vast number of parties who need to authenticate themselves to one party.
==如果有大量的方需要向一个方进行身份验证，密码往往很有用。==

Public keys tend to be useful if there’s one party who needs to authenticate himself to a vast number of parties.
==如果有一个方需要向大量的方证明自己的身份，公钥往往很有用。==

Why?
==为什么？==

With a password, the authentication provides evidence that somebody knows a password.
==使用密码时，身份验证提供了某人知道密码的证据。==

If you want to know exactly who that is (which is usually important), only the party authenticating and the party checking can know it.
==如果你想确切地知道那个人是谁（这通常很重要），只有进行身份验证的方和进行检查的方能知道它。==

With a public key, many parties can know the key, but only one party who knows the matching private key can authenticate himself.
==使用公钥时，许多方都可以知道该密钥，但只有知道匹配私钥的那一方才能验证自己的身份。==

So we tend to use both mechanisms, but for different cases.
==因此，我们倾向于使用这两种机制，但针对不同的情况。==

When a web site authenticates itself to a user, it’s done with PK cryptography.
==当网站向用户验证其身份时，它是通过公钥（PK）加密完成的。==

By distributing one single public key (to vast numbers of users), the web site can be authenticated by all its users.
==通过分发一个单一的公钥（给大量用户），该网站可以被其所有用户验证。==

The web site need not bother keeping separate authentication information to authenticate itself to each user.
==该网站无需费力为每个用户保存单独的身份验证信息来验证自己。==

When that user authenticates itself to the web site, it’s done with a password.
==当该用户向网站验证身份时，是通过密码完成的。==

Each user must be separately authenticated to the web site, so we require a unique piece of identifying information for that user, preferably something that’s easy for a person to use.
==每个用户必须单独向网站进行身份验证，因此我们要求为该用户提供唯一的标识信息，最好是易于人们使用的信息。==

Setting up and distributing public keys is hard, while setting up individual passwords is relatively easy.
==设置和分发公钥很困难，而设置个人密码相对容易。==

How, practically, do we use each of these authentication mechanisms in a distributed system?
==在分布式系统中，我们实际上如何使用这些身份验证机制？==

If we want a remote partner to authenticate itself via passwords, we will require it to provide us with that password, which we will check.
==如果我们希望远程伙伴通过密码进行身份验证，我们将要求它向我们提供该密码，我们将对其进行检查。==

We’ll need to encrypt the transport of the password across the network if we do that; otherwise anyone eavesdropping on the network (which is easy for many wireless networks) will readily learn passwords sent unencrypted.
==如果我们这样做，我们需要对密码在网络上的传输进行加密；否则，任何在网络上偷听的人（这在许多无线网络中很容易做到）都会轻而易举地获知未加密发送的密码。==

Encrypting the password will require that we already have either a shared symmetric key or our partner’s public key.
==加密密码将要求我们已经拥有共享的对称密钥或伙伴的公钥。==

Let’s concentrate now on how we get that public key, either to use it directly or set up the cryptography to protect the password in transit.
==现在让我们集中讨论如何获取该公钥，无论是直接使用它，还是设置加密以保护传输中的密码。==

We’ll spend the rest of the chapter on securing the network connection, but please don’t forget that even if you secure the network perfectly, you still face the major security challenge of the uncontrolled site you’re interacting with on the other side of the network.
==我们将在本章的其余部分讨论如何保护网络连接，但请不要忘记，即使你完美地保护了网络，你仍然面临着与网络另一端进行交互的、不受控制的站点的重大安全挑战。==

If your compromised partner attacks you, it will offer little consolation that the attack was authenticated and encrypted.
==如果你的伙伴已被攻破并攻击你，那么攻击是经过身份验证和加密的这一点并不能提供多少安慰。==

### 57.3 Public Key Authentication For Distributed Systems
==### 57.3 分布式系统的公钥身份验证==

The public key doesn’t need to be secret, but we need to be sure it really belongs to our partner.
==公钥不需要保密，但我们需要确保它确实属于我们的伙伴。==

If we have a face-to-face meeting, our partner can directly give us a public key in some form or another, in which case we can be pretty sure it’s the right one.
==如果我们进行面对面的会面，我们的伙伴可以直接以某种形式给我们一个公钥，在这种情况下，我们可以非常确定它是正确的。==

That’s limiting, though, since we often interact with partners whom we never see face to face.
==不过这是有局限性的，因为我们经常与从未见过面的伙伴互动。==

For that matter, whose “face” belongs to Amazon or Google?
==就此而言，亚马逊或谷歌的“脸”属于谁？==

Fortunately, we can use the fact that secrecy isn’t required to simply create a bunch of bits containing the public key.
==幸运的是，我们可以利用不需要保密这一事实，简单地创建一串包含公钥的比特。==

Anyone who gets a copy of the bits has the key.
==任何获得这些比特副本的人都拥有该密钥。==

But how do they know for sure whose key it is?
==但他们如何确定这是谁的密钥呢？==

What if some other trusted party known to everyone who needs to authenticate our partner used their own public key to cryptographically sign that bunch of bits, verifying that they do indeed belong to our partner?
==如果某个其他受信任的方（每个需要验证我们伙伴身份的人都认识它）使用他们自己的公钥对这串比特进行加密签名，验证它们确实属于我们的伙伴，那会怎么样呢？==

If we could check that signature, we could then be sure that bunch of bits really does represent our partner’s public key, at least to the extent that we trust that third party who did the signature.
==如果我们能检查该签名，我们就能确定这串比特确实代表了我们伙伴的公钥，至少在我们信任进行签名的第三方的范围内是如此。==

This technique is how we actually authenticate web sites and many other entities on the Internet.
==这种技术就是我们实际上如何在互联网上验证网站和许多其他实体身份的方法。==

Every time you browse the web or perform any other web-based activity, you use it.
==每次你浏览网页或执行任何其他基于网络的操作时，你都会使用它。==

The signed bundle of bits is called a **certificate**.
==这一组经过签名的比特被称为**证书（certificate）**。==

Essentially, it contains information about the party that owns the public key, the public key itself, and other information, such as an expiration date.
==从本质上讲，它包含有关拥有公钥的方的信息、公钥本身以及其他信息（如到期日期）。==

The entire set of information, including the public key, is run through a cryptographic hash, and the result is encrypted with the trusted third party’s private key, digitally signing the certificate.
==整个信息集（包括公钥）通过密码学哈希运行，结果用受信任第三方的私钥加密，从而对证书进行数字签名。==

If you obtain a copy of the certificate, and can check the signature, you can learn someone else’s public key, even if you have never met or had any direct interaction with them.
==如果你获得了证书副本并能检查签名，你就可以获知他人的公钥，即使你从未见过他们或与他们有过任何直接互动。==

In certain ways, it’s a beautiful technology that empowers the whole Internet.
==在某些方面，这是一项赋予整个互联网力量的优美技术。==

Let’s briefly go through an example, to solidify the concepts.
==让我们简要地看一个例子，以巩固这些概念。==

Let’s say Frobazz Inc. wants to obtain a certificate for its public key, which is $K_F$.
==假设 Frobazz 公司想为其公钥 $K_F$ 获取一份证书。==

Frobazz Inc. pays big bucks to Acmesign Co., a widely trusted company whose business it is to sell certificates, to obtain a certificate signed by AcmeSign.
==Frobazz 公司向 Acmesign 公司支付巨资，以获得由 AcmeSign 签名的证书。Acmesign 是一家被广泛信任的公司，其业务就是出售证书。==

Such companies are commonly called **Certificate Authorities**, or **CAs**, since they create authoritative certificates trusted by many parties.
==这类公司通常被称为**证书颁发机构**或 **CA**，因为它们创建被多方信任的权威证书。==

Acmesign checks up on Frobazz Inc. to ensure that the people asking for the certificate actually are legitimate representatives of Frobazz.
==Acmesign 会对 Frobazz 公司进行调查，以确保请求证书的人确实是 Frobazz 的合法代表。==

Acmesign then makes very, very sure that the public key it’s about to embed in a certificate actually is the one that Frobazz wants to use.
==然后，Acmesign 会非常非常确定它即将嵌入证书的公钥确实是 Frobazz 想要使用的那个。==

Assuming it is, Acmesign runs a cryptographic hashing algorithm (perhaps SHA-3) on Frobazz’s name, public key $K_F$, and other information, producing hash $H_F$.
==假设确实如此，Acmesign 对 Frobazz 的名称、公钥 $K_F$ 和其他信息运行密码学哈希算法（可能是 SHA-3），生成哈希值 $H_F$。==

Acmesign then encrypts $H_F$ with its own private key, $P_A$, producing digital signature $S_F$.
==然后，Acmesign 用它自己的私钥 $P_A$ 加密 $H_F$，生成数字签名 $S_F$。==

Finally, Acmesign combines all the information used to produce $H_F$, plus Acmesign’s own identity and the signature $S_F$, into the certificate $C_F$, which it hands over to Frobazz, presumably in exchange for money.
==最后，Acmesign 将所有用于生成 $H_F$ 的信息，加上 Acmesign 自身的身份和签名 $S_F$，组合成证书 $C_F$，并将其交给 Frobazz，大概是为了换取金钱。==

Remember, $C_F$ is just some bits.
==记住，$C_F$ 仅仅是一些比特。==

Now Frobazz Inc. wants to authenticate itself over the Internet to one of its customers.
==现在 Frobazz 公司想要通过互联网向其客户之一验证自己的身份。==

If the customer already has Frobazz’s public key, we can use public key authentication mechanisms directly.
==如果客户已经拥有 Frobazz 的公钥，我们可以直接使用公钥身份验证机制。==

If the customer does not have the public key, Frobazz sends $C_F$ to the customer.
==如果客户没有该公钥，Frobazz 会将 $C_F$ 发送给客户。==

The customer examines the certificate, sees that it was generated by Acmesign using, say, SHA-3, and runs the same information that Acmesign hashed (all of which is in the certificate itself) through SHA-3, producing $H_F'$.
==客户检查该证书，看到它是 Acmesign 使用（比如）SHA-3 生成的，并将 Acmesign 哈希过的相同信息（所有这些信息都在证书本身中）通过 SHA-3 运行，产生 $H_F'$。==

Then the customer uses Acmesign’s public key to decrypt $S_F$ (also in the certificate), obtaining $H_F$.
==然后客户使用 Acmesign 的公钥来解密 $S_F$（也在证书中），获得 $H_F$。==

If all is well, $H_F$ equals $H_F'$, and now the customer knows that the public key in the certificate is indeed Frobazz’s.
==如果一切正常，$H_F$ 等于 $H_F'$，现在客户知道证书中的公钥确实是 Frobazz 的。==

Public key-based authentication can proceed.
==基于公钥的身份验证可以继续进行。==

If the two hashes aren’t exactly the same, the customer knows that something fishy is going on and will not accept the certificate.
==如果这两个哈希值不完全相同，客户就知道有些不对劲，并且不会接受该证书。==

There are some wonderful properties about this approach to learning public keys.
==这种获取公钥的方法有一些奇妙的特性。==

First, note that the signing authority (Acmesign, in our example) did not need to participate in the process of the customer checking the certificate.
==首先，请注意，签署机构（在我们例子中是 Acmesign）不需要参与客户检查证书的过程。==

In fact, Frobazz didn’t really, either.
==事实上，Frobazz 也不需要。==

The customer can get the certificate from literally anywhere and obtain the same degree of assurance of its validity.
==客户几乎可以从任何地方获取该证书，并获得同等程度的有效性保证。==

Second, it only needs to be done once per customer.
==其次，每个客户只需要操作一次。==

After obtaining the certificate and checking it, the customer has the public key that is needed.
==在获取并检查证书后，客户就拥有了所需的公钥。==

From that point onward, the customer can simply store it and use it.
==从那时起，客户只需存储并使用它即可。==

If, for whatever reason, it gets lost, the customer can either extract it again from the certificate (if that has been saved), or go through the process of obtaining the certificate again.
==如果由于某种原因丢失了它，客户可以从证书中再次提取（如果证书已保存），或者重新执行获取证书的过程。==

Third, the customer had no need to trust the party claiming to be Frobazz until that identity had been proven by checking the certificate.
==第三，在通过检查证书证明其身份之前，客户不需要信任声称是 Frobazz 的那一方。==

The customer can proceed with caution until the certificate checks out.
==在证书通过检查之前，客户可以谨慎行事。==

Assuming you’ve been paying attention for the last few chapters, you should be saying to yourself, “now, wait a minute, isn’t there a chicken-and-egg problem here?”
==假设你一直在关注过去的几个章节，你应该会对自己说：“现在，等等，这里难道没有一个‘先有鸡还是先有蛋’的问题吗？”==

We’ll learn Frobazz’s public key by getting a certificate for it.
==我们将通过获取 Frobazz 公钥的证书来获知它。==

The certificate will be signed by Acmesign.
==证书将由 Acmesign 签名。==

We’ll check the signature by knowing Acmesign’s public key.
==我们将通过获知 Acmesign 的公钥来检查签名。==

But where did we get Acmesign’s key?
==但我们从哪里得到 Acmesign 的密钥呢？==

We really hope you did have that head-scratching moment and asked yourself that question, because if you did, you understand the true nature of the Internet authentication problem.
==我们真心希望你确实有过那个抓耳挠腮的时刻并问过自己这个问题，因为如果你问了，你就理解了互联网身份验证问题的本质。==

Ultimately, we’ve got to bootstrap it.
==归根结底，我们必须对其进行引导（bootstrap）。==

You’ve got to somehow or other obtain a public key for somebody that you trust.
==你必须以某种方式获得你所信任的某人的公钥。==

Once you do, if it’s the right public key for the right kind of party, you can then obtain a lot of other public keys.
==一旦你这样做了，如果它是适合那类方的正确公钥，你就可以接着获取许多其他公钥。==

But without something to start from, you can’t do much of anything.
==但如果没有一个起始点，你什么也做不了。==

Where do you get that primal public key?
==你从哪里得到那个原始公钥呢？==

Most commonly, it comes in a piece of software you obtain and install.
==最常见的情况是，它包含在你获取并安装的一款软件中。==

The one you use most often is probably your browser, which typically comes with the public keys for several hundred trusted authorities.
==你最常使用的可能就是你的浏览器，它通常自带了数百个受信任机构的公钥。==

Whenever you go to a new web site that cares about security, it provides you with a certificate containing that site’s public key, and signed by one of those trusted authorities pre-configured into your browser.
==每当你访问一个注重安全的新网站时，它会向你提供一个包含该网站公钥的证书，该证书由预先配置在浏览器中的受信任机构之一签名。==

You use the pre-configured public key of that authority to verify that the certificate is indeed proper, after which you know the public key of that web site.
==你使用该机构预先配置的公钥来验证证书是否确实正当，之后你就知道了该网站的公钥。==

From that point onward, you can use the web site’s public key to authenticate it.
==从那时起，你就可以使用该网站的公钥来验证其身份。==

Anyone can create a certificate, not just those trusted CAs, either by getting one from someone whose business it is to issue certificates or simply by creating one from scratch, following a certificate standard (**X.509** is the most commonly used certificate standard).
==任何人都可以创建证书，而不仅仅是那些受信任的 CA，既可以从专门从事证书颁发业务的人那里获取，也可以按照证书标准（**X.509** 是最常用的证书标准）从头开始创建一个。==

The necessary requirement: the party being authenticated and the parties performing the authentication must all trust whoever created the certificate.
==必要条件：被验证身份的方和执行身份验证的方必须都信任证书的创建者。==

If they don’t trust that party, why would they believe the certificate is correct?
==如果他们不信任那一方，他们为什么要相信证书是正确的呢？==

If you are building your own distributed system, you can create your own certificates from a machine you (and other participants in the system) trust and can handle the bootstrapping issue by carefully hand-installing the certificate signing machine’s public key wherever it needs to be.
==如果你正在构建自己的分布式系统，你可以从你（以及系统中的其他参与者）信任的机器上创建自己的证书，并可以通过在需要的地方小心地手动安装证书签名机器的公钥来处理引导问题。==

There are a number of existing software packages for creating certificates, and, as usual with critical cryptographic software, you’re better off using an existing, trusted implementation rather than coding up one of your own.
==有许多现成的软件包用于创建证书，而且与关键的密码学软件一样，你最好使用现有的、受信任的实现，而不是自己编写代码。==

One example you might want to look at is **PGP** (available in both supported commercial versions and compatible but less supported free versions), but there are others.
==一个你可能想参考的例子是 **PGP**（有受支持的商业版本和兼容但受支持较少的免费版本），当然还有其他选择。==

If you are working with a fixed number of machines and you can distribute the public key by hand in some reasonable way, you can dispense entirely with certificates.
==如果你在固定数量的机器上工作，并且可以通过某种合理的方式手动分发公钥，你就可以完全不需要证书。==

Remember, the only point of a PK certificate is to distribute the public key, so if your public keys are already where they need to be, you don’t need certificates.
==记住，公钥证书的唯一目的就是分发公钥，因此如果你的公钥已经在需要的地方了，你就不需要证书。==

OK, one way or another you’ve obtained the public key you need to authenticate some remote machine. Now what?
==好了，通过某种方式，你已经获得了验证某台远程机器身份所需的公钥。接下来怎么办？==

Well, anything they send you encrypted with their private key will only decrypt with their public key, so anything that decrypts properly with the public key must have come from them, right?
==嗯，他们用私钥加密后发送给你的任何内容，都只能用他们的公钥解密，所以任何能用公钥正确解密的内容一定来自他们，对吧？==

Yes, it must have come from them at some point, but it’s possible for an adversary to have made a copy of a legitimate message the site sent at some point in the past and then send it again it at some future date.
==是的，它一定在某个时间点来自他们，但敌手有可能复制了该站点在过去某个时间点发送的一条合法消息，然后在未来的某个日期再次发送。==

Depending on exactly what’s going on, that could cause trouble, since you may take actions based on that message that the legitimate site did not ask for.
==取决于具体发生了什么，这可能会导致麻烦，因为你可能会根据该消息采取合法站点并未要求的行动。==

So usually we take measures to ensure that we’re not being subjected to a **replay attack**.
==因此，我们通常会采取措施，确保我们不会受到**重放攻击**。==

Such measures generally involve ensuring that each encrypted message contains unique information not in any other message.
==此类措施通常涉及确保每条加密消息都包含其他任何消息中都不存在的唯一信息。==

This feature is built in properly to standard cryptographic protocols, so if you follow our advice and use one of those, you will get protection from such replay attacks.
==此功能已正确内置于标准密码学协议中，因此如果你遵循我们的建议并使用其中之一，你将获得针对此类重放攻击的保护。==

If you insist on building your own cryptography, you’ll need to learn a good deal more about this issue and will have to apply that knowledge very carefully.
==如果你坚持构建自己的加密算法，你需要更多地了解这个问题，并且必须非常谨慎地应用这些知识。==

Also, public key cryptography is expensive.
==此外，公钥加密开销很大。==

We want to stop using it as soon as possible, but we also want to continue to get authentication guarantees.
==我们希望尽快停止使用它，但我们也希望继续获得身份验证保证。==

We’ll see how to do that when we discuss **SSL** and **TLS**.
==我们将在讨论 **SSL** 和 **TLS** 时看到如何做到这一点。==

### 57.4 Password Authentication For Distributed Systems
==### 57.4 分布式系统的密码身份验证==

The other common option to authenticate in distributed systems is to use a password.
==分布式系统中另一种常见的身份验证选项是使用密码。==

As noted above, that will work best in situations where only two parties need to deal with any particular password: the party being authenticated and the authenticating party.
==如前所述，这在只有两个方需要处理任何特定密码的情况下效果最好：被验证身份的方和进行身份验证的方。==

They make sense when an individual user is authenticating himself to a site that hosts many users, such as when you log in to Amazon.
==当个人用户向托管许多用户的站点验证自己的身份时（例如当你登录亚马逊时），这种方式是有意义的。==

They don’t make sense when that site is trying to authenticate itself to an individual user, such as when a web site claiming to be Amazon wants to do business with you.
==当该站点试图向个人用户验证自己的身份时（例如当一个自称是亚马逊的网站想要和你做生意时），这种方式就没有意义了。==

Public key authentication works better there.
==在这种情况下，公钥身份验证的效果更好。==

How do we properly handle password authentication over the network, when it is a reasonable choice?
==当密码身份验证是一个合理的选择时，我们如何正确处理网络上的密码身份验证？==

The password is usually associated with a particular user ID, so the user provides that ID and password to the site requiring authentication.
==密码通常与特定的用户 ID 相关联，因此用户向需要身份验证的站点提供该 ID 和密码。==

That typically happens over a network, and typically we cannot guarantee that networks provide confidentiality.
==这通常发生在网络上，而通常我们无法保证网络能提供机密性。==

If our password is divulged to someone else, they’ll be able to pose as us, so we must add confidentiality to this cross-network authentication, generally by encrypting at least the password itself (though encrypting everything involved is better).
==如果我们的密码泄露给了别人，他们就能冒充我们，所以我们必须为这种跨网络身份验证增加机密性，通常通过至少加密密码本身（尽管加密涉及的所有内容更好）。==

So a typical interchange with Alice trying to authenticate herself to Frobazz Inc.’s web site would involve the site requesting a user ID and password and Alice providing both, but encrypting them before sending them over the network.
==因此，爱丽丝尝试向 Frobazz 公司的网站验证身份的典型交互将涉及：网站请求用户 ID 和密码，爱丽丝提供这两者，但在通过网络发送之前对其进行加密。==

The obvious question you should ask is, encrypting them with what key?
==你应该问的一个显而易见的问题是：用什么密钥加密它们？==

Well, if Frobazz authenticated itself to Alice using PK, as discussed above, Alice can encrypt her user ID and password with Frobazz’s public key.
==既然 Frobazz 已经按照上述方式使用公钥加密（PK）向爱丽丝验证了身份，爱丽丝就可以用 Frobazz 的公钥加密她的用户 ID 和密码。==

Frobazz Inc., having the matching private key, will be able to check them, but nobody else can read them.
==Frobazz 公司拥有匹配的私钥，能够检查它们，但其他任何人都无法读取。==

In actuality, there are various reasons why this alone would not suffice, including replay attacks, as mentioned above.
==实际上，出于各种原因（包括上述提到的重放攻击），仅靠这一点是不够的。==

But we can and do use Frobazz’s private key to set up cryptography that will protect Alice’s password in transit.
==但我们可以且确实利用 Frobazz 的私钥建立起加密机制，以保护爱丽丝在传输过程中的密码。==

We’ll discuss the details in the section on SSL/TLS.
==我们将在关于 SSL/TLS 的部分讨论具体细节。==

We discussed issues of password choice and management in the chapter on authentication, and those all apply in the networking context.
==我们在身份验证章节中讨论了密码选择和管理的问题，这些问题同样适用于网络环境。==

Otherwise, there’s not that much more to say about how we’ll use passwords, other than to note that after the remote site has verified the password, what does it actually know?
==除此之外，关于我们将如何使用密码，没有更多可说的了，只需注意在远程站点验证密码后，它实际上知道了什么？==

That the site or user who sent the password knows it, and, to the strength of the password, that site or user is who it claims to be.
==它知道发送密码的站点或用户知道该密码，并且根据密码的强度，确定该站点或用户就是它所声称的那个。==

But what about future messages that come in, supposedly from that site?
==但是，此后收到的据称来自该站点的消息又该如何处理呢？==

Remember, anyone can create any message they want, so if all we do is verify that the remote site sent us the right password, all we know is that particular message is authentic.
==请记住，任何人都可以创建他们想要的任何消息，因此如果我们只是验证远程站点发送了正确的密码，我们所知道的仅仅是那条特定消息是真实的。==

We don’t want to have to include the password on every message we send, just as we don’t want to use PK to encrypt every message we send.
==我们不想在发送的每条消息中都包含密码，就像我们不想使用公钥加密（PK）来加密发送的每条消息一样。==

We will use both authentication techniques to establish initial authenticity, then use something else to tie that initial authenticity to subsequent interactions.
==我们将同时使用这两种身份验证技术来建立初始真实性，然后使用其他手段将这种初始真实性与随后的交互联系起来。==

Let’s move right along to SSL/TLS to talk about how we do that.
==让我们直接进入 SSL/TLS 部分，讨论如何实现这一点。==

### 57.5 SSL/TLS
### 57.5 SSL/TLS

We saw in an earlier chapter that a standard method of communicating between processes in modern systems is the **socket**.
==我们在之前的章节中看到，现代系统中进程间通信的标准方法是**套接字（socket）**。==

That’s equally true when the processes are on different machines.
==当进程位于不同的机器上时，这一点同样适用。==

So a natural way to add cryptographic protection to communications crossing unprotected networks is to add cryptographic features to sockets.
==因此，为跨越不受保护网络的通信添加加密保护的一种自然方式是为套接字添加加密功能。==

That’s precisely what **SSL** (the **Secure Socket Layer**) was designed to do, many years ago.
==这正是多年前设计 **SSL**（**安全套接层**）的目的。==

Unfortunately, SSL did not get it quite right.
==不幸的是，SSL 做得并不完全正确。==

That’s because it’s pretty darn hard to get it right, not because the people who designed and built it were careless.
==这是因为要把它做对真的很难，而不是因为设计和构建它的人粗心大意。==

They learned from their mistakes and created a new version of encrypted sockets called **Transport Layer Security** (**TLS**).
==他们从错误中吸取教训，创建了一个新版本的加密套接字，称为**传输层安全**（**TLS**）。==

You will frequently hear people talk about using SSL.
==你会经常听到人们谈论使用 SSL。==

They are usually treating it as a shorthand for SSL/TLS.
==他们通常将其视为 SSL/TLS 的简写。==

SSL, formally, is insecure and should never be used for anything.
==从正式意义上讲，SSL 是不安全的，绝不应被用于任何用途。==

Use TLS.
==请使用 TLS。==

The only exception is that some very old devices might run software that doesn’t support TLS.
==唯一的例外是，一些非常旧的设备可能运行不支持 TLS 的软件。==

In that case, it’s better to use SSL than nothing.
==在这种情况下，使用 SSL 总比什么都不用强。==

We’ll adopt the same shorthand as others from here on, since it’s ubiquitous.
==从现在起，我们将采用和其他人一样的简写，因为这无处不在。==

The concept behind SSL is simple: move encrypted data through an ordinary socket.
==SSL 背后的概念很简单：通过普通套接字传输加密数据。==

You set up a socket, set up a special structure to perform whatever cryptography you want, and hook the output of that structure to the input of the socket.
==你设置一个套接字，设置一个特殊的结构来执行你想要的任何加密操作，并将该结构的输出挂接到套接字的输入。==

You reverse the process on the other end.
==在另一端执行相反的过程。==

What’s simple in concept is rather laborious in execution, with a number of steps required to achieve the desired result.
==概念上简单的事情在执行中相当费力，需要经过若干步骤才能达到预期的结果。==

There are further complications due to the general nature of SSL.
==由于 SSL 的通用性质，还存在进一步的复杂性。==

The technology is designed to support a variety of cryptographic operations and many different ciphers, as well as multiple methods to perform key exchange and authentication between the sender and receiver.
==该技术旨在支持各种密码操作和许多不同的密码，以及在发送者和接收者之间执行密钥交换和身份验证的多种方法。==

The process of adding SSL to your program is intricate, requiring the use of particular libraries and a sequence of calls into those libraries to set up a correct SSL connection.
==将 SSL 添加到程序的过程错综复杂，需要使用特定的库，并按顺序调用这些库来建立正确的 SSL 连接。==

We will not go through those operations step by step here, but you will need to learn about them to make proper use of SSL.
==我们在这里不会逐步讲解这些操作，但你需要了解它们才能正确使用 SSL。==

Their purpose is, for the most part, to allow a wide range of generality both in the cryptographic options SSL supports and the ways you use those options in your program.
==它们的目的在很大程度上是为了在 SSL 支持的密码选项以及你在程序中使用这些选项的方式上提供广泛的通用性。==

For example, these setup calls would allow you to create one set of SSL connections using AES-128 and another using AES-256, if that’s what you needed to do.
==例如，如果你需要这样做，这些设置调用将允许你创建一组使用 AES-128 的 SSL 连接和另一组使用 AES-256 的 SSL 连接。==

One common requirement for setting up an SSL connection that we will go through in a bit more detail is how to securely distribute whatever cryptographic key you will use for the connection you are setting up.
==我们将稍微详细介绍建立 SSL 连接的一个共同要求，即如何安全地分发你将用于正在建立的连接的任何加密密钥。==

Best cryptographic practice calls for you to use a brand new key to encrypt the bulk of your data for each connection you set up.
==最佳密码学实践要求你为建立的每个连接使用一个全新的密钥来加密大部分数据。==

You will use public/private keys for authentication many times, but as we discussed earlier, you need to use symmetric cryptography to encrypt the data once you have authenticated your partner, and you want a fresh key for that.
==你会多次使用公钥/私钥进行身份验证，但正如我们之前讨论的，一旦你验证了伙伴的身份，你就需要使用对称加密来加密数据，并且你需要为此使用一个新密钥。==

Even if you are running multiple simultaneous SSL connections with the same partner, you want a different symmetric key for each connection.
==即使你与同一个伙伴运行多个并发的 SSL 连接，你也希望为每个连接使用不同的对称密钥。==

So what do you need to do to set up a new SSL connection?
==那么，建立一个新的 SSL 连接需要做些什么呢？==

We won’t go through all of the gory details, but, in essence, SSL needs to bootstrap a secure connection based (usually) on asymmetric cryptography when no usable symmetric key exists.
==我们不会详细讲解所有细节，但本质上，当不存在可用的对称密钥时，SSL 需要（通常）基于非对称加密来引导一个安全连接。==

The very first step is to start a negotiation between the client and the server.
==第一步是在客户端和服务器之间开始协商。==

Each party might only be able to handle particular ciphers, secure hashes, key distribution strategies, or authentication schemes, based on what version of SSL they have installed, how it’s configured, and how the programs that set up the SSL connection on each side were written.
==根据所安装的 SSL 版本、配置方式以及各方建立 SSL 连接的程序的编写方式，每一方可能只能处理特定的密码、安全哈希、密钥分发策略或身份验证方案。==

In the most common cases, the negotiation will end in both sides finding some acceptable set of ciphers and techniques that hit a balance between security and performance.
==在最常见的情况下，协商将以双方找到一组可接受的密码和技术而告终，这些密码和技术在安全性和性能之间达到了平衡。==

For example, they might use RSA with 2048 bit keys for asymmetric cryptography, some form of a **Diffie-Hellman key exchange** mechanism to establish a new symmetric key, SHA-3 to generate secure hashes for integrity, and AES with 256 bit keys for bulk encryption.
==例如，他们可能会使用 2048 位密钥的 RSA 进行非对称加密，使用某种形式的 **Diffie-Hellman 密钥交换**机制建立新的对称密钥，使用 SHA-3 生成用于完整性的安全哈希，并使用 256 位密钥的 AES 进行批量加密。==

A modern installation of SSL might support 50 or more different combinations of these options.
==现代 SSL 安装可能会支持 50 种或更多这些选项的组合。==

In some cases, it may be important for you to specify which of these many combinations are acceptable for your system, but often most of them will do, in which case you can let SSL figure out which to use for each connection without worrying about it yourself.
==在某些情况下，指定这些众多组合中哪些对于你的系统是可接受的可能很重要，但通常其中大多数都可以，在这种情况下，你可以让 SSL 为每个连接决定使用哪一个，而无需自己操心。==

The negotiation will happen invisibly and SSL will get on with its main business: authenticating at least the server (optionally the client), creating and distributing a new symmetric key, and running the communication through the chosen cipher using that key.
==协商将隐形发生，SSL 将继续其主要业务：至少验证服务器（可选验证客户端），创建并分发一个新的对称密钥，并使用该密钥通过选定的密码运行通信。==

We can use Diffie-Hellman key exchange to create the key (and SSL frequently does), but we need to be sure who we are sharing that key with.
==我们可以使用 Diffie-Hellman 密钥交换来创建密钥（SSL 经常这样做），但我们需要确定我们在与谁共享该密钥。==

SSL offers a number of possibilities for doing so.
==SSL 为此提供了多种可能性。==

The most common method is for the client to obtain a certificate containing the server’s public key (typically by having the server send it to the client) and to use the public key in that certificate to verify the authenticity of the server’s messages.
==最常用的方法是客户端获取一个包含服务器公钥的证书（通常是由服务器将其发送给客户端），并使用该证书中的公钥来验证服务器消息的真实性。==

It is possible for the client to obtain the certificate through some other means, though less common.
==客户端有可能通过其他手段获取证书，尽管这种情况较少见。==

Note that having the server send the certificate is every bit as secure (or insecure) as having the client obtain the certificate through other means.
==请注意，让服务器发送证书与让客户端通过其他手段获取证书同样安全（或不安全）。==

Certificate security is not based on the method used to transport it, but on the cryptography embedded in the certificate.
==证书的安全性并非基于传输它的方法，而是基于嵌入在证书中的密码学。==

With the certificate in hand (however the client got it), the Diffie-Hellman key exchange can now proceed in an authenticated fashion.
==一旦拿到证书（无论客户端是如何得到的），Diffie-Hellman 密钥交换现在就可以以经过身份验证的方式进行。==

### ASIDE: DIFFIE-HELLMAN KEY EXCHANGE
==### 旁注：DIFFIE-HELLMAN 密钥交换==

What if you want to share a secret key between two parties, but they can only communicate over an insecure channel, where eavesdroppers can hear anything they say?
==如果你想在两方之间共享一个密钥，但他们只能通过不安全的通道通信，偷听者可以听到他们说的任何话，该怎么办？==

You might think this is an impossible problem to solve, but you’d be wrong.
==你可能认为这是一个无法解决的问题，但你错了。==

Two extremely smart cryptographers named Whitfield Diffie and Martin Hellman solved this problem years ago, and their solution is in common use.
==两位极其聪明的密码学家 Whitfield Diffie 和 Martin Hellman 多年前就解决了这个问题，他们的解决方案已被广泛使用。==

It’s called **Diffie-Hellman key exchange**.
==它被称为 **Diffie-Hellman 密钥交换**。==

Here’s how it works.
==以下是它的工作原理。==

Let’s say Alice and Bob want to share a secret key, but currently don’t share anything, other than the ability to send each other messages.
==假设爱丽丝和鲍勃想要共享一个密钥，但目前除了互相发送消息的能力外，没有任何共享的东西。==

First, they agree on two numbers, $n$ (a large prime number) and $g$ (which is primitive mod $n$).
==首先，他们商定两个数字，$n$（一个大质数）和 $g$（它是 $n$ 的原根）。==

They can use the insecure channel to do this, since $n$ and $g$ don’t need to be secret.
==他们可以使用不安全通道来做这件事，因为 $n$ 和 $g$ 不需要保密。==

Alice chooses a large random integer, say $x$, calculates $X = g^x \pmod n$, and sends $X$ to Bob.
==爱丽丝选择一个大的随机整数，假设为 $x$，计算 $X = g^x \pmod n$，并将 $X$ 发送给鲍勃。==

Bob independently chooses a large random integer, say $y$, calculates $Y = g^y \pmod n$, and sends $Y$ to Alice.
==鲍勃独立选择一个大的随机整数，假设为 $y$，计算 $Y = g^y \pmod n$，并将 $Y$ 发送给爱丽丝。==

The eavesdroppers can hear $X$ and $Y$, but since Alice and Bob didn’t send $x$ or $y$, the eavesdroppers don’t know those values.
==偷听者可以听到 $X$ 和 $Y$，但由于爱丽丝和鲍勃没有发送 $x$ 或 $y$，偷听者不知道这些值。==

It’s important that Alice and Bob keep $x$ and $y$ secret.
==重要的是爱丽丝和鲍勃必须对 $x$ 和 $y$ 保密。==

Alice now computes $k = Y^x \pmod n$, and Bob computes $k = X^y \pmod n$.
==爱丽丝现在计算 $k = Y^x \pmod n$，鲍勃计算 $k = X^y \pmod n$。==

Alice and Bob get the same value $k$ from these computations.
==爱丽丝和鲍勃通过这些计算得到相同的 $k$ 值。==

Why?
==为什么？==

Well, $Y^x \pmod n = (g^y \pmod n)^x \pmod n$, which in turn equals $g^{yx} \pmod n$.
==嗯，$Y^x \pmod n = (g^y \pmod n)^x \pmod n$，这又等于 $g^{yx} \pmod n$。==

$X^y \pmod n = (g^x \pmod n)^y \pmod n = g^{xy} \pmod n$, which is the same thing Alice got.
==$X^y \pmod n = (g^x \pmod n)^y \pmod n = g^{xy} \pmod n$，这与爱丽丝得到的结果相同。==

Nothing magic there, that’s just how exponentiation and modulus arithmetic work.
==这没有什么神奇的，这只是指数运算和模运算的工作原理。==

So $k$ is the same in both calculations and is known to both Alice and Bob.
==因此，在两次计算中 $k$ 是相同的，并且爱丽丝和鲍勃都知道它。==

What about those eavesdroppers?
==那些偷听者呢？==

They know $g$, $n$, $X$, and $Y$, but not $x$ or $y$.
==他们知道 $g$、$n$、$X$ 和 $Y$，但不知道 $x$ 或 $y$。==

They can compute $k' = XY \pmod n$, but that is not equal to the $k$ Alice and Bob calculated.
==他们可以计算 $k' = XY \pmod n$，但这不等于爱丽丝和鲍勃计算出的 $k$。==

They do have approaches to derive $x$ or $y$, which would give them enough information to obtain $k$, but those approaches require them either to perform a calculation for every possible value of $n$ (which is why you want $n$ to be very large) or to compute a discrete logarithm.
==他们确实有推导 $x$ 或 $y$ 的方法，这将给他们足够的信息来获得 $k$，但这些方法要求他们要么对 $n$ 的每个可能值执行计算（这就是为什么你希望 $n$ 非常大），要么计算离散对数。==

Computing a discrete logarithm is a solvable problem, but it’s computationally infeasible for large numbers.
==计算离散对数是一个可解决的问题，但对于大数来说，它在计算上是不可行的。==

So if the prime $n$ is large (and meets other properties), the eavesdroppers are out of luck.
==因此，如果质数 $n$ 很大（并符合其他属性），偷听者就没戏了。==

How large? 600 digit primes should be good enough.
==多大？600 位的质数应该足够了。==

Neat, no?
==很巧妙，不是吗？==

But there is a fly in the ointment, when one considers using Diffie-Hellman over a network.
==但是，当考虑在网络上使用 Diffie-Hellman 时，美中不足的是。==

It ensures that you securely share a key with someone, but gives you no assurance of who you’re sharing the key with.
==它确保你与某人安全地共享密钥，但它无法保证你在与谁共享密钥。==

Maybe Alice is sharing the key with Bob, as she thinks and hopes, but maybe she’s sharing it with Mallory, who posed as Bob and injected his own $Y$.
==也许爱丽丝正在与她认为并希望的鲍勃共享密钥，但也可能她正在与 Mallory 共享，后者冒充鲍勃并注入了他自己的 $Y$。==

Since we usually care who we’re in secure communication with, we typically augment Diffie-Hellman with an authentication mechanism to provide the assurance of our partner’s identity.
==由于我们通常关心我们在与谁进行安全通信，因此我们通常会用身份验证机制来增强 Diffie-Hellman，以提供对伙伴身份的保证。==

The server will sign its Diffie-Hellman messages with its private key, which will allow the client to determine that its partner in this key exchange is the correct server.
==服务器将使用其私钥签署其 Diffie-Hellman 消息，这将允许客户端确定其在该密钥交换中的伙伴是正确的服务器。==

Typically, the client does not provide (or even have) its own certificate, so it cannot sign its Diffie-Hellman messages.
==通常，客户端不提供（甚至没有）自己的证书，因此它不能签署其 Diffie-Hellman 消息。==

This implies that when SSL’s Diffie-Hellman key exchange completes, typically the client is pretty sure who the server is, but the server has no clue about the client’s identity.
==这意味着当 SSL 的 Diffie-Hellman 密钥交换完成时，客户端通常很确定服务器是谁，但服务器对客户端的身份一无所知。==

Recalling our discussion earlier in this chapter, it actually isn’t a problem for the server to be unsure about the client’s identity at this point, in many cases.
==回想本章早些时候的讨论，在许多情况下，服务器在此时不确定客户端的身份实际上并不是问题。==

As we stated earlier, the client will probably want to use a password to authenticate itself, not a public key extracted from a certificate.
==如前所述，客户端可能希望使用密码来验证自己的身份，而不是从证书中提取公钥。==

As long as the server doesn’t permit the client to do anything requiring trust before the server obtains and checks the client’s password, the server probably doesn’t care who the client is, anyway.
==只要在服务器获取并检查客户端密码之前，服务器不允许客户端执行任何需要信任的操作，那么服务器可能根本不在乎客户端是谁。==

Many servers offer some services to anonymous clients (such as providing them with publicly available information), so as long as they can get a password from the client before proceeding to more sensitive subjects, there is no security problem.
==许多服务器向匿名客户端提供某些服务（例如向其提供公开可用的信息），因此只要在进入更敏感的话题之前能从客户端获得密码，就不存在安全问题。==

The server can ask the client for a user ID and password later, at any point after the SSL connection is established.
==在 SSL 连接建立后的任何时间点，服务器都可以稍后要求客户端提供用户 ID 和密码。==

Since creating the SSL connection sets up a symmetric key, the exchange of ID and password can be protected with that key.
==由于创建 SSL 连接会建立对称密钥，因此 ID 和密码的交换可以用该密钥进行保护。==

A final word about SSL/TLS: it’s a protocol, not a software package.
==最后关于 SSL/TLS 的一句话：它是一种协议，而不是一个软件包。==

There are multiple different software packages that implement this protocol.
==有多个不同的软件包实现了这一协议。==

Ideally, if they all implement the protocol properly, they all interact correctly.
==理想情况下，如果它们都正确地实现了协议，它们都能正确地进行交互。==

However, they use different code to implement the protocol.
==然而，它们使用不同的代码来实现协议。==

As a result, software flaws in one implementation of SSL/TLS might not be present in other implementations.
==因此，SSL/TLS 的一种实现中的软件漏洞可能不会出现在其他实现中。==

For example, the **Heartbleed** attack was based on implementation details of OpenSSL, but was not present in other implementations, such as the version of SSL/TLS found in Microsoft’s Windows operating system.
==例如，**Heartbleed** 攻击是基于 OpenSSL 的实现细节，但并没有出现在其他实现中，例如微软 Windows 操作系统中的 SSL/TLS 版本。==

It is also possible that the current protocol definition of SSL/TLS contains protocol flaws that would be present in any compliant implementation.
==当前的 SSL/TLS 协议定义本身也有可能包含协议缺陷，这些缺陷会出现在任何合规的实现中。==

If you hear of a security problem involving SSL, determine whether it is a **protocol flaw** or an **implementation flaw** before taking further action.
==如果你听说涉及 SSL 的安全问题，在采取进一步行动之前，请先确定它是**协议缺陷**还是**实现缺陷**。==

### 57.6 Other Authentication Approaches
==### 57.6 其他身份验证方法==

While passwords and public keys are the most common ways to authenticate a remote user or machines, there are other options.
==虽然密码和公钥是验证远程用户或机器身份最常用的方式，但还有其他选择。==

One such option is used all the time.
==其中一种选择一直在被使用。==

After you have authenticated yourself to a web site by providing a password, the web site will continue to assume that the authentication is valid.
==在你通过提供密码向网站验证了身份后，该网站将继续假设该验证是有效的。==

It won’t ask for your password every time you click a link or perform some other interaction with it.
==当你点击链接或与其进行其他交互时，它不会每次都询问你的密码。==

Imagine how much of a pain it would be if you had to provide your password every time you wanted to do anything.
==想象一下，如果你想做任何事都必须提供密码，那将是多么痛苦。==

In such cases, the site you are working with has chosen to make a security tradeoff.
==在这种情况下，你正在使用的站点选择做出了安全性权衡。==

It verified your identity at some time in the past using your password and then relies on another method to authenticate you in the future.
==它在过去的某个时间使用你的密码验证了你的身份，然后依靠另一种方法在未来对你进行身份验证。==

A common method is to use **web cookies**.
==一种常见的方法是使用 **Web Cookie**。==

Web cookies are pieces of data that a web site sends to a client with the intention that the client stores that data and send it back again whenever the client next communicates with the server.
==Web Cookie 是网站发送给客户端的一段数据，目的是让客户端存储该数据，并在下次与服务器通信时将其发回。==

With proper use of cryptography, a server that has verified the password of a client can create a web cookie that securely stores the client’s identity.
==通过正确使用加密技术，验证了客户端密码的服务器可以创建一个安全存储客户端身份的 Web Cookie。==

When the client communicates with the server again, the web browser automatically includes the cookie in the request, which allows the server to verify the client’s identity without asking for a password again.
==当客户端再次与服务器通信时，浏览器会自动在请求中包含该 Cookie，这允许服务器在不再次询问密码的情况下验证客户端的身份。==

If you spend a few minutes thinking about this authentication approach, you might come up with some possible security problems associated with it.
==如果你花几分钟思考这种身份验证方法，你可能会想到一些与其相关的潜在安全问题。==

The people designing this technology have dealt with some of these problems, like preventing an eavesdropper from simply using a cookie that was copied as it went across the network.
==设计这项技术的人已经处理了其中的一些问题，比如防止偷听者直接使用在网络传输过程中复制的 Cookie。==

However, there are other security problems that can’t be solved with these kinds of cookies, but could have been solved if you required the user to provide the password every time.
==然而，还有一些安全问题无法通过这类 Cookie 解决，但如果你要求用户每次都提供密码，这些问题本可以解决。==

Is it better to make life simpler for your user by not asking for a password except when absolutely necessary, or is it better to provide your user with improved security by frequently requiring proof of identity?
==是通过除非绝对必要否则不询问密码来让用户的生活更简单，还是通过频繁要求身份证明来为用户提供更高的安全性，哪种更好？==

The point isn’t that there is one correct answer to this question, but that you need to think about such questions in the design of your system.
==重点不在于这个问题有一个正确的答案，而在于你在设计系统时需要思考此类问题。==

There are other authentication options.
==还有其他身份验证选项。==

One example is what is called a **challenge/response protocol**.
==一个例子是所谓的**挑战/响应协议**。==

The remote machine sends you a challenge, typically in the form of a number.
==远程机器向你发送一个挑战，通常是一个数字的形式。==

To authenticate yourself, you must perform some operation on the challenge that produces a response.
==为了验证身份，你必须对该挑战执行某种操作以产生响应。==

This should be an operation that only the authentic party can perform, so it probably relies on the use of a secret that party knows, but no one else does.
==这应该是一个只有真实方才能执行的操作，因此它可能依赖于使用该方知道而其他人不知道的秘密。==

The secret is applied to the challenge, producing the response, which is sent to the server.
==将秘密应用于挑战，产生响应，并发送给服务器。==

A different challenge is sent every time, requiring a different response, so attackers gain no advantage by listening to and copying down old challenges and responses.
==每次发送的挑战都不同，需要不同的响应，因此攻击者通过偷听并复制旧的挑战和响应无法获得任何优势。==

Another authentication option is to use an **authentication server**.
==另一个身份验证选项是使用**身份验证服务器**。==

In essence, you talk to a server that you trust and that trusts you.
==从本质上讲，你与一个你信任且信任你的服务器交谈。==

The party you wish to authenticate to must also trust the server.
==你希望向其验证身份的那一方也必须信任该服务器。==

The authentication server vouches for your identity in some secure form, usually involving cryptography.
==身份验证服务器以某种安全形式（通常涉及加密）为你的身份提供担保。==

Since the party you wish to communicate with trusts the authentication server, it now trusts that you are who you claim to be.
==由于你希望通信的那一方信任身份验证服务器，它现在也信任你就是你所声称的那个人。==

Online versions are more responsive to changes in security conditions than offline versions like CAs.
==在线版本比像 CA 这样的离线版本对安全状况的变化反应更迅速。==

**Kerberos** is one example of such an online authentication server.
==**Kerberos** 就是这种在线身份验证服务器的一个例子。==

### 57.7 Some Higher Level Tools
==### 57.7 一些高级工具==

In some cases, we can achieve desirable security effects by working at a higher level.
==在某些情况下，我们可以通过在更高级别上工作来达到理想的安全效果。==

**HTTPS** (the cryptographically protected version of the HTTP protocol) and **SSH** (a competitor to SSL most often used to set up secure sessions with remote computers) are two good examples.
==**HTTPS**（HTTP 协议的加密保护版本）和 **SSH**（SSL 的竞争对手，最常用于建立与远程计算机的安全会话）是两个很好的例子。==

### HTTPS
### HTTPS

HTTP, the protocol that supports the World Wide Web, does not have its own security features.
==HTTP（支持万维网的协议）本身没有安全特性。==

Rather than come up with a fresh implementation of security for HTTP, however, HTTPS takes the existing HTTP definition and connects it to SSL/TLS.
==然而，HTTPS 并没有为 HTTP 提出一套全新的安全实现，而是采用了现有的 HTTP 定义并将其连接到 SSL/TLS。==

SSL takes care of establishing a secure connection, including authenticating the web server using the certificate approach discussed earlier and establishing a new symmetric encryption key known only to the client and server.
==SSL 负责建立安全连接，包括使用前面讨论的证书方法验证 Web 服务器，并建立一个新的仅为客户端和服务器所知的对称加密密钥。==

To a large extent, HTTPS is simply HTTP passed through an SSL connection.
==在很大程度上，HTTPS 只是通过 SSL 连接传输的 HTTP。==

HTTPS makes direct use of a high quality transport security tool, thus replacing an insecure transport with a highly secure transport at very little development cost.
==HTTPS 直接利用高质量的传输安全工具，从而以极低的开发成本将不安全的传输替换为高度安全的传输。==

HTTPS obviously depends heavily on authentication, since we want to be sure we aren’t communicating with malicious web sites.
==HTTPS 显然非常依赖身份验证，因为我们要确保不与恶意网站进行通信。==

HTTPS uses certificates for that purpose.
==HTTPS 为此目的使用证书。==

Remember, however, what a certificate actually tells you, assuming it checks out: that at some moment in time the signing authority thought it was a good idea to vouch that a particular public key belongs to a particular party.
==然而，请记住证书实际上告诉你了什么（假设它通过了检查）：即在某个时间点，签署机构认为担保某个特定公钥属于某个特定方是一个好主意。==

There is no implication that the party is good or evil, that the matching private key is still secret, or even that the certificate signing authority itself is secure and uncompromised.
==这并不暗示该方是善是恶，也不暗示匹配的私钥仍然保密，甚至不暗示证书签署机构本身是安全且未被攻破的。==

Remember also that HTTPS only vouches for authenticity.
==还请记住，HTTPS 仅担保真实性。==

An authenticated web site using HTTPS can still launch an attack on your client.
==使用 HTTPS 的经过身份验证的网站仍然可以对你的客户端发起攻击。==



a push towards servers insisting on HTTPS, and refusing to talk to clients who can’t or won’t speak HTTPS.
==推动服务器强制使用 HTTPS，并拒绝与不能或不愿使用 HTTPS 的客户端进行通信。==

This approach is called HSTS (HTTP Strict Transport Security).
==这种方法被称为 HSTS（HTTP 严格传输安全）。==

HSTS is an option for a web site.
==HSTS 是网站的一个选项。==

If the web site decides it will support HSTS, all interactions with it will be cryptographically secured for any client.
==如果网站决定支持 HSTS，那么与任何客户端的所有交互都将通过加密方式获得安全保障。==

Clients who can’t or won’t accept HTTPS will not be allowed to interact with such a web site.
==不能或不愿接受 HTTPS 的客户端将不被允许与该网站进行交互。==

HSTS is used by a number of major web sites, including Google’s `google.com` domain, but is far from ubiquitous as of 2020.
==许多主流网站都在使用 HSTS，包括 Google 的 `google.com` 域名，但截至 2020 年，它还远未达到普及的程度。==

While HTTPS is primarily intended to help secure web browsing, it is sometimes used to secure other kinds of communications.
==虽然 HTTPS 的主要目的是为了帮助保护网页浏览的安全，但它有时也用于保护其他类型的通信。==

Some developers have leveraged HTTP for purposes rather different than standard web browsing, and, for them, using HTTPS to secure their communications is both natural and cheap.
==一些开发人员利用 HTTP 实现了与标准网页浏览截然不同的目的，对他们来说，使用 HTTPS 来保护通信既自然又廉价。==

However, you can only use HTTPS to secure your system if you commit to using HTTP as your application protocol, and HTTP was intended primarily to support a human-based activity.
==然而，只有当你承诺使用 HTTP 作为应用层协议时，才能使用 HTTPS 来保护系统，而 HTTP 最初主要是为了支持基于人类的行为而设计的。==

HTTP messages, for example, are typically encoded in ASCII and include substantial headers designed to support web browsing needs.
==例如，HTTP 消息通常以 ASCII 编码，并包含大量旨在支持网页浏览需求的头部信息。==

You may be able to achieve far greater efficiency of your application by using SSL, rather than HTTPS.
==通过直接使用 SSL 而不是 HTTPS，你可能会让应用程序获得更高的效率。==

Or you can use SSH.
==或者，你可以使用 SSH。==

**SSH**
**SSH**

SSH stands for **Secure Shell** which accurately describes the original purpose of the program.
==SSH 代表**安全外壳**（Secure Shell），这准确地描述了该程序的最初用途。==

SSH is available on Linux and other Unix systems, and to some extent on Windows systems.
==SSH 可用于 Linux 和其他 Unix 系统，在某种程度上也适用于 Windows 系统。==

SSH was envisioned as a secure remote shell, but it has been developed into a more general tool for allowing secure interactions between computers.
==SSH 最初被设想为一个安全的远程外壳，但后来它被发展成一个更通用的工具，用于允许计算机之间进行安全的交互。==

Most commonly this shell is used for command line interfaces, but SSH can support many other forms of secure remote interactions.
==最常见的情况是，这个外壳用于命令行界面，但 SSH 也可以支持许多其他形式的安全远程交互。==

For example, it can be used to protect remote X Windows sessions.
==例如，它可以用来保护远程 X Windows 会话。==

Generally, TCP ports can be forwarded through SSH, providing a powerful method to protect interactions between remote systems.
==通常，TCP 端口可以通过 SSH 进行转发，从而提供一种强大的方法来保护远程系统之间的交互。==

SSH addresses many of the same problems seen by SSL, often in similar ways.
==SSH 解决了许多与 SSL 相同的问题，而且通常采用类似的方法。==

Remote users must be authenticated, shared encryption keys must be established, integrity must be checked, and so on.
==远程用户必须经过身份验证，必须建立共享加密密钥，必须检查完整性，等等。==

SSH typically relies on public key cryptography and certificates to authenticate remote servers.
==SSH 通常依靠公钥加密和证书来对远程服务器进行身份验证。==

Clients frequently do not have their own certificates and private keys, in which case providing a user ID and password is permitted.
==客户端通常没有自己的证书和私私钥，在这种情况下，允许提供用户 ID 和密码。==

SSH supports other options for authentication not based on certificates or passwords, such as the use of authentication servers (such as Kerberos).
==SSH 支持不基于证书或密码的其他身份验证选项，例如使用身份验证服务器（如 Kerberos）。==

Various ciphers (both for authentication and for symmetric encryption) are supported, and some form of negotiation is required between the client and the server to choose a suitable set.
==SSH 支持各种加密算法（用于身份验证和对称加密），并且客户端和服务器之间需要进行某种形式的协商，以选择一套合适的方案。==

A typical use of SSH provides a good example of a common general kind of network security vulnerability called a **man-in-the-middle attack**.
==SSH 的一个典型应用提供了一个常见的通用网络安全漏洞示例，称为**中间人攻击**（man-in-the-middle attack）。==

This kind of attack occurs when two parties think they are communicating directly, but actually are communicating through a malicious third party without knowing it.
==这种攻击发生在两个当事方认为他们正在直接通信，但实际上是在不知情的情况下通过一个恶意第三方进行通信时。==

That third party sees all of the messages passed between them, and can alter such messages or inject new messages without their knowledge.
==该第三方可以看到在他们之间传递的所有消息，并且可以在他们不知情的情况下修改这些消息或注入新消息。==

Well-designed network security tools are immune to man-in-the-middle attacks of many types, but even a good tool like SSH can sometimes be subject to them.
==设计良好的网络安全工具对多种类型的中间人攻击具有免疫力，但即使是像 SSH 这样优秀的工具，有时也可能遭受此类攻击。==

If you use SSH much, you might have encountered an example yourself.
==如果你经常使用 SSH，你可能自己就遇到过一个例子。==

When you first use SSH to log into a remote machine you’ve never logged into before, you probably don’t have the public key associated with that remote machine.
==当你第一次使用 SSH 登录一台以前从未登录过的远程机器时，你可能没有与该远程机器关联的公钥。==

How do you get it?
==你如何得到它？==

Often, not through a certificate or any other secure means, but simply by asking the remote site to send it to you.
==通常不是通过证书或任何其他安全手段，而只是通过请求远程站点将其发送给你。==

Then you have its public key and away you go, securely authenticating that machine and setting up encrypted communications.
==然后你就拥有了它的公钥，接着就可以对该机器进行安全认证并建立加密通信。==

But what if there’s a man in the middle when you first attempt to log into the remote machine?
==但是，当你第一次尝试登录远程机器时，如果中间有一个人（中间人）怎么办？==

In that case, when the remote machine sends you its public key, the man in the middle can discard the message containing the correct public key and substitute one containing his own public key.
==在这种情况下，当远程机器向你发送其公钥时，中间人可以丢弃包含正确公钥的消息，并替换为包含他自己公钥的消息。==

Now you think you have the public key for the remote server, but you actually have the public key of the man in the middle.
==现在你认为你拥有了远程服务器的公钥，但实际上你拥有的是中间人的公钥。==

That means the man in the middle can pose as the remote server and you’ll never be the wiser.
==这意味着中间人可以伪装成远程服务器，而你永远不会察觉。==

The folks who designed SSH were well aware of this problem, and if you ever do use SSH this way, up will pop a message warning you of the danger and asking if you want to go ahead despite the risk.
==SSH 的设计者们深知这个问题，如果你真的以这种方式使用 SSH，就会弹出一个消息，警告你存在危险，并询问你是否要在冒风险的情况下继续。==

Folk wisdom suggests that everyone always says “yes, go ahead” when they get this message, including network security professionals.
==民间智慧表明，每个人在收到这条消息时总是会说“是的，继续”，包括网络安全专业人员也是如此。==

For that matter, folk wisdom suggests that all messages warning a user of the possibility of insecure actions are always ignored, which should suggest to you just how much security benefit will arise from adding such confirmation messages to your system.
==就此而言，民间智慧还表明，所有警告用户可能存在不安全行为的消息总是被忽略，这应该会让你意识到在系统中添加此类确认消息能产生多少安全效益。==

SSH is not built on SSL, but is a separate implementation.
==SSH 不是构建在 SSL 之上的，而是一个独立的实现。==

As a result, the two approaches each have their own bugs, features, and uses.
==因此，这两种方法各有其自身的错误、特性和用途。==

A security flaw found in SSH will not necessarily have any impact on SSL, and vice versa.
==在 SSH 中发现的安全缺陷不一定会对 SSL 产生任何影响，反之亦然。==

**Summary**
==**总结**==

Distributed systems are critical to modern computing, but are difficult to secure.
==分布式系统对现代计算至关重要，但很难保证其安全性。==

The cornerstone of providing distributed system security tends to be ensuring that the insecure network connecting system components does not introduce new security problems.
==提供分布式系统安全性的基石往往是确保连接系统组件的不安全网络不会引入新的安全问题。==

Messages sent between the components are encrypted and authenticated, protecting their privacy and integrity, and offering exclusive access to the distributed service to the intended users.
==在组件之间发送的消息经过加密和身份验证，从而保护了它们的隐私性和完整性，并为预期用户提供对分布式服务的专享访问权限。==

Standard tools like SSL/TLS and public keys distributed through X.509 certificates are used to provide these security services.
==SSL/TLS 等标准工具以及通过 X.509 证书分发的公钥被用于提供这些安全服务。==

Passwords are often used to authenticate remote human users.
==密码通常用于对远程人类用户进行身份验证。==

Symmetric cryptography is used for transport of most data, since it is cheaper than asymmetric cryptography.
==对称加密用于大多数数据的传输，因为它比非对称加密更廉价。==

Often, symmetric keys are not shared by system participants before the communication starts, so the first step in the protocol is typically exchanging a symmetric key.
==通常，系统参与者在通信开始前不会共享对称密钥，因此协议的第一步通常是交换对称密钥。==

As discussed in previous chapters, key secrecy is critical in proper use of cryptography, so care is required in the key distribution process.
==正如前几章所述，密钥保密性在密码学的正确使用中至关重要，因此在密钥分发过程中需要格外小心。==

**Diffie-Hellman key exchange** is commonly used, but it still requires authentication to ensure that only the intended participants know the key.
==**Diffie-Hellman 密钥交换**是常用的方法，但它仍然需要身份验证，以确保只有预期的参与者知道密钥。==

As mentioned in earlier chapters, building your own cryptographic solutions is challenging and often leads to security failures.
==正如前几章提到的，构建自己的加密解决方案具有挑战性，并且经常导致安全故障。==

A variety of tools, including SSL/TLS, SSH, and HTTPS, have already tackled many of the challenging problems and made good progress in overcoming them.
==包括 SSL/TLS、SSH 和 HTTPS 在内的各种工具已经解决了许多具有挑战性的问题，并在克服这些问题方面取得了良好进展。==

These tools can be used to build other systems, avoiding many of the pitfalls of building cryptography from scratch.
==这些工具可以用来构建其他系统，从而避免了从头开始构建加密系统的许多陷阱。==

However, proper use of even the best security tools depends on an understanding of the tool’s purpose and limitations, so developing deeper knowledge of the way such tools can be integrated into one’s system is vital to using them to their best advantage.
==然而，即使是最好的安全工具，其正确使用也取决于对工具用途和局限性的理解，因此，深入了解此类工具如何集成到个人系统中的知识，对于发挥其最大优势至关重要。==

Remember that these tools only make limited security guarantees.
==请记住，这些工具仅提供有限的安全保证。==

They do not provide the same assurance that an operating system gets when it performs actions locally on hardware under its direct control.
==它们无法提供像操作系统在受其直接控制的硬件上本地执行操作时所获得的那种保证。==

Thus, even when using good authentication and encryption tools properly, a system designer is well advised to think carefully about the implications of performing actions requested by a remote site, or providing sensitive information to that site.
==因此，即使正确使用了良好的身份验证和加密工具，系统设计者最好也要仔细考虑执行远程站点请求的操作或向该站点提供敏感信息的后果。==

What happens beyond the boundary of the machine the OS controls is always uncertain and thus risky.
==在操作系统控制的机器边界之外发生的事情总是具有不确定性，因此也充满风险。==

**A Dialogue on Virtual Machine Monitors**
==**关于虚拟机监控器的对话**==

Student: So now we’re stuck in the Appendix, huh?
==学生：所以我们现在被困在附录里了，是吗？==

Professor: Yes, just when you thought things couldn’t get any worse.
==教授：是的，就在你认为情况不会变得更糟的时候。==

Student: Well, what are we going to talk about?
==学生：好吧，我们要谈论什么？==

Professor: An old topic that has been reborn: **virtual machine monitors**, also known as **hypervisors**.
==教授：一个重获新生的老话题：**虚拟机监控器**（virtual machine monitors），也被称为**管理程序**（hypervisors）。==

Student: Oh, like VMware? That’s cool; I’ve used that kind of software before.
==学生：噢，就像 VMware 那样吗？那很酷；我以前用过那种软件。==

Professor: Cool indeed. We’ll learn how VMMs add yet another layer of virtualization into systems, this one beneath the OS itself! Crazy and amazing stuff, really.
==教授：确实很酷。我们将学习 VMM 如何在系统中增加另一层虚拟化，而这一层就在操作系统本身之下！真的是既疯狂又神奇的东西。==

Student: Sounds neat. Why not include this in the earlier part of the book, then, on virtualization? Shouldn’t it really go there?
==学生：听起来很棒。那为什么不把这部分放在书的前面关于虚拟化的部分呢？它难道不应该放在那里吗？==

Professor: That’s above our pay grade, I’m afraid. But my guess is this: there is already a lot of material there.
==教授：恐怕那超出了我们的职权范围。但我的猜测是：那里已经有很多材料了。==

By moving this small aside on VMMs into the appendix, a particular instructor can choose whether to include it or skip it.
==通过将关于 VMM 的这段简短插叙移到附录中，特定的教师可以自行选择是包含它还是跳过它。==

But I do think it should be included, because if you can understand how VMMs work, then you really understand virtualization quite well.
==但我确实认为它应该被包含进去，因为如果你能理解 VMM 的工作原理，那么你就真正很好地理解了虚拟化。==

Student: Alright then, let’s get to work!
==学生：那好吧，让我们开始工作吧！==

**Virtual Machine Monitors**
==**虚拟机监控器**==

**B.1 Introduction**
==**B.1 引言**==

Years ago, IBM sold expensive mainframes to large organizations, and a problem arose: what if the organization wanted to run different operating systems on the machine at the same time?
==多年前，IBM 向大型机构出售昂贵的大型机，随后出现了一个问题：如果该机构想在同一台机器上同时运行不同的操作系统怎么办？==

Some applications had been developed on one OS, and some on others, and thus the problem.
==有些应用程序是在一个操作系统上开发的，有些是在其他系统上开发的，问题由此产生。==

As a solution, IBM introduced yet another level of indirection in the form of a **virtual machine monitor (VMM)** (also called a **hypervisor**) [G74].
==作为解决方案，IBM 引入了另一种形式的间接层，即**虚拟机监控器 (VMM)**（也称为**管理程序**）[G74]。==

Specifically, the monitor sits between one or more operating systems and the hardware and gives the illusion to each running OS that it controls the machine.
==具体来说，监控器位于一个或多个操作系统与硬件之间，并给每个运行中的操作系统一种它控制着机器的错觉。==

Behind the scenes, however, the monitor actually is in control of the hardware, and must multiplex running OSes across the physical resources of the machine.
==然而，在幕后，监控器实际上控制着硬件，并且必须在机器的物理资源上多路复用运行中的操作系统。==

Indeed, the VMM serves as an operating system for operating systems, but at a much lower level; the OS must still think it is interacting with the physical hardware.
==事实上，VMM 充当了操作系统的操作系统，但处于更低的层级；操作系统必须仍然认为它正在与物理硬件进行交互。==

Thus, **transparency** is a major goal of VMMs.
==因此，**透明性**是 VMM 的一个主要目标。==

Thus, we find ourselves in a funny position: the OS has thus far served as the master illusionist, tricking unsuspecting applications into thinking they have their own private CPU and a large virtual memory, while secretly switching between applications and sharing memory as well.
==因此，我们发现自己处于一个滑稽的境地：到目前为止，操作系统一直充当着首席幻术师，欺骗那些毫无戒心的应用程序，让它们以为自己拥有私有的 CPU 和巨大的虚拟内存，而实际上却在秘密地在应用程序之间进行切换并共享内存。==

Now, we have to do it again, but this time underneath the OS, who is used to being in charge.
==现在，我们要再来一次，但这次是在习惯于发号施令的操作系统之下。==

How can the VMM create this illusion for each OS running on top of it?
==VMM 如何为运行在其上的每个操作系统创造这种错觉？==

**THE CRUX: HOW TO VIRTUALIZE THE MACHINE UNDERNEATH THE OS**
==**关键点：如何在操作系统之下实现机器虚拟化**==

The virtual machine monitor must transparently virtualize the machine underneath the OS; what are the techniques required to do so?
==虚拟机监控器必须透明地虚拟化操作系统之下的机器；实现这一目标需要哪些技术？==

**B.2 Motivation: Why VMMs?**
==**B.2 动机：为什么需要 VMM？**==

Today, VMMs have become popular again for a multitude of reasons.
==今天，由于多种原因，VMM 再次流行起来。==

**Server consolidation** is one such reason.
==**服务器整合**就是原因之一。==

In many settings, people run services on different machines which run different operating systems (or even OS versions), and yet each machine is lightly utilized.
==在许多环境下，人们在不同的机器上运行服务，这些机器运行着不同的操作系统（甚至不同的操作系统版本），但每台机器的利用率都很低。==

In this case, virtualization enables an administrator to **consolidate** multiple OSes onto fewer hardware platforms, and thus lower costs and ease administration.
==在这种情况下，虚拟化使管理员能够将多个操作系统**整合**到更少的硬件平台上，从而降低成本并简化管理。==

Virtualization has also become popular on desktops, as many users wish to run one operating system (say Linux or Mac OS X) but still have access to native applications on a different platform (say Windows).
==虚拟化在桌面端也变得流行起来，因为许多用户希望运行一个操作系统（比如 Linux 或 Mac OS X），但仍然能够访问另一个平台（比如 Windows）上的原生应用程序。==

This type of improvement in **functionality** is also a good reason.
==这种**功能性**方面的改进也是一个很好的理由。==

Another reason is testing and debugging.
==另一个原因是测试和调试。==

While developers write code on one main platform, they often want to debug and test it on the many different platforms that they deploy the software to in the field.
==虽然开发人员在一个主平台上编写代码，但他们通常希望在将来部署软件的许多不同平台上进行调试和测试。==

Thus, virtualization makes it easy to do so, by enabling a developer to run many operating system types and versions on just one machine.
==因此，虚拟化通过使开发人员能够在仅一台机器上运行许多操作系统类型和版本，从而轻松实现了这一点。==

This resurgence in virtualization began in earnest the mid-to-late 1990’s, and was led by a group of researchers at Stanford headed by Professor Mendel Rosenblum.
==这场虚拟化的复兴始于 20 世纪 90 年代中后期，由斯坦福大学教授 Mendel Rosenblum 领导的一组研究人员发起。==

His group’s work on Disco [B+97], a virtual machine monitor for the MIPS processor, was an early effort that revived VMMs and eventually led that group to the founding of VMware [V98], now a market leader in virtualization technology.
==他的小组在 Disco [B+97]（一个针对 MIPS 处理器的虚拟机监控器）上的工作是复兴 VMM 的早期尝试，并最终促使该小组创立了 VMware [V98]，该公司现在是虚拟化技术的市场领导者。==

In this chapter, we will discuss the primary technology underlying Disco and through that window try to understand how virtualization works.
==在本章中，我们将讨论 Disco 背后的主要技术，并通过这个窗口尝试了解虚拟化是如何工作的。==

**B.3 Virtualizing the CPU**
==**B.3 CPU 虚拟化**==

To run a **virtual machine** (e.g., an OS and its applications) on top of a virtual machine monitor, the basic technique that is used is **limited direct execution**, a technique we saw before when discussing how the OS virtualizes the CPU.
==要在虚拟机监控器上运行**虚拟机**（例如，操作系统及其应用程序），使用的基本技术是**受限直接执行**（limited direct execution），这是我们之前在讨论操作系统如何虚拟化 CPU 时见过的技术。==

Thus, when we wish to “boot” a new OS on top of the VMM, we simply jump to the address of the first instruction and let the OS begin running.
==因此，当我们希望在 VMM 上“启动”一个新操作系统时，我们只需跳转到第一条指令的地址，让操作系统开始运行即可。==

It is as simple as that (well, almost).
==就是这么简单（好吧，几乎如此）。==

Assume we are running on a single processor, and that we wish to multiplex between two virtual machines, that is, between two OSes and their respective applications.
==假设我们运行在单处理器上，并且希望在两个虚拟机之间进行多路复用，即在两个操作系统及其各自的应用程序之间进行切换。==

In a manner quite similar to an operating system switching between running processes (a **context switch**), a virtual machine monitor must perform a **machine switch** between running virtual machines.
==以一种与操作系统在运行进程之间切换（**上下文切换**）非常相似的方式，虚拟机监控器必须在运行中的虚拟机之间执行**机器切换**。==

Thus, when performing such a switch, the VMM must save the entire machine state of one OS (including registers, PC, and unlike in a context switch, any privileged hardware state), restore the machine state of the to-be-run VM, and then jump to the PC of the to-be-run VM and thus complete the switch.
==因此，在执行此类切换时，VMM 必须保存一个操作系统的整个机器状态（包括寄存器、PC，并且与上下文切换不同，还包括任何特权硬件状态），恢复待运行虚拟机的机器状态，然后跳转到待运行虚拟机的 PC，从而完成切换。==

Note that the to-be-run VM’s PC may be within the OS itself (i.e., the system was executing a system call) or it may simply be within a process that is running on that OS (i.e., a user-mode application).
==请注意，待运行虚拟机的 PC 可能位于操作系统本身内部（即系统正在执行系统调用），或者可能只是位于该操作系统上运行的一个进程中（即用户模式应用程序）。==

We get into some slightly trickier issues when a running application or OS tries to perform some kind of **privileged operation**.
==当正在运行的应用程序或操作系统尝试执行某种**特权操作**时，我们会遇到一些稍微棘手的问题。==

For example, on a system with a software-managed TLB, the OS will use special privileged instructions to update the TLB with a translation before restarting an instruction that suffered a TLB miss.
==例如，在具有软件管理 TLB 的系统上，操作系统将使用特殊的特权指令，在重新启动发生 TLB 未命中的指令之前，使用转换后的地址更新 TLB。==

In a virtualized environment, the OS cannot be allowed to perform privileged instructions, because then it controls the machine rather than the VMM beneath it.
==在虚拟化环境中，不能允许操作系统执行特权指令，因为这样它就控制了机器，而不是其下的 VMM。==

Thus, the VMM must somehow intercept attempts to perform privileged operations and thus retain control of the machine.
==因此，VMM 必须以某种方式拦截执行特权操作的尝试，从而保持对机器的控制。==

A simple example of how a VMM must interpose on certain operations arises when a running process on a given OS tries to make a system call.
==当给定操作系统上的运行进程尝试进行系统调用时，就会出现 VMM 必须干预某些操作的简单例子。==

For example, the process may be trying to call `open()` on a file, or may be calling `read()` to get data from it, or may be calling `fork()` to create a new process.
==例如，进程可能正尝试对文件调用 `open()`，或者可能正在调用 `read()` 以从中获取数据，或者可能正在调用 `fork()` 以创建一个新进程。==

In a system without virtualization, a system call is achieved with a special instruction; on MIPS, it is a **trap** instruction, and on x86, it is the `int` (an interrupt) instruction with the argument `0x80`.
==在没有虚拟化的系统中，系统调用是通过一条特殊指令实现的；在 MIPS 上，它是一条**陷阱**（trap）指令，在 x86 上，它是带有参数 `0x80` 的 `int`（中断）指令。==

Here is the `open` library call on FreeBSD [B00] (recall that your C code first makes a library call into the C library, which then executes the proper assembly sequence to actually issue the trap instruction and make a system call):
==这是 FreeBSD [B00] 上的 `open` 库调用（回想一下，你的 C 代码首先调用 C 库，然后 C 库执行适当的汇编序列，以实际发出陷阱指令并进行系统调用）：==

```assembly
open:
    push dword mode
    push dword flags
    push dword path
    mov eax, 5
    push eax
    int 80h
```

On UNIX-based systems, `open()` takes just three arguments: `int open(char *path, int flags, mode_t mode)`.
==在基于 UNIX 的系统上，`open()` 仅需三个参数：`int open(char *path, int flags, mode_t mode)`。==

You can see in the code above how the `open()` library call is implemented: first, the arguments get pushed onto the stack (`mode`, `flags`, `path`), then a `5` gets pushed onto the stack, and then `int 80h` is called, which transfers control to the kernel.
==你可以在上面的代码中看到 `open()` 库调用是如何实现的：首先，参数被压入栈中（`mode`、`flags`、`path`），然后将 `5` 压入栈中，接着调用 `int 80h`，这会将控制权转移给内核。==

The `5`, if you were wondering, is the pre-agreed upon convention between user-mode applications and the kernel for the `open()` system call in FreeBSD; different system calls would place different numbers onto the stack (in the same position) before calling the trap instruction `int` and thus making the system call.
==如果你感到好奇，这里的 `5` 是 FreeBSD 中用户模式应用程序与内核之间针对 `open()` 系统调用预先约定的规范；不同的系统调用在调用陷阱指令 `int` 并进行系统调用之前，会将不同的数字放置在栈的同一位置。==

When a trap instruction is executed, as we’ve discussed before, it usually does a number of interesting things.
==正如我们之前讨论过的，当执行陷阱指令时，它通常会做一些有趣的事情。==

Most important in our example here is that it first transfers control (i.e., changes the PC) to a well-defined **trap handler** within the operating system.
==在我们这里的例子中，最重要的一点是它首先将控制权转移（即更改 PC）到操作系统中定义的**陷阱处理程序**（trap handler）。==

The OS, when it is first starting up, establishes the address of such a routine with the hardware (also a privileged operation) and thus upon subsequent traps, the hardware knows where to start running code to handle the trap.
==操作系统在最初启动时，向硬件登记此类例程的地址（这也是一种特权操作），因此在随后的陷阱发生时，硬件知道从哪里开始运行代码来处理陷阱。==

At the same time of the trap, the hardware also does one other crucial thing: it changes the mode of the processor from **user mode** to **kernel mode**.
==在发生陷阱的同时，硬件还做了另一件至关重要的事：它将处理器的模式从**用户模式**更改为**内核模式**。==

In user mode, operations are restricted, and attempts to perform privileged operations will lead to a trap and likely the termination of the offending process; in kernel mode, on the other hand, the full power of the machine is available, and thus all privileged operations can be executed.
==在用户模式下，操作受到限制，尝试执行特权操作将导致陷阱，并可能终止违规进程；另一方面，在内核模式下，可以使用机器的所有功能，因此可以执行所有特权操作。==

Thus, in a traditional setting (again, without virtualization), the flow of control would be like what you see in Figure B.1.
==因此，在传统环境下（同样是没有虚拟化），控制流将如图 B.1 所示。==

On a virtualized platform, things are a little more interesting.
==在虚拟化平台上，情况变得更有趣一些。==

When an application running on an OS wishes to perform a system call, it does the exact same thing: executes a trap instruction with the arguments carefully placed on the stack (or in registers).
==当运行在操作系统上的应用程序希望执行系统调用时，它会执行完全相同的操作：执行陷阱指令，并将参数仔细地放置在栈中（或寄存器中）。==

However, it is the VMM that controls the machine, and thus the VMM who has installed a trap handler that will first get executed in kernel mode.
==然而，由于是 VMM 控制着机器，因此是 VMM 安装的陷阱处理程序将首先在内核模式下执行。==

So what should the VMM do to handle this system call?
==那么，VMM 应该如何处理这个系统调用呢？==

The VMM doesn’t really know **how** to handle the call; after all, it does not know the details of each OS that is running and therefore does not know what each call should do.
==VMM 实际上并不知道**如何**处理该调用；毕竟，它不知道每个正在运行的操作系统的细节，因此也就不知道每个调用应该做什么。==

What the VMM does know, however, is **where** the OS’s trap handler is.
==然而，VMM 确实知道操作系统的陷阱处理程序在**哪里**。==

It knows this because when the OS booted up, it tried to install its own trap handlers; when the OS did so, it was trying to do something privileged, and therefore trapped into the VMM; at that time, the VMM recorded the necessary information (i.e., where this OS’s trap handlers are in memory).
==它知道这一点是因为当操作系统启动时，它尝试安装自己的陷阱处理程序；当操作系统这样做时，它正在尝试执行特权操作，因此陷入了 VMM；那时，VMM 记录了必要的信息（即该操作系统的陷阱处理程序在内存中的位置）。==

Now, when the VMM receives a trap from a user process running on the given OS, it knows exactly what to do: it jumps to the OS’s trap handler and lets the OS handle the system call as it should.
==现在，当 VMM 接收到来自运行在给定操作系统上的用户进程的陷阱时，它确切地知道该怎么做：它跳转到该操作系统的陷阱处理程序，让操作系统按其应有的方式处理系统调用。==

When the OS is finished, it executes some kind of privileged instruction to return from the trap (`rett` on MIPS, `iret` on x86), which again bounces into the VMM, which then realizes that the OS is trying to return from the trap and thus performs a real return-from-trap and thus returns control to the user and puts the machine back in user mode.
==当操作系统完成处理后，它会执行某种特权指令以从陷阱返回（MIPS 上为 `rett`，x86 上为 `iret`），这再次弹回到 VMM 中，VMM 随后意识到操作系统正尝试从陷阱返回，从而执行真正的“从陷阱返回”操作，进而将控制权返回给用户并将机器重新置于用户模式。==

The entire process is depicted in Figures B.2 and B.3, both for the normal case without virtualization and the case with virtualization.
==整个过程在图 B.2 和 B.3 中进行了描述，分别针对没有虚拟化的正常情况和有虚拟化的情况。==

As you can see from the figures, a lot more has to take place when virtualization is going on.
==正如你从图中看到的，在进行虚拟化时，必须发生更多的事情。==

Certainly, because of the extra jumping around, virtualization might indeed slow down system calls and thus could hurt performance.
==当然，由于额外的跳转，虚拟化确实可能会减慢系统调用速度，从而可能损害性能。==

You might also notice that we have one remaining question: what mode should the OS run in?
==你可能还会注意到，我们还有一个遗留问题：操作系统应该在什么模式下运行？==

It can’t run in kernel mode, because then it would have unrestricted access to the hardware.
==它不能在内核模式下运行，因为那样它将拥有对硬件的无限制访问权限。==

Thus, it must run in some less privileged mode than before, be able to access its own data structures, and simultaneously prevent access to its data structures from user processes.
==因此，它必须在比以前特权更低的某种模式下运行，既能访问自己的数据结构，同时又要防止用户进程访问其数据结构。==

In the Disco work, Rosenblum and colleagues handled this problem quite neatly by taking advantage of a special mode provided by the MIPS hardware known as **supervisor mode**.
==在 Disco 的工作中，Rosenblum 及其同事利用 MIPS 硬件提供的一种称为**主管模式**（supervisor mode）的特殊模式，非常巧妙地处理了这个问题。==

When running in this mode, one still doesn’t have access to privileged instructions, but one can access a little more memory than when in user mode; the OS can use this extra memory for its data structures and all is well.
==在这种模式下运行时，虽然仍然无法访问特权指令，但可以访问比用户模式稍多一点的内存；操作系统可以将这些额外的内存用于其数据结构，一切进展顺利。==

On hardware that doesn’t have such a mode, one has to run the OS in user mode and use memory protection (page tables and TLBs) to protect OS data structures appropriately.
==在没有这种模式的硬件上，必须在用户模式下运行操作系统，并使用内存保护（页表和 TLB）来适当地保护操作系统数据结构。==

In other words, when switching into the OS, the monitor would have to make the memory of the OS data structures available to the OS via page-table protections; when switching back to the running application, the ability to read and write the kernel would have to be removed.
==换句话说，当切换到操作系统时，监控器必须通过页表保护使操作系统的内存数据结构对操作系统可用；当切换回运行中的应用程序时，必须移除读取和写入内核的能力。==

**B.4 Virtualizing Memory**
==**B.4 内存虚拟化**==

You should now have a basic idea of how the processor is virtualized: the VMM acts like an OS and schedules different virtual machines to run, and some interesting interactions occur when privilege levels change.
==你现在应该对处理器是如何虚拟化的有了基本了解：VMM 表现得像一个操作系统，调度不同的虚拟机运行，并且在特权级别改变时会发生一些有趣的交互。==

But we have left out a big part of the equation: how does the VMM virtualize memory?
==但我们遗漏了方程中的一个重要部分：VMM 如何虚拟化内存？==

Each OS normally thinks of physical memory as a linear array of pages, and assigns each page to itself or user processes.
==每个操作系统通常将物理内存视为线性的页面数组，并将每个页面分配给自身或用户进程。==

The OS itself, of course, already virtualizes memory for its running processes, such that each process has the illusion of its own private address space.
==当然，操作系统本身已经为其运行中的进程虚拟化了内存，使得每个进程都拥有自己私有地址空间的错觉。==

Now we must add another layer of virtualization, so that multiple OSes can share the actual physical memory of the machine, and we must do so transparently.
==现在我们必须增加另一层虚拟化，以便多个操作系统可以共享机器的实际物理内存，并且我们必须透明地做到这一点。==

This extra layer of virtualization makes “physical” memory a virtualization on top of what the VMM refers to as **machine memory**, which is the real physical memory of the system.
==这额外的一层虚拟化使得“物理”内存成为构建在 VMM 所称的**机器内存**（machine memory）之上的虚拟化，而机器内存才是系统的真实物理内存。==

Thus, we now have an additional layer of indirection: each OS maps virtual-to-physical addresses via its per-process page tables; the VMM maps the resulting physical mappings to underlying machine addresses via its per-OS page tables.
==因此，我们现在有了一个额外的间接层：每个操作系统通过其每个进程的页表将虚拟地址映射到物理地址；VMM 通过其每个操作系统的页表将产生的物理映射映射到底层的机器地址。==

Figure B.4 depicts this extra level of indirection.
==图 B.4 描绘了这一额外的间接层。==

In the figure, there is just a single virtual address space with four pages, three of which are valid (0, 2, and 3).
==在图中，只有一个拥有四个页面的虚拟地址空间，其中三个页面是有效的（0、2 和 3）。==

The OS uses its page table to map these pages to three underlying physical frames (10, 3, and 8, respectively).
==操作系统使用其页表将这些页面映射到三个底层的物理页框（分别是 10、3 和 8）。==

Underneath the OS, the VMM performs a further level of indirection, mapping PFNs 3, 8, and 10 to machine frames 6, 10, and 5 respectively.
==在操作系统之下，VMM 执行了进一步的间接映射，分别将物理页框号（PFN）3、8 和 10 映射到机器页框 6、10 和 5。==

To understand how this works a little better, let’s recall how **address translation** works in a modern paged system.
==为了更好地理解这是如何工作的，让我们回顾一下在现代分页系统中**地址转换**是如何工作的。==

Specifically, let’s discuss what happens on a system with a software-managed TLB during address translation.
==具体来说，让我们讨论在具有软件管理 TLB 的系统上，地址转换期间会发生什么。==

Assume a user process generates an address; by definition, the process generates a **virtual address**, as its address space has been virtualized by the OS.
==假设一个用户进程生成了一个地址；根据定义，该进程生成的是一个**虚拟地址**，因为其地址空间已被操作系统虚拟化。==

As you know by now, it is the role of the OS, with help from the hardware, to turn this into a **physical address** and thus be able to fetch the desired contents from physical memory.
==正如你现在所知道的，操作系统的角色是在硬件的帮助下，将其转换为**物理地址**，从而能够从物理内存中获取所需的内容。==

Assume we have a 32-bit virtual address space and a 4-KB page size.
==假设我们有一个 32 位虚拟地址空间和 4-KB 的页面大小。==

Thus, our 32-bit address is chopped into two parts: a 20-bit virtual page number (VPN), and a 12-bit offset.
==因此，我们的 32 位地址被切分为两部分：20 位的虚拟页号（VPN）和 12 位的偏移量。==

The role of the OS, with help from the hardware TLB, is to translate the VPN into a valid physical page frame number (PFN) and thus produce a fully-formed physical address which can be sent to physical memory to fetch the proper data.
==操作系统的角色是在硬件 TLB 的帮助下，将 VPN 转换为有效的物理页框号（PFN），从而生成一个完整的物理地址，该地址可以发送到物理内存以获取正确的数据。==

In the common case, we expect the TLB to handle the translation in hardware, thus making the translation fast.
==在通常情况下，我们希望 TLB 在硬件中处理转换，从而使转换速度更快。==

When a TLB miss occurs (at least, on a system with a software-managed TLB), the OS must get involved to service the miss, as depicted here in Figure B.5.
==当发生 TLB 未命中时（至少在具有软件管理 TLB 的系统上），操作系统必须介入以处理该未命中，如图 B.5 所示。==

As you can see, a TLB miss causes a trap into the OS, which handles the fault by looking up the VPN in the page table and installing the translation in the TLB.
==如你所见，TLB 未命中会导致陷入操作系统，操作系统通过在页表中查找 VPN 并将转换后的映射安装到 TLB 中来处理该故障。==

With a virtual machine monitor underneath the OS, however, things again get a little more interesting.
==然而，在操作系统下方有了虚拟机监控器后，情况再次变得更有趣了。==

When a process makes a virtual memory reference and misses in the TLB, it is not the OS TLB miss handler that runs; rather, it is the VMM TLB miss handler, as the VMM is the true privileged owner of the machine.
==当一个进程进行虚拟内存引用并在 TLB 中未命中时，运行的不是操作系统的 TLB 未命中处理程序；相反，是 VMM 的 TLB 未命中处理程序在运行，因为 VMM 才是机器真正的特权所有者。==

However, in the normal case, the VMM TLB handler doesn’t know how to handle the TLB miss, so it immediately jumps into the OS TLB miss handler; the VMM knows the location of this handler because the OS, during “boot”, tried to install its own trap handlers.
==然而，在正常情况下，VMM TLB 处理程序不知道如何处理 TLB 未命中，因此它立即跳转到操作系统的 TLB 未命中处理程序中；VMM 知道此处理程序的位置，因为操作系统在“启动”期间尝试安装了自己的陷阱处理程序。==

The OS TLB miss handler then runs, does a page table lookup for the VPN in question, and tries to install the VPN-to-PFN mapping in the TLB.
==操作系统的 TLB 未命中处理程序随后运行，对相关的 VPN 进行页表查找，并尝试在 TLB 中安装 VPN 到 PFN 的映射。==

However, doing so is a privileged operation, and thus causes another trap into the VMM.
==然而，这样做是一项特权操作，因此会导致再次陷入 VMM。==

At this point, the VMM plays its trick: instead of installing the OS’s VPN-to-PFN mapping, the VMM installs its desired VPN-to-MFN mapping.
==此时，VMM 耍了一个花招：它不安装操作系统的 VPN 到 PFN 映射，而是安装它所期望的 VPN 到 MFN（机器页框号）映射。==

After doing so, the system eventually gets back to the user-level code, which retries the instruction, and results in a TLB hit, fetching the data from the machine frame where the data resides.
==执行完此操作后，系统最终会返回到用户级代码，该代码会重试指令，并导致 TLB 命中，从而从数据所在的机器页框中获取数据。==

**ASIDE: PARA-VIRTUALIZATION**
==**插叙：半虚拟化**==

In many situations, it is good to assume that the OS cannot be modified in order to work better with virtual machine monitors.
==在许多情况下，最好假设操作系统不能被修改，以便更好地与虚拟机监控器协作。==

However, this is not always the case, and when the OS can be modified, it may run more efficiently on top of a VMM.
==然而，情况并非总是如此，当操作系统可以被修改时，它在 VMM 上运行的效率可能会更高。==

Running a modified OS to run on a VMM is generally called **para-virtualization** [WSG02], as the virtualization provided by the VMM isn’t a complete one, but rather a partial one requiring OS changes to operate effectively.
==为了在 VMM 上运行而运行经过修改的操作系统，通常被称为**半虚拟化**（para-virtualization）[WSG02]，因为 VMM 提供的虚拟化不是完全的虚拟化，而是需要修改操作系统才能有效运行的部分虚拟化。==

Research shows that a properly-designed para-virtualized system, with just the right OS changes, can be made to be nearly as efficient a system without a VMM [BD+03].
==研究表明，通过恰当的操作系统修改，一个设计良好的半虚拟化系统可以变得几乎与没有 VMM 的系统一样高效 [BD+03]。==

**B.5 The Information Gap**
==**B.5 信息鸿沟**==

Just like the OS doesn’t know too much about what application programs really want, the VMM often doesn’t know too much about what the OS is doing or wanting.
==就像操作系统不太了解应用程序真正想要什么一样，VMM 往往也不太了解操作系统正在做什么或想要什么。==

This lack of knowledge, sometimes called the **information gap** between the VMM and the OS, can lead to various inefficiencies [B+97].
==这种知识的匮乏，有时被称为 VMM 与操作系统之间的**信息鸿沟**（information gap），可能会导致各种效率低下 [B+97]。==

For example, an OS, when it has nothing else to run, will sometimes go into an **idle loop** just spinning and waiting for the next interrupt to occur:
==例如，一个操作系统在没有其他任务可运行时，有时会进入一个**空闲循环**（idle loop），只是在那里轮询并等待下一个中断的发生：==

```c
while (1)
    ; // the idle loop
```

It makes sense to spin like this if the OS is in charge of the entire machine and thus knows there is nothing else that needs to run.
==如果操作系统掌控着整台机器，并且知道没有其他任务需要运行，那么像这样轮询是有意义的。==

However, when a VMM is running underneath two different OSes, one in the idle loop and one usefully running user processes, it would be useful for the VMM to know that one OS is idle so it can give more CPU time to the OS doing useful work.
==然而，当 VMM 在两个不同的操作系统之下运行时，如果其中一个处于空闲循环，另一个正在有用地运行用户进程，那么让 VMM 知道其中一个操作系统处于空闲状态将非常有用，这样它就可以将更多的 CPU 时间分配给那个正在做有用工作的操作系统。==

Another example arises with **demand zeroing** of pages.
==另一个例子出现在页面的**请求置零**（demand zeroing）中。==

Most operating systems zero a physical frame before mapping it into a process’s address space.
==大多数操作系统在将物理页框映射到进程地址空间之前会将其置零。==

The reason for doing so is simple: security.
==这样做的主因很简单：安全。==

If the OS gave one process a page that another had been using without zeroing it, an information leak across processes could occur.
==如果操作系统将一个进程使用过的页面在不置零的情况下分配给另一个进程，可能会发生进程间的信息泄漏。==

Unfortunately, the VMM must zero pages that it gives to each OS, for the same reason, and thus many times a page will be zeroed twice.
==不幸的是，出于同样的原因，VMM 也必须将其交给每个操作系统的页面置零，因此很多时候一个页面会被置零两次。==

**B.6 Summary**
==**B.6 总结**==

Virtualization is in a renaissance.
==虚拟化正处于复兴时期。==

For a multitude of reasons, users and administrators want to run multiple OSes on the same machine at the same time.
==出于多种原因，用户和管理员希望在同一台机器上同时运行多个操作系统。==

The key is that VMMs generally provide this service **transparently**; the OS above has little clue that it is not actually controlling the hardware of the machine.
==关键在于 VMM 通常**透明地**提供这种服务；其上的操作系统几乎不知道自己实际上并没有控制机器的硬件。==

The key method that VMMs use to do so is to extend the notion of **limited direct execution**.
==VMM 实现这一目标的关键方法是扩展**受限直接执行**的概念。==

By setting up the hardware to enable the VMM to interpose on key events (such as traps), the VMM can completely control how machine resources are allocated while preserving the illusion that the OS requires.
==通过设置硬件以使 VMM 能够干预关键事件（如陷阱），VMM 可以完全控制机器资源的分配方式，同时保持操作系统所需的错觉。==

You might have noticed some similarities between what the OS does for processes and what the VMM does for OSes.
==你可能已经注意到操作系统为进程所做的与 VMM 为操作系统所做的之间有一些相似之处。==

They both virtualize the hardware after all, and hence do some of the same things.
==毕竟它们都对硬件进行了虚拟化，因此执行了一些相同的操作。==

However, there is one key difference: with the OS virtualization, a number of new abstractions and nice interfaces are provided; with VMM-level virtualization, the abstraction is identical to the hardware (and thus not very nice).
==然而，有一个关键的区别：通过操作系统虚拟化，提供了一系列新的抽象和友好的接口；而通过 VMM 级虚拟化，抽象与硬件完全一致（因此并不怎么友好）。==

**Monitors (Deprecated)**
==**管程（已弃用）**==

Around the time concurrent programming was becoming a big deal, object-oriented programming was also gaining ground.
==在大约并发编程变得重要的时候，面向对象编程也在取得进展。==

Not surprisingly, people started to think about ways to merge synchronization into a more structured programming environment.
==不出所料，人们开始思考将同步合并到更结构化的编程环境中的方法。==

One such approach that emerged was the **monitor**.
==其中一种出现的方法就是**管程**（monitor）。==

First described by Per Brinch Hansen [BH73] and later refined by Tony Hoare [H74], the idea behind a monitor is quite simple.
==管程的概念最早由 Per Brinch Hansen [BH73] 描述，后来由 Tony Hoare [H74] 完善，其背后的想法非常简单。==

Consider the following pretend monitor written in C++ notation:
==考虑以下用 C++ 符号编写的假想管程：==

```cpp
monitor class account {
private:
    int balance = 0;
public:
    void deposit(int amount) {
        balance = balance + amount;
    }
    void withdraw(int amount) {
        balance = balance - amount;
    }
};
```

Note: this is a “pretend” class because C++ does not support monitors, and hence the `monitor` keyword does not exist.
==注意：这是一个“假想”类，因为 C++ 不支持管程，因此不存在 `monitor` 关键字。==

However, Java does support monitors, with what are called **synchronized** methods.
==然而，Java 确实支持管程，它使用的是所谓的**同步**（synchronized）方法。==

In this example, you may notice we have our old friend the account and some routines to deposit and withdraw an amount from the balance.
==在这个例子中，你可能会注意到我们有老朋友“账户”，以及一些用于从余额中存款和取款的例程。==

As you also may notice, these are **critical sections**; if they are called by multiple threads concurrently, you have a race condition and the potential for an incorrect outcome.
==你可能也注意到了，这些是**临界区**；如果它们被多个线程并发调用，你就会遇到竞态条件，并可能产生错误的结果。==



MONITORS (DEPRECATED)
==管程（已弃用）==

In a monitor class, you don’t get into trouble, though, because the monitor guarantees that **only one thread can be active within the monitor at a time**.
==不过，在管程类中，你不会遇到麻烦，因为管程保证了**一次只能有一个线程在管程内活动**。==

Thus, our above example is a perfectly safe and working piece of code; multiple threads can call deposit() or withdraw() and know that mutual exclusion is preserved.
==因此，我们上面的例子是一个完全安全且有效的代码片段；多个线程可以调用 deposit() 或 withdraw()，并知道互斥性得到了维护。==

How does the monitor do this?
==管程是如何做到这一点的？==

Simple: with a lock.
==很简单：通过锁。==

Whenever a thread tries to call a monitor routine, it implicitly tries to acquire the monitor lock.
==每当线程尝试调用管程例程时，它都会隐式地尝试获取管程锁。==

If it succeeds, then it will be able to call into the routine and run the method’s code.
==如果成功，它将能够进入该例程并运行方法代码。==

If it does not, it will block until the thread that is in the monitor finishes what it is doing.
==如果不成功，它将阻塞，直到管程中的线程完成其操作。==

Thus, if we wrote a C++ class that looked like the following, it would accomplish the exact same goal as the monitor class above:
==因此，如果我们编写一个如下所示的 C++ 类，它将实现与上述管程类完全相同的目标：==

```cpp
class account {
private:
    int balance = 0;
    pthread_mutex_t monitor;

public:
    void deposit(int amount) {
        pthread_mutex_lock(&monitor);
        balance = balance + amount;
        pthread_mutex_unlock(&monitor);
    }
    void withdraw(int amount) {
        pthread_mutex_lock(&monitor);
        balance = balance - amount;
        pthread_mutex_unlock(&monitor);
    }
};
```

Figure D.2: A C++ Class that acts like a Monitor
==图 D.2：一个表现得像管程的 C++ 类==

Thus, as you can see from this example, the monitor isn’t doing too much for you automatically.
==因此，正如你从这个例子中看到的，管程并没有自动为你做太多事情。==

Basically, it is just acquiring a lock and releasing it.
==基本上，它只是获取锁并释放锁。==

By doing so, we achieve what the monitor requires: only one thread will be active within deposit() or withdraw(), as desired.
==通过这样做，我们实现了管程的要求：正如预期的那样，在 deposit() 或 withdraw() 中一次只会有一个活跃线程。==

D.1 Why Bother with Monitors?
==D.1 为什么要费心使用管程？==

You might wonder why monitors were invented at all, instead of just using explicit locking.
==你可能会奇怪为什么要发明管程，而不是直接使用显式锁。==

At the time, object-oriented programming was just coming into fashion.
==当时，面向对象编程正开始流行。==

Thus, the idea was to gracefully blend some of the key concepts in concurrent programming with some of the basic approaches of object orientation.
==因此，当时的初衷是将并发编程中的一些关键概念与面向对象的一些基本方法优雅地融合在一起。==

Nothing more than that.
==仅此而已。==

D.2 Do We Get More Than Automatic Locking?
==D.2 除了自动加锁，我们还能得到更多吗？==

```cpp
monitor class BoundedBuffer {
private:
    int buffer[MAX];
    int fill, use;
    int fullEntries = 0;
    cond_t empty;
    cond_t full;

public:
    void produce(int element) {
        if (fullEntries == MAX) // line P0
            wait(&empty);       // line P1
        buffer[fill] = element; // line P2
        fill = (fill + 1) % MAX; // line P3
        fullEntries++;          // line P4
        signal(&full);          // line P5
    }

    int consume() {
        if (fullEntries == 0)   // line C0
            wait(&full);        // line C1
        int tmp = buffer[use];  // line C2
        use = (use + 1) % MAX;  // line C3
        fullEntries--;          // line C4
        signal(&empty);         // line C5
        return tmp;             // line C6
    }
}
```

Figure D.3: Producer/Consumer with Monitors and Hoare Semantics
==图 D.3：使用管程和 Hoare 语义的生产者/消费者问题==

Back to business.
==言归正传。==

As we know from our discussion of semaphores, just having locks is not quite enough.
==正如我们从关于信号量的讨论中所知，仅仅有锁是不够的。==

For example, to implement the producer/consumer solution, we previously used semaphores to both put threads to sleep when waiting for a condition to change (e.g., a producer waiting for a buffer to be emptied), as well as to wake up a thread when a particular condition has changed (e.g., a consumer signaling that it has indeed emptied a buffer).
==例如，为了实现生产者/消费者解决方案，我们之前使用信号量来使等待条件改变的线程进入睡眠状态（例如，生产者等待缓冲区变空），并在特定条件发生改变时唤醒线程（例如，消费者发出信号表示它确实清空了一个缓冲区）。==

Monitors support such functionality through an explicit construct known as a **condition variable**.
==管程通过一种称为**条件变量**的显式结构来支持这种功能。==

Let’s take a look at the producer/consumer solution, here written with monitors and condition variables.
==让我们来看看生产者/消费者的解决方案，这里是用管程和条件变量编写的。==

In this monitor class, we have two routines, produce() and consume().
==在这个管程类中，我们有两个例程：produce() 和 consume()。==

A producer thread would repeatedly call produce() to put data into the bounded buffer, while a consumer() would repeatedly call consume().
==生产者线程会重复调用 produce() 将数据放入有界缓冲区，而消费者则会重复调用 consume()。==

The example is a modern paraphrase of Hoare’s solution [H74].
==该示例是对 Hoare 解决方案 [H74] 的现代改写。==

You should notice some similarities between this code and the semaphore-based solution in the previous note.
==你应该会注意到这段代码与前一篇笔记中基于信号量的解决方案之间的一些相似之处。==

One major difference is how condition variables must be used in concert with an explicit **state variable**.
==一个主要的区别是条件变量必须与显式的**状态变量**配合使用。==

In this case, the integer `fullEntries` determines whether a producer or consumer must wait, depending on its state.
==在这种情况下，整数 `fullEntries` 根据其状态决定生产者或消费者是否必须等待。==

Semaphores, in contrast, have an internal numeric value which serves this same purpose.
==相比之下，信号量具有一个起相同作用的内部数值。==

Thus, condition variables must be paired with some kind of external state value in order to achieve the same end.
==因此，条件变量必须与某种外部状态值配对，才能达到相同的目的。==

The most important aspect of this code, however, is the use of the two condition variables, empty and full, and the respective wait() and signal() calls that employ them.
==然而，这段代码最重要的方面是使用了两个条件变量 empty 和 full，以及使用它们的相应 wait() 和 signal() 调用。==

These operations do exactly what you might think: wait() blocks the calling thread on a given condition; signal() wakes one waiting thread that is waiting on the condition.
==这些操作正如你所想的那样：wait() 在给定条件下阻塞调用线程；signal() 唤醒一个在该条件下等待的线程。==

However, there are some subtleties in how these calls operate; understanding the semantics of these calls is critically important to understanding why this code works.
==然而，这些调用的运作方式存在一些细微差别；理解这些调用的语义对于理解这段代码为何有效至关重要。==

In what researchers in operating systems call **Hoare semantics** (yes, a somewhat unfortunate name), the signal() immediately wakes one waiting thread and runs it.
==在操作系统研究人员所谓的 **Hoare 语义**（是的，一个有点令人遗憾的名字）中，signal() 会立即唤醒一个等待线程并运行它。==

Thus, the monitor lock, which is implicitly held by the running thread, immediately is transferred to the woken thread which then runs until it either blocks or exits the monitor.
==因此，由正在运行的线程隐式持有的管程锁会立即转移到被唤醒的线程，然后该线程一直运行，直到它阻塞或退出管程。==

Note that there may be more than one thread waiting; signal() only wakes one waiting thread and runs it, while the others must wait for a subsequent signal.
==请注意，可能不止一个线程在等待；signal() 仅唤醒一个等待线程并运行它，而其他线程必须等待后续的信号。==

A simple example will help us understand this code better.
==一个简单的例子将帮助我们更好地理解这段代码。==

Imagine there are two threads, one a producer and the other a consumer.
==想象有两个线程，一个是生产者，另一个是消费者。==

The consumer gets to run first, and calls consume(), only to find that fullEntries = 0 (C0), as there is nothing in the buffer yet.
==消费者先运行并调用 consume()，结果发现 fullEntries = 0 (C0)，因为缓冲区中还没有任何东西。==

Thus, it calls wait(&full) (C1), and waits for a buffer to be filled.
==因此，它调用 wait(&full) (C1)，并等待缓冲区被填充。==

The producer then runs, finds it doesn’t have to wait (P0), puts an element into the buffer (P2), increments the fill index (P3) and the fullEntries count (P4), and calls signal(&full) (P5).
==然后生产者运行，发现它不需要等待 (P0)，将一个元素放入缓冲区 (P2)，增加填充索引 (P3) 和 fullEntries 计数 (P4)，并调用 signal(&full) (P5)。==

In Hoare semantics, the producer does not continue running after the signal; rather, the signal immediately transfers control to the waiting consumer, which returns from wait() (C1) and immediately consumes the element produced by the producer (C2) and so on.
==在 Hoare 语义中，生产者在发出信号后不会继续运行；相反，该信号立即将控制权转移给等待的消费者，消费者从 wait() (C1) 返回并立即消耗生产者生产的元素 (C2)，依此类推。==

Only after the consumer returns will the producer get to run again and return from the produce() routine.
==只有在消费者返回后，生产者才会再次运行并从 produce() 例程返回。==

D.3 Where Theory Meets Practice
==D.3 理论与实践的交汇点==

Tony Hoare, who wrote the solution above and came up with the exact semantics for signal() and wait(), was a theoretician.
==编写上述解决方案并提出 signal() 和 wait() 精确语义的 Tony Hoare 是一位理论家。==

Clearly a smart guy, too; he came up with quicksort after all [H61].
==显然他也是个聪明人；毕竟他发明了快速排序 [H61]。==

However, the semantics of signaling and waiting, as it turns out, were not ideal for a real implementation.
==然而，事实证明，信号通知（signaling）和等待（waiting）的语义对于实际实现来说并不理想。==

As the old saying goes, in theory, there is no difference between theory and practice, but in practice, there is.
==正如俗话所说，在理论上，理论和实践没有区别，但在实践中，确实有区别。==

OLD SAYING: THEORY VS. PRACTICE
==俗话说：理论与实践==

The old saying is “in theory, there is no difference between theory and practice, but in practice, there is.”
==俗话说得好：“在理论上，理论和实践没有区别，但在实践中，确实有区别。”==

Of course, only practitioners tell you this; a theory person could undoubtedly prove that it is not true.
==当然，只有实践者会告诉你这一点；理论家无疑可以证明这不是真的。==

A few years later, Butler Lampson and David Redell of Xerox PARC were building a concurrent language known as **Mesa**, and decided to use monitors as their basic concurrency primitive [LR80].
==几年后，施乐帕克研究中心（Xerox PARC）的 Butler Lampson 和 David Redell 正在开发一种名为 **Mesa** 的并发语言，并决定使用管程作为其基本的并发原语 [LR80]。==

They were well-known systems researchers, and they soon found that Hoare semantics, while more amenable to proofs, were hard to realize in a real system.
==他们是著名的系统研究员，很快发现 Hoare 语义虽然更利于证明，但在实际系统中很难实现。==

In particular, to build a working monitor implementation, Lampson and Redell decided to change the meaning of signal() in a subtle but critical way.
==特别地，为了构建一个可用的管程实现，Lampson 和 Redell 决定以一种微妙但关键的方式改变 signal() 的含义。==

The signal() routine now was just considered a **hint** [L83]; it would move a single waiting thread from the blocked state to a runnable state, but it would not run it immediately.
==signal() 例程现在仅被视为一种**提示** [L83]；它会将一个等待线程从阻塞状态移动到可运行状态，但不会立即运行它。==

Rather, the signaling thread would retain control until it exited the monitor and was descheduled.
==相反，发出信号的线程将保留控制权，直到它退出管程并被取消调度。==

D.4 Oh Oh, A Race
==D.4 噢，竞态条件==

Given these new **Mesa semantics**, let us again reexamine the code above.
==鉴于这些新的 **Mesa 语义**，让我们再次重新检查上面的代码。==

Imagine again a consumer (consumer 1) who enters the monitor and finds the buffer empty and thus waits (C1).
==再次想象一个消费者（消费者 1）进入管程，发现缓冲区为空，因此进入等待状态 (C1)。==

Now the producer comes along and fills the buffer and signals that a buffer has been filled, moving the waiting consumer from blocked on the full condition variable to ready.
==现在生产者出现了，填充了缓冲区并发出信号表示缓冲区已满，将被阻塞在 full 条件变量上的等待消费者移动到就绪状态。==

The producer keeps running for a while, and eventually gives up the CPU.
==生产者继续运行一段时间，最终放弃 CPU。==

But Houston, we have a problem.
==但是，休斯顿，我们遇到了一个问题。==

Can you see it?
==你能看出来吗？==

Imagine a different consumer (consumer 2) now calls into the consume() routine; it will find a full buffer, consume it, and return, setting fullEntries to 0 in the meanwhile.
==想象另一个消费者（消费者 2）现在调用 consume() 例程；它会发现缓冲区已满，将其消耗掉，然后返回，同时将 fullEntries 设置为 0。==

Can you see the problem yet?
==你看到问题了吗？==

Well, here it comes.
==好了，问题来了。==

Our old friend consumer 1 now finally gets to run, and returns from wait(), expecting a buffer to be full (C1...); unfortunately, this is no longer true, as consumer 2 snuck in and consumed the buffer before consumer 1 had a chance to consume it.
==我们的老朋友消费者 1 现在终于开始运行，并从 wait() 返回，期望缓冲区是满的 (C1...)；不幸的是，这不再属实，因为消费者 2 在消费者 1 有机会消耗缓冲区之前就偷偷潜入并消耗掉了它。==

Thus, the code doesn’t work, because in the time between the signal() by the producer and the return from wait() by consumer 1, the condition has changed.
==因此，代码无法工作，因为在生产者发出 signal() 和消费者 1 从 wait() 返回之间的时间里，条件发生了变化。==

This timeline illustrates the problem:
==这个时间轴说明了该问题：==

Figure D.4: Why the Code doesn’t work with Hoare Semantics
==图 D.4：为什么代码在 Hoare 语义下无法正常工作（注：此处原文标题似有误，应指 Mesa 语义下旧代码失效）==

Fortunately, the switch from Hoare semantics to Mesa semantics requires only a small change by the programmer to realize a working solution.
==幸运的是，从 Hoare 语义切换到 Mesa 语义只需要程序员做一点小改动就能实现可行的解决方案。==

Specifically, when woken, a thread should **recheck the condition** it was waiting on; because signal() is only a hint, it is possible that the condition has changed (even multiple times) and thus may not be in the desired state when the waiting thread runs.
==具体来说，当被唤醒时，线程应该**重新检查它正在等待的条件**；因为 signal() 只是一个提示，条件有可能已经改变（甚至多次改变），因此当等待线程运行时，它可能不在所需的状态。==

In our example, two lines of code must change, lines P0 and C0:
==在我们的例子中，必须更改两行代码，即 P0 行和 C0 行：==

```cpp
void produce(int element) {
    while (fullEntries == MAX) // line P0 (CHANGED IF->WHILE)
        wait(&empty);          // line P1
    // ...
}

int consume() {
    while (fullEntries == 0)   // line C0 (CHANGED IF->WHILE)
        wait(&full);           // line C1
    // ...
}
```

Figure D.5: Producer/Consumer with Monitors and Mesa Semantics
==图 D.5：使用管程和 Mesa 语义的生产者/消费者问题==

Not too hard after all.
==毕竟不算太难。==

Because of the ease of this implementation, virtually any system today that uses condition variables with signaling and waiting uses Mesa semantics.
==由于这种实现的简便性，今天几乎所有使用带有信号通知和等待的条件变量的系统都使用 Mesa 语义。==

Thus, if you remember nothing else at all from this class, you can just remember: **always recheck the condition after being woken!**
==因此，如果你在这门课中什么都没记住，你只需记住：**唤醒后务必重新检查条件！**==

Put in even simpler terms, **use while loops and not if statements** when checking conditions.
==用更简单的话来说，在检查条件时，**使用 while 循环而不是 if 语句**。==

Note that this is always correct, even if somehow you are running on a system with Hoare semantics; in that case, you would just needlessly retest the condition an extra time.
==请注意，这始终是正确的，即使你是在具有 Hoare 语义的系统上运行；在这种情况下，你只是不必要地多测试了一次条件。==

D.5 Peeking Under The Hood A Bit
==D.5 深入了解底层实现==

To understand a bit better why Mesa semantics are easier to implement, let’s understand a little more about the implementation of Mesa monitors.
==为了更好地理解为什么 Mesa 语义更容易实现，让我们进一步了解 Mesa 管程的实现。==

In their work [LR80], Lampson and Redell describe three different types of queues that a thread can be a part of at a given time: the **ready queue**, a **monitor lock queue**, and a **condition variable queue**.
==在他们的著作 [LR80] 中，Lampson 和 Redell 描述了线程在给定时间可以参与的三种不同类型的队列：**就绪队列**、**管程锁队列**和**条件变量队列**。==

Note that a program might have multiple monitor classes and multiple condition variable instances; there is a queue per instance of said items.
==请注意，一个程序可能有多个管程类和多个条件变量实例；上述每个实例都有一个队列。==

D.6 Other Uses Of Monitors
==D.6 管程的其他用途==

In their paper on Mesa, Lampson and Redell also point out a few places where a different kind of signaling is needed.
==在关于 Mesa 的论文中，Lampson 和 Redell 还指出了一些需要不同类型信号的场景。==

For example, consider the following memory allocator (Figure D.7).
==例如，考虑以下内存分配器（图 D.7）。==

```cpp
monitor class allocator {
    int available; // how much memory is available?
    cond_t c;

    void *allocate(int size) {
        while (size > available)
            wait(&c);
        available -= size;
        return a_chunk_of_memory;
    }

    void free(void *pointer, int size) {
        available += size;
        signal(&c);
    }
};
```

Figure D.7: A Simple Memory Allocator
==图 D.7：一个简单的内存分配器==

Imagine two threads call allocate.
==想象有两个线程调用 allocate。==

The first calls allocate(20) and the second allocate(10).
==第一个调用 allocate(20)，第二个调用 allocate(10)。==

No memory is available, and thus both threads call wait() and block.
==没有可用内存，因此两个线程都调用 wait() 并阻塞。==

Some time later, a different thread comes along and calls free(p, 15), and thus frees up 15 bytes of memory.
==一段时间后，另一个线程出现并调用 free(p, 15)，从而释放了 15 字节的内存。==

It then signals that it has done so.
==然后它发出信号表示已完成释放。==

Unfortunately, it wakes the thread waiting for 20 bytes; that thread rechecks the condition, finds that only 15 bytes are available, and calls wait() again.
==不幸的是，它唤醒了等待 20 字节的线程；该线程重新检查条件，发现只有 15 字节可用，于是再次调用 wait()。==

The thread that could have benefited from the free of 15 bytes, i.e., the thread that called allocate(10), is not woken.
==本可以从释放的 15 字节中受益的线程，即调用 allocate(10) 的线程，却没有被唤醒。==

Lampson and Redell suggest a simple solution to this problem.
==Lampson 和 Redell 为这个问题提出了一个简单的解决方案。==

Instead of a signal() which wakes a single waiting thread, they employ a **broadcast()** which wakes *all* waiting threads.
==他们不使用唤醒单个等待线程的 signal()，而是采用 **broadcast()** 唤醒*所有*等待线程。==

D.7 Using Monitors To Implement Semaphores
==D.7 使用管程实现信号量==

You can probably see a lot of similarities between monitors and semaphores.
==你可能会发现管程和信号量之间有很多相似之处。==

Not surprisingly, you can use one to implement the other.
==不出所料，你可以用其中一个来实现另一个。==

D.8 Monitors in the Real World
==D.8 现实世界中的管程==

We already mentioned above that we were using “pretend” monitors; C++ has no such concept.
==我们上面已经提到我们使用的是“假装的”管程；C++ 没有这样的概念。==

We now show how to make a monitor-like C++ class, and how Java uses synchronized methods to achieve a similar end.
==我们现在展示如何创建一个类似管程的 C++ 类，以及 Java 如何使用 synchronized 方法来实现类似的目标。==

A Java Monitor
==Java 管程==

Interestingly, the designers of Java decided to use monitors as they thought they were a graceful way to add synchronization primitives into a language.
==有趣的是，Java 的设计者决定使用管程，因为他们认为这是将同步原语添加到语言中的一种优雅方式。==

To use them, you just add the keyword **synchronized** to the method or set of methods that you wish to use as a monitor.
==要使用它们，你只需将关键字 **synchronized** 添加到你希望作为管程使用的方法或方法集中。==

D.9 Summary
==D.9 总结==

We have seen the introduction of monitors, a structuring concept developed by Brinch Hansen and subsequently Hoare in the early seventies.
==我们已经看到了管程的引入，这是由 Brinch Hansen 以及随后的 Hoare 在七十年代初开发的一种结构化概念。==

When running inside the monitor, a thread implicitly holds a monitor lock, and thus prevents other threads from entering the monitor, allowing the ready construction of mutual exclusion.
==在管程内部运行时，线程隐式持有管程锁，从而防止其他线程进入管程，从而可以轻松构建互斥。==

We also have seen the introduction of explicit condition variables, which allow threads to signal() and wait() much like we saw with semaphores in the previous note.
==我们也看到了显式条件变量的引入，它们允许线程进行 signal() 和 wait()，就像我们在前一篇笔记中看到的信号量一样。==

The semantics of signal() and wait() are critical; because all modern systems implement **Mesa semantics**, a recheck of the condition that the thread went to sleep on is required for correct execution.
==signal() 和 wait() 的语义至关重要；因为所有现代系统都实现 **Mesa 语义**，为了正确执行，需要重新检查线程进入睡眠状态时所依据的条件。==

Thus, signal() is just a **hint** that something has changed; it is the responsibility of the woken thread to make sure the conditions are right for its continued execution.
==因此，signal() 只是一个表明某些情况已发生变化的**提示**；被唤醒的线程有责任确保条件适合其继续执行。==




`hw.c` has been modified more recently than `hw.o` has been created, `make` will know that `hw.o` is out of date and should be generated anew; in that case, it will execute the command line, `gcc -O -Wall -c hw.c`, which generates `hw.o`.
==`hw.c` 的修改时间比 `hw.o` 的创建时间更近，`make` 将会知道 `hw.o` 已经过期并应重新生成；在这种情况下，它将执行命令行 `gcc -O -Wall -c hw.c`，从而生成 `hw.o`。==

Thus, if you are compiling a large program, `make` will know which object files need to be re-generated based on their dependencies, and will only do the necessary amount of work to recreate the executable.
==因此，如果你正在编译一个大型程序，`make` 将根据它们的依赖关系知道哪些对象文件需要重新生成，并且只会进行重建可执行文件所需的必要工作。==

Also note that `hw.o` will be created in the case that it does not exist at all.
==另外请注意，如果 `hw.o` 根本不存在，它也会被创建。==

Continuing along, `helper.o` may also be regenerated or created, based on the same criteria as defined above.
==继续往下看，`helper.o` 也可能根据上述定义的相同标准被重新生成或创建。==

When both of the object files have been created, `make` is now ready to execute the command to create the final executable, and goes back and does so: `gcc -o hw hw.o helper.o -lm`.
==当两个对象文件都创建好后，`make` 就可以执行创建最终可执行文件的命令，并返回执行：`gcc -o hw hw.o helper.o -lm`。==

Up until now, we’ve been ignoring the `clean` target in the makefile.
==到目前为止，我们一直忽略了 makefile 中的 `clean` 目标。==

To use it, you have to ask for it explicitly.
==要使用它，你必须显式地请求它。==

Type `prompt> make clean`
==输入 `prompt> make clean`==

This will execute the command on the command line.
==这将执行命令行上的命令。==

Because there are no prerequisites for the `clean` target, typing `make clean` will always result in the command(s) being executed.
==由于 `clean` 目标没有先决条件，输入 `make clean` 总是会导致命令被执行。==

In this case, the `clean` target is used to remove the object files and executable, quite handy if you wish to rebuild the entire program from scratch.
==在这种情况下，`clean` 目标用于删除对象文件和可执行文件，如果你想从头开始重新构建整个程序，这非常方便。==

Now you might be thinking, “well, this seems OK, but these makefiles sure are cumbersome!”
==现在你可能会想，“嗯，这看起来还行，但这些 makefile 确实很麻烦！”==

And you’d be right — if they always had to be written like this.
==你是对的——如果它们总是必须这样写的话。==

Fortunately, there are a lot of shortcuts that make `make` even easier to use.
==幸运的是，有很多快捷方式可以让 `make` 变得更容易使用。==

For example, this makefile has the same functionality but is a little nicer to use:
==例如，这个 makefile 具有相同的功能，但使用起来更舒服一些：==

```makefile
# specify all source files here
SRCS = hw.c helper.c
# specify target here (name of executable)
TARG = hw
# specify compiler, compile flags, and needed libs
CC = gcc
OPTS = -Wall -O
LIBS = -lm

# this translates .c files in src list to .o’s
OBJS = $(SRCS:.c=.o)

# all is not really needed, but is used to generate the target
all: $(TARG)

# this generates the target executable
$(TARG): $(OBJS)
    $(CC) -o $(TARG) $(OBJS) $(LIBS)

# this is a generic rule for .o files
%.o: %.c
    $(CC) $(OPTS) -c $< -o $@

# and finally, a clean line
clean:
    rm -f $(OBJS) $(TARG)
```
```makefile
==# 在此处指定所有源文件==
SRCS = hw.c helper.c
==# 在此处指定目标（可执行文件的名称）==
TARG = hw
==# 指定编译器、编译标志和所需的库==
CC = gcc
OPTS = -Wall -O
LIBS = -lm

==# 这将源列表中的 .c 文件转换为 .o 文件==
OBJS = $(SRCS:.c=.o)

==# all 并不是真正需要的，但用于生成目标==
all: $(TARG)

==# 这将生成目标可执行文件==
$(TARG): $(OBJS)
    $(CC) -o $(TARG) $(OBJS) $(LIBS)

==# 这是一个用于 .o 文件的通用规则==
%.o: %.c
    $(CC) $(OPTS) -c $< -o $@

==# 最后是一个 clean 行==
clean:
    rm -f $(OBJS) $(TARG)
```

Though we won’t go into the details of `make` syntax, as you can see, this makefile can make your life somewhat easier.
==虽然我们不会深入探讨 `make` 语法的细节，但正如你所看到的，这个 makefile 可以让你的生活更轻松一些。==

For example, it allows you to easily add new source files into your build, simply by adding them to the `SRCS` variable at the top of the makefile.
==例如，它允许你通过简单地将新源文件添加到 makefile 顶部的 `SRCS` 变量中，轻松地将它们添加到你的构建中。==

You can also easily change the name of the executable by changing the `TARG` line, and the compiler, flags, and library specifications are all easily modified.
==你还可以通过更改 `TARG` 行来轻松更改可执行文件的名称，并且编译器、标志和库规范也都很容易修改。==

One final word about `make`: figuring out a target’s prerequisites is not always trivial, especially in large and complex programs.
==关于 `make` 的最后一句话：确定一个目标的先决条件并不总是那么容易，特别是在大型和复杂的程序中。==

Not surprisingly, there is another tool that helps with this, called `makedepend`.
==不出所料，还有另一个工具可以提供帮助，叫做 `makedepend`。==

Read about it on your own and see if you can incorporate it into a makefile.
==你自己阅读相关内容，看看是否可以将其整合到 makefile 中。==

**F.7 Debugging**
==**F.7 调试**==

Finally, after you have created a good build environment, and a correctly compiled program, you may find that your program is buggy.
==最后，在你创建了一个良好的构建环境并正确编译了程序之后，你可能会发现你的程序存在漏洞（bug）。==

One way to fix the problem(s) is to think really hard — this method is sometimes successful, but often not.
==解决问题的一种方法是苦思冥想——这种方法有时会成功，但通常不会。==

The problem is a lack of information; you just don’t know exactly what is going on within the program, and therefore cannot figure out why it is not behaving as expected.
==问题在于缺乏信息；你只是不确切知道程序内部发生了什么，因此无法弄清楚它为什么没有按预期运行。==

Fortunately, there is some help: `gdb`, the GNU debugger.
==幸运的是，有一些帮助工具：`gdb`，即 GNU 调试器。==

Let’s take the following buggy code, saved in the file `buggy.c`, and compiled into the executable `buggy`.
==让我们以保存为文件 `buggy.c` 并编译为可执行文件 `buggy` 的以下有漏洞的代码为例。==

```c
#include <stdio.h>
struct Data {
    int x;
};

int
main(int argc, char *argv[])
{
    struct Data *p = NULL;
    printf("%d\n", p->x);
}
```
```c
#include <stdio.h>
struct Data {
    int x;
};

int
main(int argc, char *argv[])
{
    struct Data *p = NULL;
    printf("%d\n", p->x);
}
```

In this example, the main program dereferences the variable `p` when it is `NULL`, which will lead to a segmentation fault.
==在这个例子中，主程序在变量 `p` 为 `NULL` 时对其进行解引用，这将导致段错误（segmentation fault）。==

Of course, this problem should be easy to fix by inspection, but in a more complex program, finding such a problem is not always easy.
==当然，这个问题通过检查应该很容易修复，但在更复杂的程序中，发现这样的问题并不总是那么容易。==

To prepare yourself for a debugging session, recompile your program and make sure to pass the `-g` flag to each compile line.
==为了准备调试会话，请重新编译你的程序，并确保在每个编译行中都传递 `-g` 标志。==

This includes extra debugging information in your executable that will be useful during your debugging session.
==这会在你的可执行文件中包含额外的调试信息，这些信息在调试会话期间非常有用。==

Also, don’t turn on optimization (`-O`); though this may work, it may also lead to confusion during debugging.
==此外，不要开启优化（`-O`）；虽然这可能可行，但也可能在调试过程中导致混乱。==

After re-compiling with `-g`, you are ready to use the debugger.
==使用 `-g` 重新编译后，你就可以使用调试器了。==

Fire up `gdb` at the command prompt as follows: `prompt> gdb buggy`
==在命令提示符下启动 `gdb`，如下所示：`prompt> gdb buggy`==

This puts you inside an interactive session with the debugger.
==这将使你进入与调试器的交互式会话。==

Note that you can also use the debugger to examine “core” files that were produced during bad runs, or to attach to an already-running program; read the documentation to learn more about this.
==请注意，你还可以使用调试器检查在运行失败时产生的“核心（core）”文件，或者附加到一个已经在运行的程序；阅读文档以了解更多相关信息。==

Once inside, you may see something like this:
==进入后，你可能会看到类似这样的内容：==

```text
prompt> gdb buggy
GNU gdb ...
Copyright 2008 Free Software Foundation, Inc.
(gdb)
```
```text
prompt> gdb buggy
GNU gdb ...
Copyright 2008 Free Software Foundation, Inc.
(gdb)
```

The first thing you might want to do is to go ahead and run the program.
==你可能想做的第一件事就是继续运行程序。==

To do this, simply type `run` at `gdb` command prompt.
==为此，只需在 `gdb` 命令提示符下输入 `run`。==

In this case, this is what you might see:
==在这种情况下，你可能会看到以下内容：==

```text
(gdb) run
Starting program: buggy

Program received signal SIGSEGV, Segmentation fault.
0x8048433 in main (argc=1, argv=0xbffff844) at buggy.c:19
19 printf("%d\n", p->x);
```
```text
(gdb) run
Starting program: buggy

==程序接收到信号 SIGSEGV，段错误。==
0x8048433 in main (argc=1, argv=0xbffff844) at buggy.c:19
19 printf("%d\n", p->x);
```

As you can see from the example, in this case, `gdb` immediately pinpoints where the problem occurred; a “segmentation fault” was generated at the line where we tried to dereference `p`.
==正如你从例子中看到的，在这种情况下，`gdb` 立即指出了问题发生的位置；在我们尝试对 `p` 进行解引用的那一行产生了一个“段错误”。==

This just means that we accessed some memory that we weren’t supposed to access.
==这仅仅意味着我们访问了一些本不该访问的内存。==

At this point, the astute programmer can examine the code, and say “aha! it must be that `p` does not point to anything valid, and thus should not be dereferenced!”, and then go ahead and fix the problem.
==此时，精明的程序员可以检查代码并说：“啊哈！一定是 `p` 没有指向任何有效的东西，因此不应该被解引用！”，然后着手修复问题。==

However, if you didn’t know what was going on, you might want to examine some variable.
==然而，如果你不知道发生了什么，你可能想检查某些变量。==

`gdb` allows you to do this interactively during the debug session.
==`gdb` 允许你在调试会话期间交互式地执行此操作。==

```text
(gdb) print p
$1 = (struct Data *) 0x0
```
```text
(gdb) print p
$1 = (struct Data *) 0x0
```

By using the `print` primitive, we can examine `p`, and see both that it is a pointer to a struct of type `Data`, and that it is currently set to `NULL` (or zero, or hex zero which is shown here as “0x0”).
==通过使用 `print` 原语，我们可以检查 `p`，并看到它是一个指向 `Data` 类型结构体的指针，并且当前被设置为 `NULL`（或零，或此处显示为“0x0”的十六进制零）。==

Finally, you can also set breakpoints within your program to have the debugger stop the program at a certain routine.
==最后，你还可以在程序中设置断点，让调试器在某个例程处停止程序。==

After doing this, it is often useful to step through the execution (one line at a time), and see what is happening.
==完成此操作后，逐步执行（一次一行）并查看发生了什么是很有用的。==

```text
(gdb) break main
Breakpoint 1 at 0x8048426: file buggy.c, line 17.
(gdb) run
Starting program: /homes/hacker/buggy

Breakpoint 1, main (argc=1, argv=0xbffff844) at buggy.c:17
17 struct Data *p = NULL;
(gdb) next
19 printf("%d\n", p->x);
(gdb) next

Program received signal SIGSEGV, Segmentation fault.
0x8048433 in main (argc=1, argv=0xbffff844) at buggy.c:19
19 printf("%d\n", p->x);
```
```text
(gdb) break main
==断点 1 位于 0x8048426：文件 buggy.c，第 17 行。==
(gdb) run
==正在启动程序：/homes/hacker/buggy==

==断点 1，main (argc=1, argv=0xbffff844) 位于 buggy.c:17==
17 struct Data *p = NULL;
(gdb) next
19 printf("%d\n", p->x);
(gdb) next

==程序接收到信号 SIGSEGV，段错误。==
0x8048433 in main (argc=1, argv=0xbffff844) at buggy.c:19
19 printf("%d\n", p->x);
```

In the example above, a breakpoint is set at the `main()` routine; thus, when we run the program, the debugger almost immediately stops execution at `main`.
==在上面的例子中，在 `main()` 例程处设置了一个断点；因此，当我们运行程序时，调试器几乎立即在 `main` 处停止执行。==

At that point in the example, a `next` command is issued, which executes the next source-level command.
==在例子的那个点上，发出了一个 `next` 命令，它执行下一个源码级命令。==

Both `next` and `step` are useful ways to advance through a program — read about them in the documentation for more details.
==`next` 和 `step` 都是在程序中推进的有用方式——阅读文档以获取更多细节。==

This discussion really does not do `gdb` justice; it is a rich and flexible debugging tool, with many more features than can be described in the limited space here.
==这里的讨论确实有失公允，没能充分展现 `gdb` 的强大；它是一个功能丰富且灵活的调试工具，其功能远多于在此有限空间内所能描述的。==

Read more about it on your own and become an expert in your copious spare time.
==在你的大量业余时间里多读读相关内容，成为一名专家。==

**F.8 Documentation**
==**F.8 文档**==

To learn a lot more about all of these things, you have to do two things: the first is to use these tools, and the second is to read more about them on your own.
==要了解有关所有这些内容的更多信息，你必须做两件事：第一是使用这些工具，第二是自己阅读更多关于它们的信息。==

One way to find out more about `gcc`, `gmake`, and `gdb` is to read their `man` pages; type `man gcc`, `man gmake`, or `man gdb` at your command prompt.
==了解更多关于 `gcc`、`gmake` 和 `gdb` 的一种方法是阅读它们的 `man` 手册页；在命令提示符下输入 `man gcc`、`man gmake` 或 `man gdb`。==

You can also use `man -k` to search the `man` pages for keywords, though that doesn’t always work as well as it might; googling is probably a better approach here.
==你还可以使用 `man -k` 在 `man` 手册页中搜索关键字，尽管这并不总是那么有效；在这里，谷歌搜索可能是更好的方法。==

One tricky thing about `man` pages: typing `man XXX` may not result in the thing you want, if there is more than one thing called `XXX`.
==`man` 手册页中一件棘手的事情：如果有一个以上的东西叫 `XXX`，输入 `man XXX` 可能不会得到你想要的东西。==

For example, if you are looking for the `kill()` system call `man` page, and if you just type `man kill` at the prompt, you will get the wrong `man` page, because there is a command-line program called `kill`.
==例如，如果你正在寻找 `kill()` 系统调用的 `man` 手册页，如果你只是在提示符下输入 `man kill`，你会得到错误的 `man` 手册页，因为有一个名为 `kill` 的命令行程序。==

`Man` pages are divided into sections, and by default, `man` will return the `man` page in the lowest section that it finds, which in this case is section 1.
==`Man` 手册页被分为不同的章节，默认情况下，`man` 会返回它找到的最低章节中的 `man` 手册页，在本例中是第 1 节。==

Note that you can tell which `man` page you got by looking at the top of the page: if you see `kill(2)`, you know you are in the right `man` page in Section 2, where system calls live.
==请注意，你可以通过查看页面顶部来判断你得到的是哪个 `man` 手册页：如果你看到 `kill(2)`，你就知道你是在第 2 节中正确的 `man` 手册页里，那是系统调用所在的地方。==

Type `man man` to learn more about what is stored in each of the different sections of the `man` pages.
==输入 `man man` 以了解更多关于 `man` 手册页每个不同章节中存储内容的信息。==

Also note that `man -a kill` can be used to cycle through all of the different `man` pages named “kill”.
==另请注意，`man -a kill` 可用于循环查看所有名为“kill”的不同 `man` 手册页。==

`Man` pages are useful for finding out a number of things.
==`Man` 手册页对于查寻许多事情都很有用。==

In particular, you will often want to look up what arguments to pass to a library call, or what header files need to be included to use a library call.
==特别地，你经常会想要查找传递给库调用的参数，或者使用库调用需要包含哪些头文件。==

All of this should be available in the `man` page.
==所有这些都应该可以在 `man` 手册页中找到。==

For example, if you look up the `open()` system call, you will see:
==例如，如果你查找 `open()` 系统调用，你会看到：==

```text
SYNOPSIS
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *path, int oflag, /* mode_t mode */...);
```
```text
==大纲==
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *path, int oflag, /* mode_t mode */...);
```

That tells you to include the headers `sys/types.h`, `sys/stat.h`, and `fcntl.h` in order to use the `open` call.
==这告诉你要包含头文件 `sys/types.h`、`sys/stat.h` 和 `fcntl.h` 才能使用 `open` 调用。==

It also tells you about the parameters to pass to `open`, namely a string called `path`, and integer flag `oflag`, and an optional argument to specify the `mode` of the file.
==它还告诉你传递给 `open` 的参数，即一个名为 `path` 的字符串、整数标志 `oflag`，以及一个用于指定文件 `mode`（模式）的可选参数。==

If there were any libraries you needed to link with to use the call, it would tell you that here too.
==如果使用该调用需要链接任何库，它也会在这里告诉你。==

`Man` pages require some effort to use effectively.
==有效使用 `man` 手册页需要一些努力。==

They are often divided into a number of standard sections.
==它们通常被分为若干标准章节。==

The main body will describe how you can pass different parameters in order to have the function behave differently.
==正文将描述你如何传递不同的参数，以便让函数表现出不同的行为。==

One particularly useful section is called the **RETURN VALUES** part of the `man` page, and it tells you what the function will return under success or failure.
==一个特别有用的部分是 `man` 手册页中名为 **RETURN VALUES**（返回值）的部分，它会告诉你函数在成功或失败时会返回什么。==

From the `open()` `man` page again:
==再次引用 `open()` 的 `man` 手册页：==

```text
RETURN VALUES
Upon successful completion, the open() function opens the file and return a non-negative integer representing the lowest numbered unused file descriptor. Otherwise, -1 is returned, errno is set to indicate the error, and no files are created or modified.
```
```text
==返回值==
==成功完成后，open() 函数将打开文件并返回一个非负整数，代表编号最低的未使用文件描述符。否则，返回 -1，设置 errno 以指示错误，并且不创建或修改任何文件。==
```

Thus, by checking what `open` returns, you can see if the `open` succeeded or not.
==因此，通过检查 `open` 的返回值，你可以查看 `open` 是否成功。==

If it didn’t, `open` (and many standard library routines) will set a global variable called `errno` to a value to tell you about the error.
==如果没成功，`open`（以及许多标准库例程）将把一个名为 `errno` 的全局变量设置为一个值，以告知你错误信息。==

See the **ERRORS** section of the `man` page for more details.
==有关更多详细信息，请参阅 `man` 手册页的 **ERRORS**（错误）部分。==

Another thing you might want to do is to look for the definition of a structure that is not specified in the `man` page itself.
==你可能想做的另一件事是寻找 `man` 手册页本身未指定的结构体定义。==

For example, the `man` page for `gettimeofday()` has the following synopsis:
==例如，`gettimeofday()` 的 `man` 手册页有以下大纲：==

```text
SYNOPSIS
#include <sys/time.h>
int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
```
```text
==大纲==
#include <sys/time.h>
int gettimeofday(struct timeval *restrict tp, void *restrict tzp);
```

From this page, you can see that the time is put into a structure of type `timeval`, but the `man` page may not tell you what fields that struct has!
==从这个页面你可以看到，时间被放入一个 `timeval` 类型的结构体中，但 `man` 手册页可能不会告诉你该结构体有哪些字段！==

(In this case, it does, but you may not always be so lucky)
==（在这种情况下它确实告诉了，但你并不总是那么幸运）==

Thus, you may have to hunt for it.
==因此，你可能不得不去寻找它。==

All include files are found under the directory `/usr/include`, and thus you can use a tool like `grep` to look for it.
==所有包含文件都位于 `/usr/include` 目录下，因此你可以使用像 `grep` 这样的工具来寻找它。==

For example, you might type: `prompt> grep ’struct timeval’ /usr/include/sys/*.h`
==例如，你可以输入：`prompt> grep ’struct timeval’ /usr/include/sys/*.h`==

This lets you look for the definition of the structure in all files that end with `.h` in `/usr/include/sys`.
==这让你在 `/usr/include/sys` 中所有以 `.h` 结尾的文件里寻找该结构体的定义。==

Unfortunately, this may not always work, as that include file may include others which are found elsewhere.
==不幸的是，这并不总是有效，因为该包含文件可能包含在其他地方找到的其他文件。==

A better way to do this is to use a tool at your disposal, the compiler.
==一个更好的方法是使用你可以支配的工具——编译器。==

Write a program that includes the header `time.h`, let’s say called `main.c`.
==编写一个包含头文件 `time.h` 的程序，假设叫做 `main.c`。==

Then, instead of compiling it, use the compiler to invoke the preprocessor.
==然后，不要编译它，而是使用编译器来调用预处理器。==

The preprocessor processes all the directives in your file, such as `#define` commands and `#include` commands.
==预处理器处理文件中的所有指令，例如 `#define` 命令和 `#include` 命令。==

To do this, type `gcc -E main.c`.
==为此，输入 `gcc -E main.c`。==

The result of this is a C file that has all of the needed structures and prototypes in it, including the definition of the `timeval` struct.
==其结果是一个包含所有所需结构体和原型的 C 文件，包括 `timeval` 结构体的定义。==

Probably an even better way to find these things out: google.
==寻找这些东西可能还有一个更好的方法：谷歌。==

You should always google things you don’t know about — it’s amazing how much you can learn simply by looking it up!
==你总是应该谷歌搜索你不了解的事情——仅仅通过查阅就能学到这么多东西，真是令人惊讶！==

**Info Pages**
==**Info 页面**==

Also quite useful in the hunt for documentation are the `info` pages, which provide much more detailed documentation on many GNU tools.
==在寻找文档时，`info` 页面也相当有用，它提供了关于许多 GNU 工具的更为详尽的文档。==

You can access the `info` pages by running the program `info`, or via emacs, the preferred editor of hackers, by executing `Meta-x info`.
==你可以通过运行程序 `info` 来访问 `info` 页面，或者通过黑客首选的编辑器 emacs 执行 `Meta-x info` 来访问。==

A program like `gcc` has hundreds of flags, and some of them are surprisingly useful to know about.
==像 `gcc` 这样的程序有数百个标志，了解其中的一些标志出奇地有用。==

`gmake` has many more features that will improve your build environment.
==`gmake` 有更多可以改善你构建环境的功能。==

Finally, `gdb` is quite a sophisticated debugger.
==最后，`gdb` 是一个相当复杂的调试器。==

Read the `man` and `info` pages, try out features that you hadn’t tried before, and become a power user of your programming tools.
==阅读 `man` 和 `info` 页面，尝试你以前没有尝试过的功能，并成为你编程工具的高级用户。==

**F.9 Suggested Readings**
==**F.9 建议阅读**==

Other than the `man` and `info` pages, there are a number of useful books out there.
==除了 `man` 和 `info` 页面外，还有许多有用的书籍。==

Note that a lot of this information is available for free on-line; however, sometimes having something in book form seems to make it easier to learn.
==请注意，这些信息有很多可以在网上免费获得；然而，有时拥有书籍形式的东西似乎更容易学习。==

Also, always look for O’Reilly books on topics you are interested in; they are almost always of high quality.
==此外，始终寻找你感兴趣的主题的 O’Reilly 书籍；它们的质量几乎总是很高。==

*   **“The C Programming Language”**, by Brian Kernighan and Dennis Ritchie. This is the definitive C book to have.
==    *   **《C 程序设计语言》**，由 Brian Kernighan 和 Dennis Ritchie 著。这是必不可少的权威 C 语言书籍。==

*   **“Managing Projects with make”**, by Andrew Oram and Steve Talbott. A reasonable and short book on make.
==    *   **《使用 make 管理项目》**，由 Andrew Oram 和 Steve Talbott 著。一本合理且简短的关于 make 的书。==

*   **“Debugging with GDB: The GNU Source-Level Debugger”**, by Richard M. Stallman, Roland H. Pesch. A little book on using GDB.
==    *   **《使用 GDB 调试：GNU 源码级调试器》**，由 Richard M. Stallman, Roland H. Pesch 著。一本关于使用 GDB 的小书。==

*   **“Advanced Programming in the UNIX Environment”**, by W. Richard Stevens and Steve Rago. Stevens wrote some excellent books, and this is a must for UNIX hackers.
==    *   **《UNIX 环境高级编程》**，由 W. Richard Stevens 和 Steve Rago 著。Stevens 写了一些优秀的著作，这是 UNIX 黑客的必读书籍。==

*   **“Expert C Programming”**, by Peter Van der Linden. A lot of the useful tips about compilers, etc., above are stolen directly from here.
==    *   **《C 专家编程》**，由 Peter Van der Linden 著。上面关于编译器等许多有用的提示直接“窃取”自这本书。==

**G Laboratory: Systems Projects**
==**G 实验室：系统项目**==

This chapter presents some ideas for systems projects.
==本章介绍了一些系统项目的想法。==

We usually do about six or seven projects in a 15-week semester, meaning one every two weeks or so.
==我们通常在一个 15 周的学期里做大约六七个项目，这意味着大约每两周做一个。==

The first few are usually done by a single student, and the last few in groups of size two.
==前几个通常由单个学生完成，最后几个由两人一组完成。==

Each semester, the projects follow this same outline; however, we vary the details to keep it interesting and make “sharing” of code across semesters more challenging.
==每学期，项目都遵循相同的框架；然而，我们会改变细节以保持其趣味性，并使跨学期的代码“共享”更具挑战性。==

**G.1 Intro Project**
==**G.1 入门项目**==

The first project is an introduction to systems programming.
==第一个项目是系统编程简介。==

Typical assignments have been to write some variant of the `sort` utility, with different constraints.
==典型的作业是编写 `sort` 工具的一些变体，并带有不同的约束。==

To complete the project, one must get familiar with some system calls (and their return error codes), use a few simple data structures, and not much else.
==要完成该项目，必须熟悉一些系统调用（及其返回错误代码），使用一些简单的数据结构，仅此而已。==

**G.2 UNIX Shell**
**G.2 UNIX Shell**

In this project, students build a variant of a UNIX shell.
==在这个项目中，学生们构建一个 UNIX shell 的变体。==

Students learn about process management as well as how mysterious things like pipes and redirects actually work.
==学生们学习进程管理，以及像管道和重定向这样神秘的东西实际上是如何工作的。==

**G.3 Memory-allocation Library**
==**G.3 内存分配库**==

This project explores how a chunk of memory is managed, by building an alternative memory-allocation library (like `malloc()` and `free()` but with different names).
==该项目通过构建一个替代内存分配库（类似于 `malloc()` 和 `free()` 但名称不同）来探索如何管理一块内存。==

The project teaches students how to use `mmap()` to get a chunk of anonymous memory, and then about pointers in great detail in order to build a simple (or perhaps, more complex) free list to manage the space.
==该项目教学生如何使用 `mmap()` 获取一块匿名内存，然后非常详细地学习指针，以便构建一个简单的（或者可能更复杂的）空闲列表来管理空间。==

**G.4 Intro to Concurrency**
==**G.4 并发入门**==

This project introduces concurrent programming with POSIX threads.
==该项目介绍了使用 POSIX 线程进行并发编程。==

Build some simple thread-safe libraries: a list, hash table, and some more complicated data structures are good exercises in adding locks to real-world code.
==构建一些简单的线程安全库：列表、哈希表和一些更复杂的数据结构是在现实代码中添加锁的良好练习。==

**G.5 Concurrent Web Server**
==**G.5 并发 Web 服务器**==

This project explores the use of concurrency in a real-world application.
==该项目探索了并发在现实应用中的使用。==

Students take a simple web server (or build one) and add a thread pool to it, in order to serve requests concurrently.
==学生们使用一个简单的 Web 服务器（或构建一个）并向其中添加一个线程池，以便并发地处理请求。==

**G.6 File System Checker**
==**G.6 文件系统检查器**==

This project explores on-disk data structures and their consistency.
==该项目探索了磁盘上的数据结构及其一致性。==

Students build a simple file system checker.
==学生们构建一个简单的文件系统检查器。==

**H Laboratory: xv6 Projects**
==**H 实验室：xv6 项目**==

This chapter presents some ideas for projects related to the `xv6` kernel.
==本章介绍了一些与 `xv6` 内核相关的项目想法。==

The kernel is available from MIT and is quite fun to play with; doing these projects also make the in-class material more directly relevant to the projects.
==该内核可从 MIT 获得，玩起来很有趣；做这些项目也使得课堂材料与项目的关联更加直接。==

**H.1 Intro Project**
==**H.1 入门项目**==

The introduction adds a simple system call to `xv6`.
==入门项目向 `xv6` 添加一个简单的系统调用。==

Many variants are possible, including a system call to count how many system calls have taken place, or other information-gathering calls.
==许多变体都是可能的，包括统计发生了多少次系统调用的系统调用，或其他信息收集调用。==

**H.2 Processes and Scheduling**
==**H.2 进程与调度**==

Students build a more complicated scheduler than the default round robin.
==学生们构建一个比默认轮询调度更复杂的调度器。==

Many variants are possible, including a Lottery scheduler or multi-level feedback queue.
==许多变体都是可能的，包括彩票调度器或多级反馈队列。==

**H.3 Intro to Virtual Memory**
==**H.3 虚拟内存入门**==

The basic idea is to add a new system call that, given a virtual address, returns the translated physical address.
==基本思路是添加一个新的系统调用，给定一个虚拟地址，返回转换后的物理地址。==

This lets students see how the virtual memory system sets up page tables without doing too much hard work.
==这让学生们可以看到虚拟内存系统如何在不进行太多艰苦工作的情况下设置页表。==

**H.4 Copy-on-write Mappings**
==**H.4 写时复制映射**==

This project adds the ability to perform a lightweight `fork()`, called `vfork()`, to `xv6`.
==该项目向 `xv6` 添加了执行轻量级 `fork()`（称为 `vfork()`）的能力。==

This new call doesn’t simply copy the mappings but rather sets up copy-on-write mappings to shared pages.
==这个新调用不只是简单地复制映射，而是为共享页面设置写时复制映射。==

**H.11 File System Checker**
==**H.11 文件系统检查器**==

Students build a simple file system checker for the `xv6` file system.
==学生们为 `xv6` 文件系统构建一个简单的文件系统检查器。==

Students learn about what makes a file system consistent and how exactly to check for it.
==学生们学习什么使文件系统保持一致，以及究竟如何对其进行检查。==

